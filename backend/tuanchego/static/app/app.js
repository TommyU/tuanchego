(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.activities', [
        // Angular dependencies
        'ngCookies',

        // 3rd party
        'ui.bootstrap', 'ui.select',

        // tuanchego dependencies
        'app.activities.services']);
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }return s;
})({ 1: [function (require, module, exports) {
    angular.module('app.utils', []);
  }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.base', ['ui.bootstrap']);
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }return s;
})({ 1: [function (require, module, exports) {
    /**
     * app.directives is a container for all global lily related Angular directives
     */
    angular.module('app.directives', []);
  }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }return s;
})({ 1: [function (require, module, exports) {
    angular.module('app.filters', []);
  }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }return s;
})({ 1: [function (require, module, exports) {
    angular.module('app.services', []);
  }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }return s;
})({ 1: [function (require, module, exports) {
    angular.module('app.users.filters', []);
  }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }return s;
})({ 1: [function (require, module, exports) {
    angular.module('app.users.services', ['ngResource']);
  }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }return s;
})({ 1: [function (require, module, exports) {
    angular.module('app.utils.directives', []);
  }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }return s;
})({ 1: [function (require, module, exports) {
    // Include libraries.
    var Raven = require('raven-js');

    window.sprintf = require('sprintf-js').sprintf;

    require('angular-xeditable');
    require('angular-ui-bootstrap');
    require('sweetalert2');
    require('angular-elastic');
    require('ui-select');

    /**
     * App Module is the entry point for Lily related Angular code
     */
    angular.module('app', ['angular.filter', 'ui.router', 'ui.bootstrap', 'ui.select', 'ngResource', 'ngSanitize', 'ncy-angular-breadcrumb', 'xeditable', 'angular-cache',
    //'ngFileUpload',
    'monospaced.elastic',

    // Modules
    'app.base', 'app.templates',

    // Directives
    'app.directives', 'app.utils.directives',

    // Services
    'app.services',

    // Filters
    'app.filters']);

    angular.module('app').config(appConfig);

    appConfig.$inject = ['$breadcrumbProvider', '$controllerProvider', '$httpProvider', '$resourceProvider', '$urlRouterProvider'];
    function appConfig($breadcrumbProvider, $controllerProvider, $httpProvider, $resourceProvider, $urlRouterProvider) {
      // Don't strip trailing slashes from calculated URLs, because Django needs them.
      $breadcrumbProvider.setOptions({
        templateUrl: 'base/breadcrumbs.html',
        includeAbstract: true
      });
      $controllerProvider.allowGlobals();
      $httpProvider.defaults.xsrfCookieName = 'csrftoken';
      $httpProvider.defaults.xsrfHeaderName = 'X-CSRFToken';
      $resourceProvider.defaults.stripTrailingSlashes = false;
      $urlRouterProvider.otherwise('/');

      swal.setDefaults({
        confirmButtonClass: 'btn btn-primary',
        cancelButtonClass: 'btn btn-default',
        buttonsStyling: false
      });
    }

    // Global exception handler.
    angular.module('app').factory('$exceptionHandler', ['$log', function ($log) {
      return function (exception) {
        if (window.debug) {
          // Log to console when developing.
          $log.error(exception);
        } else {
          // Otherwise send to Sentry.
          Raven.captureException(exception);
        }
      };
    }]);

    /* Init global settings and run the app. */
    angular.module('app').run(runApp);

    runApp.$inject = ['$rootScope', '$state', 'editableOptions', 'HLMessages', 'HLSockets', 'HLNotifications'];
    function runApp($rootScope, $state, editableOptions, HLMessages, HLSockets, HLNotifications, UserTeams) {
      $rootScope.$state = $state; // State to be accessed from view.
      $rootScope.currentUser = currentUser;
      $rootScope.messages = HLMessages;
      window.messages = HLMessages;

      // Get tenant name to set custom dimension for GA.
      /*Tenant.query({}, function(tenant) {
          ga('set', 'dimension1', tenant.name);
      });*/

      // Get team name to set custom dimension for GA.
      /*UserTeams.mine(function(teams) {
          if (teams[0]) {
              ga('set', 'dimension2', teams[0].name);
          }
      });*/

      editableOptions.theme = 'bs3';

      /*new window.Intercom('boot', {
          app_id: intercomAppId,
          user_id: currentUser.id,
          name: currentUser.fullName,
          email: currentUser.email,
          company: currentUser.company,
          widget: {
              activator: '#IntercomDefaultWidget',
          },
      });*/

      // Only setup if we're in the live app.
      /*if (!window.debug) {
          // Setup Raven for global JS error logging.
          Raven.config(window.sentryPublicDsn).addPlugin(require('raven-js/plugins/angular'), angular).install();
          Raven.setUserContext({
              id: currentUser.id,
          });
      }*/
    }
  }, { "angular-elastic": 8, "angular-ui-bootstrap": 7, "angular-xeditable": 4, "raven-js": 12, "sprintf-js": 5, "sweetalert2": 15, "ui-select": 3 }], 2: [function (require, module, exports) {
    /*!
     * ui-select
     * http://github.com/angular-ui/ui-select
     * Version: 0.19.3 - 2016-08-17T06:16:41.345Z
     * License: MIT
     */

    (function () {
      "use strict";

      var KEY = {
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        SPACE: 32,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        HOME: 36,
        END: 35,
        BACKSPACE: 8,
        DELETE: 46,
        COMMAND: 91,

        MAP: { 91: "COMMAND", 8: "BACKSPACE", 9: "TAB", 13: "ENTER", 16: "SHIFT", 17: "CTRL", 18: "ALT", 19: "PAUSEBREAK", 20: "CAPSLOCK", 27: "ESC", 32: "SPACE", 33: "PAGE_UP", 34: "PAGE_DOWN", 35: "END", 36: "HOME", 37: "LEFT", 38: "UP", 39: "RIGHT", 40: "DOWN", 43: "+", 44: "PRINTSCREEN", 45: "INSERT", 46: "DELETE", 48: "0", 49: "1", 50: "2", 51: "3", 52: "4", 53: "5", 54: "6", 55: "7", 56: "8", 57: "9", 59: ";", 61: "=", 65: "A", 66: "B", 67: "C", 68: "D", 69: "E", 70: "F", 71: "G", 72: "H", 73: "I", 74: "J", 75: "K", 76: "L", 77: "M", 78: "N", 79: "O", 80: "P", 81: "Q", 82: "R", 83: "S", 84: "T", 85: "U", 86: "V", 87: "W", 88: "X", 89: "Y", 90: "Z", 96: "0", 97: "1", 98: "2", 99: "3", 100: "4", 101: "5", 102: "6", 103: "7", 104: "8", 105: "9", 106: "*", 107: "+", 109: "-", 110: ".", 111: "/", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NUMLOCK", 145: "SCROLLLOCK", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'"
        },

        isControl: function isControl(e) {
          var k = e.which;
          switch (k) {
            case KEY.COMMAND:
            case KEY.SHIFT:
            case KEY.CTRL:
            case KEY.ALT:
              return true;
          }

          if (e.metaKey || e.ctrlKey || e.altKey) return true;

          return false;
        },
        isFunctionKey: function isFunctionKey(k) {
          k = k.which ? k.which : k;
          return k >= 112 && k <= 123;
        },
        isVerticalMovement: function isVerticalMovement(k) {
          return ~[KEY.UP, KEY.DOWN].indexOf(k);
        },
        isHorizontalMovement: function isHorizontalMovement(k) {
          return ~[KEY.LEFT, KEY.RIGHT, KEY.BACKSPACE, KEY.DELETE].indexOf(k);
        },
        toSeparator: function toSeparator(k) {
          var sep = { ENTER: "\n", TAB: "\t", SPACE: " " }[k];
          if (sep) return sep;
          // return undefined for special keys other than enter, tab or space.
          // no way to use them to cut strings.
          return KEY[k] ? undefined : k;
        }
      };

      /**
       * Add querySelectorAll() to jqLite.
       *
       * jqLite find() is limited to lookups by tag name.
       * TODO This will change with future versions of AngularJS, to be removed when this happens
       *
       * See jqLite.find - why not use querySelectorAll? https://github.com/angular/angular.js/issues/3586
       * See feat(jqLite): use querySelectorAll instead of getElementsByTagName in jqLite.find https://github.com/angular/angular.js/pull/3598
       */
      if (angular.element.prototype.querySelectorAll === undefined) {
        angular.element.prototype.querySelectorAll = function (selector) {
          return angular.element(this[0].querySelectorAll(selector));
        };
      }

      /**
       * Add closest() to jqLite.
       */
      if (angular.element.prototype.closest === undefined) {
        angular.element.prototype.closest = function (selector) {
          var elem = this[0];
          var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;

          while (elem) {
            if (matchesSelector.bind(elem)(selector)) {
              return elem;
            } else {
              elem = elem.parentElement;
            }
          }
          return false;
        };
      }

      var latestId = 0;

      var uis = angular.module('ui.select', []).constant('uiSelectConfig', {
        theme: 'bootstrap',
        searchEnabled: true,
        sortable: false,
        placeholder: '', // Empty by default, like HTML tag <select>
        refreshDelay: 1000, // In milliseconds
        closeOnSelect: true,
        skipFocusser: false,
        dropdownPosition: 'auto',
        removeSelected: true,
        resetSearchInput: true,
        generateId: function generateId() {
          return latestId++;
        },
        appendToBody: false
      })

      // See Rename minErr and make it accessible from outside https://github.com/angular/angular.js/issues/6913
      .service('uiSelectMinErr', function () {
        var minErr = angular.$$minErr('ui.select');
        return function () {
          var error = minErr.apply(this, arguments);
          var message = error.message.replace(new RegExp('\nhttp://errors.angularjs.org/.*'), '');
          return new Error(message);
        };
      })

      // Recreates old behavior of ng-transclude. Used internally.
      .directive('uisTranscludeAppend', function () {
        return {
          link: function link(scope, element, attrs, ctrl, transclude) {
            transclude(scope, function (clone) {
              element.append(clone);
            });
          }
        };
      })

      /**
       * Highlights text that matches $select.search.
       *
       * Taken from AngularUI Bootstrap Typeahead
       * See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L340
       */
      .filter('highlight', function () {
        function escapeRegexp(queryToEscape) {
          return ('' + queryToEscape).replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
        }

        return function (matchItem, query) {
          return query && matchItem ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<span class="ui-select-highlight">$&</span>') : matchItem;
        };
      })

      /**
       * A read-only equivalent of jQuery's offset function: http://api.jquery.com/offset/
       *
       * Taken from AngularUI Bootstrap Position:
       * See https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js#L70
       */
      .factory('uisOffset', ['$document', '$window', function ($document, $window) {

        return function (element) {
          var boundingClientRect = element[0].getBoundingClientRect();
          return {
            width: boundingClientRect.width || element.prop('offsetWidth'),
            height: boundingClientRect.height || element.prop('offsetHeight'),
            top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
            left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
          };
        };
      }]);

      uis.directive('uiSelectChoices', ['uiSelectConfig', 'uisRepeatParser', 'uiSelectMinErr', '$compile', '$window', function (uiSelectConfig, RepeatParser, uiSelectMinErr, $compile, $window) {

        return {
          restrict: 'EA',
          require: '^uiSelect',
          replace: true,
          transclude: true,
          templateUrl: function templateUrl(tElement) {
            // Needed so the uiSelect can detect the transcluded content
            tElement.addClass('ui-select-choices');

            // Gets theme attribute from parent (ui-select)
            var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
            return theme + '/choices.tpl.html';
          },

          compile: function compile(tElement, tAttrs) {

            if (!tAttrs.repeat) throw uiSelectMinErr('repeat', "Expected 'repeat' expression.");

            // var repeat = RepeatParser.parse(attrs.repeat);
            var groupByExp = tAttrs.groupBy;
            var groupFilterExp = tAttrs.groupFilter;

            if (groupByExp) {
              var groups = tElement.querySelectorAll('.ui-select-choices-group');
              if (groups.length !== 1) throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-group but got '{0}'.", groups.length);
              groups.attr('ng-repeat', RepeatParser.getGroupNgRepeatExpression());
            }

            var parserResult = RepeatParser.parse(tAttrs.repeat);

            var choices = tElement.querySelectorAll('.ui-select-choices-row');
            if (choices.length !== 1) {
              throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row but got '{0}'.", choices.length);
            }

            choices.attr('ng-repeat', parserResult.repeatExpression(groupByExp)).attr('ng-if', '$select.open'); //Prevent unnecessary watches when dropdown is closed


            var rowsInner = tElement.querySelectorAll('.ui-select-choices-row-inner');
            if (rowsInner.length !== 1) {
              throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row-inner but got '{0}'.", rowsInner.length);
            }
            rowsInner.attr('uis-transclude-append', ''); //Adding uisTranscludeAppend directive to row element after choices element has ngRepeat

            // If IE8 then need to target rowsInner to apply the ng-click attr as choices will not capture the event. 
            var clickTarget = $window.document.addEventListener ? choices : rowsInner;
            clickTarget.attr('ng-click', '$select.select(' + parserResult.itemName + ',$select.skipFocusser,$event)');

            return function link(scope, element, attrs, $select) {

              $select.parseRepeatAttr(attrs.repeat, groupByExp, groupFilterExp); //Result ready at $select.parserResult

              $select.disableChoiceExpression = attrs.uiDisableChoice;
              $select.onHighlightCallback = attrs.onHighlight;

              $select.dropdownPosition = attrs.position ? attrs.position.toLowerCase() : uiSelectConfig.dropdownPosition;

              scope.$on('$destroy', function () {
                choices.remove();
              });

              scope.$watch('$select.search', function (newValue) {
                if (newValue && !$select.open && $select.multiple) $select.activate(false, true);
                $select.activeIndex = $select.tagging.isActivated ? -1 : 0;
                if (!attrs.minimumInputLength || $select.search.length >= attrs.minimumInputLength) {
                  $select.refresh(attrs.refresh);
                } else {
                  $select.items = [];
                }
              });

              attrs.$observe('refreshDelay', function () {
                // $eval() is needed otherwise we get a string instead of a number
                var refreshDelay = scope.$eval(attrs.refreshDelay);
                $select.refreshDelay = refreshDelay !== undefined ? refreshDelay : uiSelectConfig.refreshDelay;
              });
            };
          }
        };
      }]);

      /**
       * Contains ui-select "intelligence".
       *
       * The goal is to limit dependency on the DOM whenever possible and
       * put as much logic in the controller (instead of the link functions) as possible so it can be easily tested.
       */
      uis.controller('uiSelectCtrl', ['$scope', '$element', '$timeout', '$filter', '$$uisDebounce', 'uisRepeatParser', 'uiSelectMinErr', 'uiSelectConfig', '$parse', '$injector', '$window', function ($scope, $element, $timeout, $filter, $$uisDebounce, RepeatParser, uiSelectMinErr, uiSelectConfig, $parse, $injector, $window) {

        var ctrl = this;

        var EMPTY_SEARCH = '';

        ctrl.placeholder = uiSelectConfig.placeholder;
        ctrl.searchEnabled = uiSelectConfig.searchEnabled;
        ctrl.sortable = uiSelectConfig.sortable;
        ctrl.refreshDelay = uiSelectConfig.refreshDelay;
        ctrl.paste = uiSelectConfig.paste;
        ctrl.resetSearchInput = uiSelectConfig.resetSearchInput;

        ctrl.removeSelected = uiSelectConfig.removeSelected; //If selected item(s) should be removed from dropdown list
        ctrl.closeOnSelect = true; //Initialized inside uiSelect directive link function
        ctrl.skipFocusser = false; //Set to true to avoid returning focus to ctrl when item is selected
        ctrl.search = EMPTY_SEARCH;

        ctrl.activeIndex = 0; //Dropdown of choices
        ctrl.items = []; //All available choices

        ctrl.open = false;
        ctrl.focus = false;
        ctrl.disabled = false;
        ctrl.selected = undefined;

        ctrl.dropdownPosition = 'auto';

        ctrl.focusser = undefined; //Reference to input element used to handle focus events
        ctrl.multiple = undefined; // Initialized inside uiSelect directive link function
        ctrl.disableChoiceExpression = undefined; // Initialized inside uiSelectChoices directive link function
        ctrl.tagging = { isActivated: false, fct: undefined };
        ctrl.taggingTokens = { isActivated: false, tokens: undefined };
        ctrl.lockChoiceExpression = undefined; // Initialized inside uiSelectMatch directive link function
        ctrl.clickTriggeredSelect = false;
        ctrl.$filter = $filter;
        ctrl.$element = $element;

        // Use $injector to check for $animate and store a reference to it
        ctrl.$animate = function () {
          try {
            return $injector.get('$animate');
          } catch (err) {
            // $animate does not exist
            return null;
          }
        }();

        ctrl.searchInput = $element.querySelectorAll('input.ui-select-search');
        if (ctrl.searchInput.length !== 1) {
          throw uiSelectMinErr('searchInput', "Expected 1 input.ui-select-search but got '{0}'.", ctrl.searchInput.length);
        }

        ctrl.isEmpty = function () {
          return angular.isUndefined(ctrl.selected) || ctrl.selected === null || ctrl.selected === '' || ctrl.multiple && ctrl.selected.length === 0;
        };

        function _findIndex(collection, predicate, thisArg) {
          if (collection.findIndex) {
            return collection.findIndex(predicate, thisArg);
          } else {
            var list = Object(collection);
            var length = list.length >>> 0;
            var value;

            for (var i = 0; i < length; i++) {
              value = list[i];
              if (predicate.call(thisArg, value, i, list)) {
                return i;
              }
            }
            return -1;
          }
        }

        // Most of the time the user does not want to empty the search input when in typeahead mode
        function _resetSearchInput() {
          if (ctrl.resetSearchInput) {
            ctrl.search = EMPTY_SEARCH;
            //reset activeIndex
            if (ctrl.selected && ctrl.items.length && !ctrl.multiple) {
              ctrl.activeIndex = _findIndex(ctrl.items, function (item) {
                return angular.equals(this, item);
              }, ctrl.selected);
            }
          }
        }

        function _groupsFilter(groups, groupNames) {
          var i,
              j,
              result = [];
          for (i = 0; i < groupNames.length; i++) {
            for (j = 0; j < groups.length; j++) {
              if (groups[j].name == [groupNames[i]]) {
                result.push(groups[j]);
              }
            }
          }
          return result;
        }

        // When the user clicks on ui-select, displays the dropdown list
        ctrl.activate = function (initSearchValue, avoidReset) {
          if (!ctrl.disabled && !ctrl.open) {
            if (!avoidReset) _resetSearchInput();

            $scope.$broadcast('uis:activate');

            ctrl.open = true;

            ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex;

            // ensure that the index is set to zero for tagging variants
            // that where first option is auto-selected
            if (ctrl.activeIndex === -1 && ctrl.taggingLabel !== false) {
              ctrl.activeIndex = 0;
            }

            var container = $element.querySelectorAll('.ui-select-choices-content');
            var searchInput = $element.querySelectorAll('.ui-select-search');
            if (ctrl.$animate && ctrl.$animate.on && ctrl.$animate.enabled(container[0])) {
              var animateHandler = function animateHandler(elem, phase) {
                if (phase === 'start' && ctrl.items.length === 0) {
                  // Only focus input after the animation has finished
                  ctrl.$animate.off('removeClass', searchInput[0], animateHandler);
                  $timeout(function () {
                    ctrl.focusSearchInput(initSearchValue);
                  });
                } else if (phase === 'close') {
                  // Only focus input after the animation has finished
                  ctrl.$animate.off('enter', container[0], animateHandler);
                  $timeout(function () {
                    ctrl.focusSearchInput(initSearchValue);
                  });
                }
              };

              if (ctrl.items.length > 0) {
                ctrl.$animate.on('enter', container[0], animateHandler);
              } else {
                ctrl.$animate.on('removeClass', searchInput[0], animateHandler);
              }
            } else {
              $timeout(function () {
                ctrl.focusSearchInput(initSearchValue);
                if (!ctrl.tagging.isActivated && ctrl.items.length > 1) {
                  _ensureHighlightVisible();
                }
              });
            }
          } else if (ctrl.open && !ctrl.searchEnabled) {
            // Close the selection if we don't have search enabled, and we click on the select again
            ctrl.close();
          }
        };

        ctrl.focusSearchInput = function (initSearchValue) {
          ctrl.search = initSearchValue || ctrl.search;
          ctrl.searchInput[0].focus();
        };

        ctrl.findGroupByName = function (name) {
          return ctrl.groups && ctrl.groups.filter(function (group) {
            return group.name === name;
          })[0];
        };

        ctrl.parseRepeatAttr = function (repeatAttr, groupByExp, groupFilterExp) {
          function updateGroups(items) {
            var groupFn = $scope.$eval(groupByExp);
            ctrl.groups = [];
            angular.forEach(items, function (item) {
              var groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn];
              var group = ctrl.findGroupByName(groupName);
              if (group) {
                group.items.push(item);
              } else {
                ctrl.groups.push({ name: groupName, items: [item] });
              }
            });
            if (groupFilterExp) {
              var groupFilterFn = $scope.$eval(groupFilterExp);
              if (angular.isFunction(groupFilterFn)) {
                ctrl.groups = groupFilterFn(ctrl.groups);
              } else if (angular.isArray(groupFilterFn)) {
                ctrl.groups = _groupsFilter(ctrl.groups, groupFilterFn);
              }
            }
            ctrl.items = [];
            ctrl.groups.forEach(function (group) {
              ctrl.items = ctrl.items.concat(group.items);
            });
          }

          function setPlainItems(items) {
            ctrl.items = items;
          }

          ctrl.setItemsFn = groupByExp ? updateGroups : setPlainItems;

          ctrl.parserResult = RepeatParser.parse(repeatAttr);

          ctrl.isGrouped = !!groupByExp;
          ctrl.itemProperty = ctrl.parserResult.itemName;

          //If collection is an Object, convert it to Array

          var originalSource = ctrl.parserResult.source;

          //When an object is used as source, we better create an array and use it as 'source'
          var createArrayFromObject = function createArrayFromObject() {
            var origSrc = originalSource($scope);
            $scope.$uisSource = Object.keys(origSrc).map(function (v) {
              var result = {};
              result[ctrl.parserResult.keyName] = v;
              result.value = origSrc[v];
              return result;
            });
          };

          if (ctrl.parserResult.keyName) {
            // Check for (key,value) syntax
            createArrayFromObject();
            ctrl.parserResult.source = $parse('$uisSource' + ctrl.parserResult.filters);
            $scope.$watch(originalSource, function (newVal, oldVal) {
              if (newVal !== oldVal) createArrayFromObject();
            }, true);
          }

          ctrl.refreshItems = function (data) {
            data = data || ctrl.parserResult.source($scope);
            var selectedItems = ctrl.selected;
            //TODO should implement for single mode removeSelected
            if (ctrl.isEmpty() || angular.isArray(selectedItems) && !selectedItems.length || !ctrl.multiple || !ctrl.removeSelected) {
              ctrl.setItemsFn(data);
            } else {
              if (data !== undefined && data !== null) {
                var filteredItems = data.filter(function (i) {
                  return angular.isArray(selectedItems) ? selectedItems.every(function (selectedItem) {
                    return !angular.equals(i, selectedItem);
                  }) : !angular.equals(i, selectedItems);
                });
                ctrl.setItemsFn(filteredItems);
              }
            }
            if (ctrl.dropdownPosition === 'auto' || ctrl.dropdownPosition === 'up') {
              $scope.calculateDropdownPos();
            }

            $scope.$broadcast('uis:refresh');
          };

          // See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L259
          $scope.$watchCollection(ctrl.parserResult.source, function (items) {
            if (items === undefined || items === null) {
              // If the user specifies undefined or null => reset the collection
              // Special case: items can be undefined if the user did not initialized the collection on the scope
              // i.e $scope.addresses = [] is missing
              ctrl.items = [];
            } else {
              if (!angular.isArray(items)) {
                throw uiSelectMinErr('items', "Expected an array but got '{0}'.", items);
              } else {
                //Remove already selected items (ex: while searching)
                //TODO Should add a test
                ctrl.refreshItems(items);

                //update the view value with fresh data from items, if there is a valid model value
                if (angular.isDefined(ctrl.ngModel.$modelValue)) {
                  ctrl.ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters
                }
              }
            }
          });
        };

        var _refreshDelayPromise;

        /**
         * Typeahead mode: lets the user refresh the collection using his own function.
         *
         * See Expose $select.search for external / remote filtering https://github.com/angular-ui/ui-select/pull/31
         */
        ctrl.refresh = function (refreshAttr) {
          if (refreshAttr !== undefined) {

            // Debounce
            // See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L155
            // FYI AngularStrap typeahead does not have debouncing: https://github.com/mgcrea/angular-strap/blob/v2.0.0-rc.4/src/typeahead/typeahead.js#L177
            if (_refreshDelayPromise) {
              $timeout.cancel(_refreshDelayPromise);
            }
            _refreshDelayPromise = $timeout(function () {
              $scope.$eval(refreshAttr);
            }, ctrl.refreshDelay);
          }
        };

        ctrl.isActive = function (itemScope) {
          if (!ctrl.open) {
            return false;
          }
          var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
          var isActive = itemIndex == ctrl.activeIndex;

          if (!isActive || itemIndex < 0) {
            return false;
          }

          if (isActive && !angular.isUndefined(ctrl.onHighlightCallback)) {
            itemScope.$eval(ctrl.onHighlightCallback);
          }

          return isActive;
        };

        var _isItemSelected = function _isItemSelected(item) {
          return ctrl.selected && angular.isArray(ctrl.selected) && ctrl.selected.filter(function (selection) {
            return angular.equals(selection, item);
          }).length > 0;
        };

        var disabledItems = [];

        function _updateItemDisabled(item, isDisabled) {
          var disabledItemIndex = disabledItems.indexOf(item);
          if (isDisabled && disabledItemIndex === -1) {
            disabledItems.push(item);
          }

          if (!isDisabled && disabledItemIndex > -1) {
            disabledItems.splice(disabledItemIndex, 1);
          }
        }

        function _isItemDisabled(item) {
          return disabledItems.indexOf(item) > -1;
        }

        ctrl.isDisabled = function (itemScope) {

          if (!ctrl.open) return;

          var item = itemScope[ctrl.itemProperty];
          var itemIndex = ctrl.items.indexOf(item);
          var isDisabled = false;

          if (itemIndex >= 0 && (angular.isDefined(ctrl.disableChoiceExpression) || ctrl.multiple)) {

            if (item.isTag) return false;

            if (ctrl.multiple) {
              isDisabled = _isItemSelected(item);
            }

            if (!isDisabled && angular.isDefined(ctrl.disableChoiceExpression)) {
              isDisabled = !!itemScope.$eval(ctrl.disableChoiceExpression);
            }

            _updateItemDisabled(item, isDisabled);
          }

          return isDisabled;
        };

        // When the user selects an item with ENTER or clicks the dropdown
        ctrl.select = function (item, skipFocusser, $event) {
          if (item === undefined || !_isItemDisabled(item)) {

            if (!ctrl.items && !ctrl.search && !ctrl.tagging.isActivated) return;

            if (!item || !_isItemDisabled(item)) {
              // if click is made on existing item, prevent from tagging, ctrl.search does not matter
              ctrl.clickTriggeredSelect = false;
              if ($event && $event.type === 'click' && item) ctrl.clickTriggeredSelect = true;

              if (ctrl.tagging.isActivated && ctrl.clickTriggeredSelect === false) {
                // if taggingLabel is disabled and item is undefined we pull from ctrl.search
                if (ctrl.taggingLabel === false) {
                  if (ctrl.activeIndex < 0) {
                    if (item === undefined) {
                      item = ctrl.tagging.fct !== undefined ? ctrl.tagging.fct(ctrl.search) : ctrl.search;
                    }
                    if (!item || angular.equals(ctrl.items[0], item)) {
                      return;
                    }
                  } else {
                    // keyboard nav happened first, user selected from dropdown
                    item = ctrl.items[ctrl.activeIndex];
                  }
                } else {
                  // tagging always operates at index zero, taggingLabel === false pushes
                  // the ctrl.search value without having it injected
                  if (ctrl.activeIndex === 0) {
                    // ctrl.tagging pushes items to ctrl.items, so we only have empty val
                    // for `item` if it is a detected duplicate
                    if (item === undefined) return;

                    // create new item on the fly if we don't already have one;
                    // use tagging function if we have one
                    if (ctrl.tagging.fct !== undefined && typeof item === 'string') {
                      item = ctrl.tagging.fct(item);
                      if (!item) return;
                      // if item type is 'string', apply the tagging label
                    } else if (typeof item === 'string') {
                      // trim the trailing space
                      item = item.replace(ctrl.taggingLabel, '').trim();
                    }
                  }
                }
                // search ctrl.selected for dupes potentially caused by tagging and return early if found
                if (_isItemSelected(item)) {
                  ctrl.close(skipFocusser);
                  return;
                }
              }
              _resetSearchInput();
              $scope.$broadcast('uis:select', item);

              var locals = {};
              locals[ctrl.parserResult.itemName] = item;

              $timeout(function () {
                ctrl.onSelectCallback($scope, {
                  $item: item,
                  $model: ctrl.parserResult.modelMapper($scope, locals)
                });
              });

              if (ctrl.closeOnSelect) {
                ctrl.close(skipFocusser);
              }
            }
          }
        };

        // Closes the dropdown
        ctrl.close = function (skipFocusser) {
          if (!ctrl.open) return;
          if (ctrl.ngModel && ctrl.ngModel.$setTouched) ctrl.ngModel.$setTouched();
          ctrl.open = false;
          _resetSearchInput();
          $scope.$broadcast('uis:close', skipFocusser);
        };

        ctrl.setFocus = function () {
          if (!ctrl.focus) ctrl.focusInput[0].focus();
        };

        ctrl.clear = function ($event) {
          ctrl.select(undefined);
          $event.stopPropagation();
          $timeout(function () {
            ctrl.focusser[0].focus();
          }, 0, false);
        };

        // Toggle dropdown
        ctrl.toggle = function (e) {
          if (ctrl.open) {
            ctrl.close();
            e.preventDefault();
            e.stopPropagation();
          } else {
            ctrl.activate();
          }
        };

        // Set default function for locked choices - avoids unnecessary
        // logic if functionality is not being used
        ctrl.isLocked = function () {
          return false;
        };

        $scope.$watch(function () {
          return angular.isDefined(ctrl.lockChoiceExpression) && ctrl.lockChoiceExpression !== "";
        }, _initaliseLockedChoices);

        function _initaliseLockedChoices(doInitalise) {
          if (!doInitalise) return;

          var lockedItems = [];

          function _updateItemLocked(item, isLocked) {
            var lockedItemIndex = lockedItems.indexOf(item);
            if (isLocked && lockedItemIndex === -1) {
              lockedItems.push(item);
            }

            if (!isLocked && lockedItemIndex > -1) {
              lockedItems.splice(lockedItemIndex, 0);
            }
          }

          function _isItemlocked(item) {
            return lockedItems.indexOf(item) > -1;
          }

          ctrl.isLocked = function (itemScope, itemIndex) {
            var isLocked = false,
                item = ctrl.selected[itemIndex];

            if (item) {
              if (itemScope) {
                isLocked = !!itemScope.$eval(ctrl.lockChoiceExpression);
                _updateItemLocked(item, isLocked);
              } else {
                isLocked = _isItemlocked(item);
              }
            }

            return isLocked;
          };
        }

        var sizeWatch = null;
        var updaterScheduled = false;
        ctrl.sizeSearchInput = function () {

          var input = ctrl.searchInput[0],
              container = ctrl.searchInput.parent().parent()[0],
              calculateContainerWidth = function calculateContainerWidth() {
            // Return the container width only if the search input is visible
            return container.clientWidth * !!input.offsetParent;
          },
              updateIfVisible = function updateIfVisible(containerWidth) {
            if (containerWidth === 0) {
              return false;
            }
            var inputWidth = containerWidth - input.offsetLeft - 10;
            if (inputWidth < 50) inputWidth = containerWidth;
            ctrl.searchInput.css('width', inputWidth + 'px');
            return true;
          };

          ctrl.searchInput.css('width', '10px');
          $timeout(function () {
            //Give tags time to render correctly
            if (sizeWatch === null && !updateIfVisible(calculateContainerWidth())) {
              sizeWatch = $scope.$watch(function () {
                if (!updaterScheduled) {
                  updaterScheduled = true;
                  $scope.$$postDigest(function () {
                    updaterScheduled = false;
                    if (updateIfVisible(calculateContainerWidth())) {
                      sizeWatch();
                      sizeWatch = null;
                    }
                  });
                }
              }, angular.noop);
            }
          });
        };

        function _handleDropDownSelection(key) {
          var processed = true;
          switch (key) {
            case KEY.DOWN:
              if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode
              else if (ctrl.activeIndex < ctrl.items.length - 1) {
                  ctrl.activeIndex++;
                }
              break;
            case KEY.UP:
              if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode
              else if (ctrl.activeIndex > 0 || ctrl.search.length === 0 && ctrl.tagging.isActivated && ctrl.activeIndex > -1) {
                  ctrl.activeIndex--;
                }
              break;
            case KEY.TAB:
              if (!ctrl.multiple || ctrl.open) ctrl.select(ctrl.items[ctrl.activeIndex], true);
              break;
            case KEY.ENTER:
              if (ctrl.open && (ctrl.tagging.isActivated || ctrl.activeIndex >= 0)) {
                ctrl.select(ctrl.items[ctrl.activeIndex], ctrl.skipFocusser); // Make sure at least one dropdown item is highlighted before adding if not in tagging mode
              } else {
                ctrl.activate(false, true); //In case its the search input in 'multiple' mode
              }
              break;
            case KEY.ESC:
              ctrl.close();
              break;
            default:
              processed = false;
          }
          return processed;
        }

        // Bind to keyboard shortcuts
        ctrl.searchInput.on('keydown', function (e) {

          var key = e.which;

          if (~[KEY.ENTER, KEY.ESC].indexOf(key)) {
            e.preventDefault();
            e.stopPropagation();
          }

          // if(~[KEY.ESC,KEY.TAB].indexOf(key)){
          //   //TODO: SEGURO?
          //   ctrl.close();
          // }

          $scope.$apply(function () {

            var tagged = false;

            if (ctrl.items.length > 0 || ctrl.tagging.isActivated) {
              if (!_handleDropDownSelection(key) && !ctrl.searchEnabled) {
                e.preventDefault();
                e.stopPropagation();
              }
              if (ctrl.taggingTokens.isActivated) {
                for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {
                  if (ctrl.taggingTokens.tokens[i] === KEY.MAP[e.keyCode]) {
                    // make sure there is a new value to push via tagging
                    if (ctrl.search.length > 0) {
                      tagged = true;
                    }
                  }
                }
                if (tagged) {
                  $timeout(function () {
                    ctrl.searchInput.triggerHandler('tagged');
                    var newItem = ctrl.search.replace(KEY.MAP[e.keyCode], '').trim();
                    if (ctrl.tagging.fct) {
                      newItem = ctrl.tagging.fct(newItem);
                    }
                    if (newItem) ctrl.select(newItem, true);
                  });
                }
              }
            }
          });

          if (KEY.isVerticalMovement(key) && ctrl.items.length > 0) {
            _ensureHighlightVisible();
          }

          if (key === KEY.ENTER || key === KEY.ESC) {
            e.preventDefault();
            e.stopPropagation();
          }
        });

        ctrl.searchInput.on('paste', function (e) {
          var data;

          if (window.clipboardData && window.clipboardData.getData) {
            // IE
            data = window.clipboardData.getData('Text');
          } else {
            data = (e.originalEvent || e).clipboardData.getData('text/plain');
          }

          // Prepend the current input field text to the paste buffer.
          data = ctrl.search + data;

          if (data && data.length > 0) {
            // If tagging try to split by tokens and add items
            if (ctrl.taggingTokens.isActivated) {
              var items = [];
              for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {
                // split by first token that is contained in data
                var separator = KEY.toSeparator(ctrl.taggingTokens.tokens[i]) || ctrl.taggingTokens.tokens[i];
                if (data.indexOf(separator) > -1) {
                  items = data.split(separator);
                  break; // only split by one token
                }
              }
              if (items.length === 0) {
                items = [data];
              }
              var oldsearch = ctrl.search;
              angular.forEach(items, function (item) {
                var newItem = ctrl.tagging.fct ? ctrl.tagging.fct(item) : item;
                if (newItem) {
                  ctrl.select(newItem, true);
                }
              });
              ctrl.search = oldsearch || EMPTY_SEARCH;
              e.preventDefault();
              e.stopPropagation();
            } else if (ctrl.paste) {
              ctrl.paste(data);
              ctrl.search = EMPTY_SEARCH;
              e.preventDefault();
              e.stopPropagation();
            }
          }
        });

        ctrl.searchInput.on('tagged', function () {
          $timeout(function () {
            _resetSearchInput();
          });
        });

        // See https://github.com/ivaynberg/select2/blob/3.4.6/select2.js#L1431
        function _ensureHighlightVisible() {
          var container = $element.querySelectorAll('.ui-select-choices-content');
          var choices = container.querySelectorAll('.ui-select-choices-row');
          if (choices.length < 1) {
            throw uiSelectMinErr('choices', "Expected multiple .ui-select-choices-row but got '{0}'.", choices.length);
          }

          if (ctrl.activeIndex < 0) {
            return;
          }

          var highlighted = choices[ctrl.activeIndex];
          var posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop;
          var height = container[0].offsetHeight;

          if (posY > height) {
            container[0].scrollTop += posY - height;
          } else if (posY < highlighted.clientHeight) {
            if (ctrl.isGrouped && ctrl.activeIndex === 0) container[0].scrollTop = 0; //To make group header visible when going all the way up
            else container[0].scrollTop -= highlighted.clientHeight - posY;
          }
        }

        var onResize = $$uisDebounce(function () {
          ctrl.sizeSearchInput();
        }, 50);

        angular.element($window).bind('resize', onResize);

        $scope.$on('$destroy', function () {
          ctrl.searchInput.off('keyup keydown tagged blur paste');
          angular.element($window).off('resize', onResize);
        });
      }]);

      uis.directive('uiSelect', ['$document', 'uiSelectConfig', 'uiSelectMinErr', 'uisOffset', '$compile', '$parse', '$timeout', function ($document, uiSelectConfig, uiSelectMinErr, uisOffset, $compile, $parse, $timeout) {

        return {
          restrict: 'EA',
          templateUrl: function templateUrl(tElement, tAttrs) {
            var theme = tAttrs.theme || uiSelectConfig.theme;
            return theme + (angular.isDefined(tAttrs.multiple) ? '/select-multiple.tpl.html' : '/select.tpl.html');
          },
          replace: true,
          transclude: true,
          require: ['uiSelect', '^ngModel'],
          scope: true,

          controller: 'uiSelectCtrl',
          controllerAs: '$select',
          compile: function compile(tElement, tAttrs) {

            // Allow setting ngClass on uiSelect
            var match = /{(.*)}\s*{(.*)}/.exec(tAttrs.ngClass);
            if (match) {
              var combined = '{' + match[1] + ', ' + match[2] + '}';
              tAttrs.ngClass = combined;
              tElement.attr('ng-class', combined);
            }

            //Multiple or Single depending if multiple attribute presence
            if (angular.isDefined(tAttrs.multiple)) tElement.append('<ui-select-multiple/>').removeAttr('multiple');else tElement.append('<ui-select-single/>');

            if (tAttrs.inputId) tElement.querySelectorAll('input.ui-select-search')[0].id = tAttrs.inputId;

            return function (scope, element, attrs, ctrls, transcludeFn) {

              var $select = ctrls[0];
              var ngModel = ctrls[1];

              $select.generatedId = uiSelectConfig.generateId();
              $select.baseTitle = attrs.title || 'Select box';
              $select.focusserTitle = $select.baseTitle + ' focus';
              $select.focusserId = 'focusser-' + $select.generatedId;

              $select.closeOnSelect = function () {
                if (angular.isDefined(attrs.closeOnSelect)) {
                  return $parse(attrs.closeOnSelect)();
                } else {
                  return uiSelectConfig.closeOnSelect;
                }
              }();

              scope.$watch('skipFocusser', function () {
                var skipFocusser = scope.$eval(attrs.skipFocusser);
                $select.skipFocusser = skipFocusser !== undefined ? skipFocusser : uiSelectConfig.skipFocusser;
              });

              $select.onSelectCallback = $parse(attrs.onSelect);
              $select.onRemoveCallback = $parse(attrs.onRemove);

              //Set reference to ngModel from uiSelectCtrl
              $select.ngModel = ngModel;

              $select.choiceGrouped = function (group) {
                return $select.isGrouped && group && group.name;
              };

              if (attrs.tabindex) {
                attrs.$observe('tabindex', function (value) {
                  $select.focusInput.attr('tabindex', value);
                  element.removeAttr('tabindex');
                });
              }

              scope.$watch(function () {
                return scope.$eval(attrs.searchEnabled);
              }, function (newVal) {
                $select.searchEnabled = newVal !== undefined ? newVal : uiSelectConfig.searchEnabled;
              });

              scope.$watch('sortable', function () {
                var sortable = scope.$eval(attrs.sortable);
                $select.sortable = sortable !== undefined ? sortable : uiSelectConfig.sortable;
              });

              attrs.$observe('limit', function () {
                //Limit the number of selections allowed
                $select.limit = angular.isDefined(attrs.limit) ? parseInt(attrs.limit, 10) : undefined;
              });

              scope.$watch('removeSelected', function () {
                var removeSelected = scope.$eval(attrs.removeSelected);
                $select.removeSelected = removeSelected !== undefined ? removeSelected : uiSelectConfig.removeSelected;
              });

              attrs.$observe('disabled', function () {
                // No need to use $eval() (thanks to ng-disabled) since we already get a boolean instead of a string
                $select.disabled = attrs.disabled !== undefined ? attrs.disabled : false;
              });

              attrs.$observe('resetSearchInput', function () {
                // $eval() is needed otherwise we get a string instead of a boolean
                var resetSearchInput = scope.$eval(attrs.resetSearchInput);
                $select.resetSearchInput = resetSearchInput !== undefined ? resetSearchInput : true;
              });

              attrs.$observe('paste', function () {
                $select.paste = scope.$eval(attrs.paste);
              });

              attrs.$observe('tagging', function () {
                if (attrs.tagging !== undefined) {
                  // $eval() is needed otherwise we get a string instead of a boolean
                  var taggingEval = scope.$eval(attrs.tagging);
                  $select.tagging = { isActivated: true, fct: taggingEval !== true ? taggingEval : undefined };
                } else {
                  $select.tagging = { isActivated: false, fct: undefined };
                }
              });

              attrs.$observe('taggingLabel', function () {
                if (attrs.tagging !== undefined) {
                  // check eval for FALSE, in this case, we disable the labels
                  // associated with tagging
                  if (attrs.taggingLabel === 'false') {
                    $select.taggingLabel = false;
                  } else {
                    $select.taggingLabel = attrs.taggingLabel !== undefined ? attrs.taggingLabel : '(new)';
                  }
                }
              });

              attrs.$observe('taggingTokens', function () {
                if (attrs.tagging !== undefined) {
                  var tokens = attrs.taggingTokens !== undefined ? attrs.taggingTokens.split('|') : [',', 'ENTER'];
                  $select.taggingTokens = { isActivated: true, tokens: tokens };
                }
              });

              //Automatically gets focus when loaded
              if (angular.isDefined(attrs.autofocus)) {
                $timeout(function () {
                  $select.setFocus();
                });
              }

              //Gets focus based on scope event name (e.g. focus-on='SomeEventName')
              if (angular.isDefined(attrs.focusOn)) {
                scope.$on(attrs.focusOn, function () {
                  $timeout(function () {
                    $select.setFocus();
                  });
                });
              }

              function onDocumentClick(e) {
                if (!$select.open) return; //Skip it if dropdown is close

                var contains = false;

                if (window.jQuery) {
                  // Firefox 3.6 does not support element.contains()
                  // See Node.contains https://developer.mozilla.org/en-US/docs/Web/API/Node.contains
                  contains = window.jQuery.contains(element[0], e.target);
                } else {
                  contains = element[0].contains(e.target);
                }

                if (!contains && !$select.clickTriggeredSelect) {
                  var skipFocusser;
                  if (!$select.skipFocusser) {
                    //Will lose focus only with certain targets
                    var focusableControls = ['input', 'button', 'textarea', 'select'];
                    var targetController = angular.element(e.target).controller('uiSelect'); //To check if target is other ui-select
                    skipFocusser = targetController && targetController !== $select; //To check if target is other ui-select
                    if (!skipFocusser) skipFocusser = ~focusableControls.indexOf(e.target.tagName.toLowerCase()); //Check if target is input, button or textarea
                  } else {
                    skipFocusser = true;
                  }
                  $select.close(skipFocusser);
                  scope.$digest();
                }
                $select.clickTriggeredSelect = false;
              }

              // See Click everywhere but here event http://stackoverflow.com/questions/12931369
              $document.on('click', onDocumentClick);

              scope.$on('$destroy', function () {
                $document.off('click', onDocumentClick);
              });

              // Move transcluded elements to their correct position in main template
              transcludeFn(scope, function (clone) {
                // See Transclude in AngularJS http://blog.omkarpatil.com/2012/11/transclude-in-angularjs.html

                // One day jqLite will be replaced by jQuery and we will be able to write:
                // var transcludedElement = clone.filter('.my-class')
                // instead of creating a hackish DOM element:
                var transcluded = angular.element('<div>').append(clone);

                var transcludedMatch = transcluded.querySelectorAll('.ui-select-match');
                transcludedMatch.removeAttr('ui-select-match'); //To avoid loop in case directive as attr
                transcludedMatch.removeAttr('data-ui-select-match'); // Properly handle HTML5 data-attributes
                if (transcludedMatch.length !== 1) {
                  throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-match but got '{0}'.", transcludedMatch.length);
                }
                element.querySelectorAll('.ui-select-match').replaceWith(transcludedMatch);

                var transcludedChoices = transcluded.querySelectorAll('.ui-select-choices');
                transcludedChoices.removeAttr('ui-select-choices'); //To avoid loop in case directive as attr
                transcludedChoices.removeAttr('data-ui-select-choices'); // Properly handle HTML5 data-attributes
                if (transcludedChoices.length !== 1) {
                  throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-choices but got '{0}'.", transcludedChoices.length);
                }
                element.querySelectorAll('.ui-select-choices').replaceWith(transcludedChoices);

                var transcludedNoChoice = transcluded.querySelectorAll('.ui-select-no-choice');
                transcludedNoChoice.removeAttr('ui-select-no-choice'); //To avoid loop in case directive as attr
                transcludedNoChoice.removeAttr('data-ui-select-no-choice'); // Properly handle HTML5 data-attributes
                if (transcludedNoChoice.length == 1) {
                  element.querySelectorAll('.ui-select-no-choice').replaceWith(transcludedNoChoice);
                }
              });

              // Support for appending the select field to the body when its open
              var appendToBody = scope.$eval(attrs.appendToBody);
              if (appendToBody !== undefined ? appendToBody : uiSelectConfig.appendToBody) {
                scope.$watch('$select.open', function (isOpen) {
                  if (isOpen) {
                    positionDropdown();
                  } else {
                    resetDropdown();
                  }
                });

                // Move the dropdown back to its original location when the scope is destroyed. Otherwise
                // it might stick around when the user routes away or the select field is otherwise removed
                scope.$on('$destroy', function () {
                  resetDropdown();
                });
              }

              // Hold on to a reference to the .ui-select-container element for appendToBody support
              var placeholder = null,
                  originalWidth = '';

              function positionDropdown() {
                // Remember the absolute position of the element
                var offset = uisOffset(element);

                // Clone the element into a placeholder element to take its original place in the DOM
                placeholder = angular.element('<div class="ui-select-placeholder"></div>');
                placeholder[0].style.width = offset.width + 'px';
                placeholder[0].style.height = offset.height + 'px';
                element.after(placeholder);

                // Remember the original value of the element width inline style, so it can be restored
                // when the dropdown is closed
                originalWidth = element[0].style.width;

                // Now move the actual dropdown element to the end of the body
                $document.find('body').append(element);

                element[0].style.position = 'absolute';
                element[0].style.left = offset.left + 'px';
                element[0].style.top = offset.top + 'px';
                element[0].style.width = offset.width + 'px';
              }

              function resetDropdown() {
                if (placeholder === null) {
                  // The dropdown has not actually been display yet, so there's nothing to reset
                  return;
                }

                // Move the dropdown element back to its original location in the DOM
                placeholder.replaceWith(element);
                placeholder = null;

                element[0].style.position = '';
                element[0].style.left = '';
                element[0].style.top = '';
                element[0].style.width = originalWidth;

                // Set focus back on to the moved element
                $select.setFocus();
              }

              // Hold on to a reference to the .ui-select-dropdown element for direction support.
              var dropdown = null,
                  directionUpClassName = 'direction-up';

              // Support changing the direction of the dropdown if there isn't enough space to render it.
              scope.$watch('$select.open', function () {

                if ($select.dropdownPosition === 'auto' || $select.dropdownPosition === 'up') {
                  scope.calculateDropdownPos();
                }
              });

              var setDropdownPosUp = function setDropdownPosUp(offset, offsetDropdown) {

                offset = offset || uisOffset(element);
                offsetDropdown = offsetDropdown || uisOffset(dropdown);

                dropdown[0].style.position = 'absolute';
                dropdown[0].style.top = offsetDropdown.height * -1 + 'px';
                element.addClass(directionUpClassName);
              };

              var setDropdownPosDown = function setDropdownPosDown(offset, offsetDropdown) {

                element.removeClass(directionUpClassName);

                offset = offset || uisOffset(element);
                offsetDropdown = offsetDropdown || uisOffset(dropdown);

                dropdown[0].style.position = '';
                dropdown[0].style.top = '';
              };

              var calculateDropdownPosAfterAnimation = function calculateDropdownPosAfterAnimation() {
                // Delay positioning the dropdown until all choices have been added so its height is correct.
                $timeout(function () {
                  if ($select.dropdownPosition === 'up') {
                    //Go UP
                    setDropdownPosUp();
                  } else {
                    //AUTO
                    element.removeClass(directionUpClassName);

                    var offset = uisOffset(element);
                    var offsetDropdown = uisOffset(dropdown);

                    //https://code.google.com/p/chromium/issues/detail?id=342307#c4
                    var scrollTop = $document[0].documentElement.scrollTop || $document[0].body.scrollTop; //To make it cross browser (blink, webkit, IE, Firefox).

                    // Determine if the direction of the dropdown needs to be changed.
                    if (offset.top + offset.height + offsetDropdown.height > scrollTop + $document[0].documentElement.clientHeight) {
                      //Go UP
                      setDropdownPosUp(offset, offsetDropdown);
                    } else {
                      //Go DOWN
                      setDropdownPosDown(offset, offsetDropdown);
                    }
                  }

                  // Display the dropdown once it has been positioned.
                  dropdown[0].style.opacity = 1;
                });
              };

              var opened = false;

              scope.calculateDropdownPos = function () {
                if ($select.open) {
                  dropdown = angular.element(element).querySelectorAll('.ui-select-dropdown');

                  if (dropdown.length === 0) {
                    return;
                  }

                  // Hide the dropdown so there is no flicker until $timeout is done executing.
                  if ($select.search === '' && !opened) {
                    dropdown[0].style.opacity = 0;
                    opened = true;
                  }

                  if (!uisOffset(dropdown).height && $select.$animate && $select.$animate.on && $select.$animate.enabled(dropdown)) {
                    var needsCalculated = true;

                    $select.$animate.on('enter', dropdown, function (elem, phase) {
                      if (phase === 'close' && needsCalculated) {
                        calculateDropdownPosAfterAnimation();
                        needsCalculated = false;
                      }
                    });
                  } else {
                    calculateDropdownPosAfterAnimation();
                  }
                } else {
                  if (dropdown === null || dropdown.length === 0) {
                    return;
                  }

                  // Reset the position of the dropdown.
                  dropdown[0].style.opacity = 0;
                  dropdown[0].style.position = '';
                  dropdown[0].style.top = '';
                  element.removeClass(directionUpClassName);
                }
              };
            };
          }
        };
      }]);

      uis.directive('uiSelectMatch', ['uiSelectConfig', function (uiSelectConfig) {
        return {
          restrict: 'EA',
          require: '^uiSelect',
          replace: true,
          transclude: true,
          templateUrl: function templateUrl(tElement) {
            // Needed so the uiSelect can detect the transcluded content
            tElement.addClass('ui-select-match');

            var parent = tElement.parent();
            // Gets theme attribute from parent (ui-select)
            var theme = getAttribute(parent, 'theme') || uiSelectConfig.theme;
            var multi = angular.isDefined(getAttribute(parent, 'multiple'));

            return theme + (multi ? '/match-multiple.tpl.html' : '/match.tpl.html');
          },
          link: function link(scope, element, attrs, $select) {
            $select.lockChoiceExpression = attrs.uiLockChoice;
            attrs.$observe('placeholder', function (placeholder) {
              $select.placeholder = placeholder !== undefined ? placeholder : uiSelectConfig.placeholder;
            });

            function setAllowClear(allow) {
              $select.allowClear = angular.isDefined(allow) ? allow === '' ? true : allow.toLowerCase() === 'true' : false;
            }

            attrs.$observe('allowClear', setAllowClear);
            setAllowClear(attrs.allowClear);

            if ($select.multiple) {
              $select.sizeSearchInput();
            }
          }
        };

        function getAttribute(elem, attribute) {
          if (elem[0].hasAttribute(attribute)) return elem.attr(attribute);

          if (elem[0].hasAttribute('data-' + attribute)) return elem.attr('data-' + attribute);

          if (elem[0].hasAttribute('x-' + attribute)) return elem.attr('x-' + attribute);
        }
      }]);

      uis.directive('uiSelectMultiple', ['uiSelectMinErr', '$timeout', function (uiSelectMinErr, $timeout) {
        return {
          restrict: 'EA',
          require: ['^uiSelect', '^ngModel'],

          controller: ['$scope', '$timeout', function ($scope, $timeout) {

            var ctrl = this,
                $select = $scope.$select,
                ngModel;

            if (angular.isUndefined($select.selected)) $select.selected = [];

            //Wait for link fn to inject it
            $scope.$evalAsync(function () {
              ngModel = $scope.ngModel;
            });

            ctrl.activeMatchIndex = -1;

            ctrl.updateModel = function () {
              ngModel.$setViewValue(Date.now()); //Set timestamp as a unique string to force changes
              ctrl.refreshComponent();
            };

            ctrl.refreshComponent = function () {
              //Remove already selected items
              //e.g. When user clicks on a selection, the selected array changes and
              //the dropdown should remove that item
              if ($select.refreshItems) {
                $select.refreshItems();
              }
              if ($select.sizeSearchInput) {
                $select.sizeSearchInput();
              }
            };

            // Remove item from multiple select
            ctrl.removeChoice = function (index) {

              // if the choice is locked, don't remove it
              if ($select.isLocked(null, index)) return false;

              var removedChoice = $select.selected[index];

              var locals = {};
              locals[$select.parserResult.itemName] = removedChoice;

              $select.selected.splice(index, 1);
              ctrl.activeMatchIndex = -1;
              $select.sizeSearchInput();

              // Give some time for scope propagation.
              $timeout(function () {
                $select.onRemoveCallback($scope, {
                  $item: removedChoice,
                  $model: $select.parserResult.modelMapper($scope, locals)
                });
              });

              ctrl.updateModel();

              return true;
            };

            ctrl.getPlaceholder = function () {
              //Refactor single?
              if ($select.selected && $select.selected.length) return;
              return $select.placeholder;
            };
          }],
          controllerAs: '$selectMultiple',

          link: function link(scope, element, attrs, ctrls) {

            var $select = ctrls[0];
            var ngModel = scope.ngModel = ctrls[1];
            var $selectMultiple = scope.$selectMultiple;

            //$select.selected = raw selected objects (ignoring any property binding)

            $select.multiple = true;

            //Input that will handle focus
            $select.focusInput = $select.searchInput;

            //Properly check for empty if set to multiple
            ngModel.$isEmpty = function (value) {
              return !value || value.length === 0;
            };

            //From view --> model
            ngModel.$parsers.unshift(function () {
              var locals = {},
                  result,
                  resultMultiple = [];
              for (var j = $select.selected.length - 1; j >= 0; j--) {
                locals = {};
                locals[$select.parserResult.itemName] = $select.selected[j];
                result = $select.parserResult.modelMapper(scope, locals);
                resultMultiple.unshift(result);
              }
              return resultMultiple;
            });

            // From model --> view
            ngModel.$formatters.unshift(function (inputValue) {
              var data = $select.parserResult && $select.parserResult.source(scope, { $select: { search: '' } }),
                  //Overwrite $search
              locals = {},
                  result;
              if (!data) return inputValue;
              var resultMultiple = [];
              var checkFnMultiple = function checkFnMultiple(list, value) {
                if (!list || !list.length) return;
                for (var p = list.length - 1; p >= 0; p--) {
                  locals[$select.parserResult.itemName] = list[p];
                  result = $select.parserResult.modelMapper(scope, locals);
                  if ($select.parserResult.trackByExp) {
                    var propsItemNameMatches = /(\w*)\./.exec($select.parserResult.trackByExp);
                    var matches = /\.([^\s]+)/.exec($select.parserResult.trackByExp);
                    if (propsItemNameMatches && propsItemNameMatches.length > 0 && propsItemNameMatches[1] == $select.parserResult.itemName) {
                      if (matches && matches.length > 0 && result[matches[1]] == value[matches[1]]) {
                        resultMultiple.unshift(list[p]);
                        return true;
                      }
                    }
                  }
                  if (angular.equals(result, value)) {
                    resultMultiple.unshift(list[p]);
                    return true;
                  }
                }
                return false;
              };
              if (!inputValue) return resultMultiple; //If ngModel was undefined
              for (var k = inputValue.length - 1; k >= 0; k--) {
                //Check model array of currently selected items
                if (!checkFnMultiple($select.selected, inputValue[k])) {
                  //Check model array of all items available
                  if (!checkFnMultiple(data, inputValue[k])) {
                    //If not found on previous lists, just add it directly to resultMultiple
                    resultMultiple.unshift(inputValue[k]);
                  }
                }
              }
              return resultMultiple;
            });

            //Watch for external model changes
            scope.$watchCollection(function () {
              return ngModel.$modelValue;
            }, function (newValue, oldValue) {
              if (oldValue != newValue) {
                //update the view value with fresh data from items, if there is a valid model value
                if (angular.isDefined(ngModel.$modelValue)) {
                  ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters
                }
                $selectMultiple.refreshComponent();
              }
            });

            ngModel.$render = function () {
              // Make sure that model value is array
              if (!angular.isArray(ngModel.$viewValue)) {
                // Have tolerance for null or undefined values
                if (angular.isUndefined(ngModel.$viewValue) || ngModel.$viewValue === null) {
                  ngModel.$viewValue = [];
                } else {
                  throw uiSelectMinErr('multiarr', "Expected model value to be array but got '{0}'", ngModel.$viewValue);
                }
              }
              $select.selected = ngModel.$viewValue;
              $selectMultiple.refreshComponent();
              scope.$evalAsync(); //To force $digest
            };

            scope.$on('uis:select', function (event, item) {
              if ($select.selected.length >= $select.limit) {
                return;
              }
              $select.selected.push(item);
              $selectMultiple.updateModel();
            });

            scope.$on('uis:activate', function () {
              $selectMultiple.activeMatchIndex = -1;
            });

            scope.$watch('$select.disabled', function (newValue, oldValue) {
              // As the search input field may now become visible, it may be necessary to recompute its size
              if (oldValue && !newValue) $select.sizeSearchInput();
            });

            $select.searchInput.on('keydown', function (e) {
              var key = e.which;
              scope.$apply(function () {
                var processed = false;
                // var tagged = false; //Checkme
                if (KEY.isHorizontalMovement(key)) {
                  processed = _handleMatchSelection(key);
                }
                if (processed && key != KEY.TAB) {
                  //TODO Check si el tab selecciona aun correctamente
                  //Crear test
                  e.preventDefault();
                  e.stopPropagation();
                }
              });
            });
            function _getCaretPosition(el) {
              if (angular.isNumber(el.selectionStart)) return el.selectionStart;
              // selectionStart is not supported in IE8 and we don't want hacky workarounds so we compromise
              else return el.value.length;
            }
            // Handles selected options in "multiple" mode
            function _handleMatchSelection(key) {
              var caretPosition = _getCaretPosition($select.searchInput[0]),
                  length = $select.selected.length,

              // none  = -1,
              first = 0,
                  last = length - 1,
                  curr = $selectMultiple.activeMatchIndex,
                  next = $selectMultiple.activeMatchIndex + 1,
                  prev = $selectMultiple.activeMatchIndex - 1,
                  newIndex = curr;

              if (caretPosition > 0 || $select.search.length && key == KEY.RIGHT) return false;

              $select.close();

              function getNewActiveMatchIndex() {
                switch (key) {
                  case KEY.LEFT:
                    // Select previous/first item
                    if (~$selectMultiple.activeMatchIndex) return prev;
                    // Select last item
                    else return last;
                    break;
                  case KEY.RIGHT:
                    // Open drop-down
                    if (!~$selectMultiple.activeMatchIndex || curr === last) {
                      $select.activate();
                      return false;
                    }
                    // Select next/last item
                    else return next;
                    break;
                  case KEY.BACKSPACE:
                    // Remove selected item and select previous/first
                    if (~$selectMultiple.activeMatchIndex) {
                      if ($selectMultiple.removeChoice(curr)) {
                        return prev;
                      } else {
                        return curr;
                      }
                    } else {
                      // If nothing yet selected, select last item
                      return last;
                    }
                    break;
                  case KEY.DELETE:
                    // Remove selected item and select next item
                    if (~$selectMultiple.activeMatchIndex) {
                      $selectMultiple.removeChoice($selectMultiple.activeMatchIndex);
                      return curr;
                    } else return false;
                }
              }

              newIndex = getNewActiveMatchIndex();

              if (!$select.selected.length || newIndex === false) $selectMultiple.activeMatchIndex = -1;else $selectMultiple.activeMatchIndex = Math.min(last, Math.max(first, newIndex));

              return true;
            }

            $select.searchInput.on('keyup', function (e) {

              if (!KEY.isVerticalMovement(e.which)) {
                scope.$evalAsync(function () {
                  $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
                });
              }
              // Push a "create new" item into array if there is a search string
              if ($select.tagging.isActivated && $select.search.length > 0) {

                // return early with these keys
                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || KEY.isVerticalMovement(e.which)) {
                  return;
                }
                // always reset the activeIndex to the first item when tagging
                $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
                // taggingLabel === false bypasses all of this
                if ($select.taggingLabel === false) return;

                var items = angular.copy($select.items);
                var stashArr = angular.copy($select.items);
                var newItem;
                var item;
                var hasTag = false;
                var dupeIndex = -1;
                var tagItems;
                var tagItem;

                // case for object tagging via transform `$select.tagging.fct` function
                if ($select.tagging.fct !== undefined) {
                  tagItems = $select.$filter('filter')(items, { 'isTag': true });
                  if (tagItems.length > 0) {
                    tagItem = tagItems[0];
                  }
                  // remove the first element, if it has the `isTag` prop we generate a new one with each keyup, shaving the previous
                  if (items.length > 0 && tagItem) {
                    hasTag = true;
                    items = items.slice(1, items.length);
                    stashArr = stashArr.slice(1, stashArr.length);
                  }
                  newItem = $select.tagging.fct($select.search);
                  // verify the new tag doesn't match the value of a possible selection choice or an already selected item.
                  if (stashArr.some(function (origItem) {
                    return angular.equals(origItem, newItem);
                  }) || $select.selected.some(function (origItem) {
                    return angular.equals(origItem, newItem);
                  })) {
                    scope.$evalAsync(function () {
                      $select.activeIndex = 0;
                      $select.items = items;
                    });
                    return;
                  }
                  if (newItem) newItem.isTag = true;
                  // handle newItem string and stripping dupes in tagging string context
                } else {
                  // find any tagging items already in the $select.items array and store them
                  tagItems = $select.$filter('filter')(items, function (item) {
                    return item.match($select.taggingLabel);
                  });
                  if (tagItems.length > 0) {
                    tagItem = tagItems[0];
                  }
                  item = items[0];
                  // remove existing tag item if found (should only ever be one tag item)
                  if (item !== undefined && items.length > 0 && tagItem) {
                    hasTag = true;
                    items = items.slice(1, items.length);
                    stashArr = stashArr.slice(1, stashArr.length);
                  }
                  newItem = $select.search + ' ' + $select.taggingLabel;
                  if (_findApproxDupe($select.selected, $select.search) > -1) {
                    return;
                  }
                  // verify the the tag doesn't match the value of an existing item from
                  // the searched data set or the items already selected
                  if (_findCaseInsensitiveDupe(stashArr.concat($select.selected))) {
                    // if there is a tag from prev iteration, strip it / queue the change
                    // and return early
                    if (hasTag) {
                      items = stashArr;
                      scope.$evalAsync(function () {
                        $select.activeIndex = 0;
                        $select.items = items;
                      });
                    }
                    return;
                  }
                  if (_findCaseInsensitiveDupe(stashArr)) {
                    // if there is a tag from prev iteration, strip it
                    if (hasTag) {
                      $select.items = stashArr.slice(1, stashArr.length);
                    }
                    return;
                  }
                }
                if (hasTag) dupeIndex = _findApproxDupe($select.selected, newItem);
                // dupe found, shave the first item
                if (dupeIndex > -1) {
                  items = items.slice(dupeIndex + 1, items.length - 1);
                } else {
                  items = [];
                  if (newItem) items.push(newItem);
                  items = items.concat(stashArr);
                }
                scope.$evalAsync(function () {
                  $select.activeIndex = 0;
                  $select.items = items;

                  if ($select.isGrouped) {
                    // update item references in groups, so that indexOf will work after angular.copy
                    var itemsWithoutTag = newItem ? items.slice(1) : items;
                    $select.setItemsFn(itemsWithoutTag);
                    if (newItem) {
                      // add tag item as a new group
                      $select.items.unshift(newItem);
                      $select.groups.unshift({ name: '', items: [newItem], tagging: true });
                    }
                  }
                });
              }
            });
            function _findCaseInsensitiveDupe(arr) {
              if (arr === undefined || $select.search === undefined) {
                return false;
              }
              var hasDupe = arr.filter(function (origItem) {
                if ($select.search.toUpperCase() === undefined || origItem === undefined) {
                  return false;
                }
                return origItem.toUpperCase() === $select.search.toUpperCase();
              }).length > 0;

              return hasDupe;
            }
            function _findApproxDupe(haystack, needle) {
              var dupeIndex = -1;
              if (angular.isArray(haystack)) {
                var tempArr = angular.copy(haystack);
                for (var i = 0; i < tempArr.length; i++) {
                  // handle the simple string version of tagging
                  if ($select.tagging.fct === undefined) {
                    // search the array for the match
                    if (tempArr[i] + ' ' + $select.taggingLabel === needle) {
                      dupeIndex = i;
                    }
                    // handle the object tagging implementation
                  } else {
                    var mockObj = tempArr[i];
                    if (angular.isObject(mockObj)) {
                      mockObj.isTag = true;
                    }
                    if (angular.equals(mockObj, needle)) {
                      dupeIndex = i;
                    }
                  }
                }
              }
              return dupeIndex;
            }

            $select.searchInput.on('blur', function () {
              $timeout(function () {
                $selectMultiple.activeMatchIndex = -1;
              });
            });
          }
        };
      }]);

      uis.directive('uiSelectNoChoice', ['uiSelectConfig', function (uiSelectConfig) {
        return {
          restrict: 'EA',
          require: '^uiSelect',
          replace: true,
          transclude: true,
          templateUrl: function templateUrl(tElement) {
            // Needed so the uiSelect can detect the transcluded content
            tElement.addClass('ui-select-no-choice');

            // Gets theme attribute from parent (ui-select)
            var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
            return theme + '/no-choice.tpl.html';
          }
        };
      }]);

      uis.directive('uiSelectSingle', ['$timeout', '$compile', function ($timeout, $compile) {
        return {
          restrict: 'EA',
          require: ['^uiSelect', '^ngModel'],
          link: function link(scope, element, attrs, ctrls) {

            var $select = ctrls[0];
            var ngModel = ctrls[1];

            //From view --> model
            ngModel.$parsers.unshift(function (inputValue) {
              var locals = {},
                  result;
              locals[$select.parserResult.itemName] = inputValue;
              result = $select.parserResult.modelMapper(scope, locals);
              return result;
            });

            //From model --> view
            ngModel.$formatters.unshift(function (inputValue) {
              var data = $select.parserResult && $select.parserResult.source(scope, { $select: { search: '' } }),
                  //Overwrite $search
              locals = {},
                  result;
              if (data) {
                var checkFnSingle = function checkFnSingle(d) {
                  locals[$select.parserResult.itemName] = d;
                  result = $select.parserResult.modelMapper(scope, locals);
                  return result === inputValue;
                };
                //If possible pass same object stored in $select.selected
                if ($select.selected && checkFnSingle($select.selected)) {
                  return $select.selected;
                }
                for (var i = data.length - 1; i >= 0; i--) {
                  if (checkFnSingle(data[i])) return data[i];
                }
              }
              return inputValue;
            });

            //Update viewValue if model change
            scope.$watch('$select.selected', function (newValue) {
              if (ngModel.$viewValue !== newValue) {
                ngModel.$setViewValue(newValue);
              }
            });

            ngModel.$render = function () {
              $select.selected = ngModel.$viewValue;
            };

            scope.$on('uis:select', function (event, item) {
              $select.selected = item;
            });

            scope.$on('uis:close', function (event, skipFocusser) {
              $timeout(function () {
                $select.focusser.prop('disabled', false);
                if (!skipFocusser) $select.focusser[0].focus();
              }, 0, false);
            });

            scope.$on('uis:activate', function () {
              focusser.prop('disabled', true); //Will reactivate it on .close()
            });

            //Idea from: https://github.com/ivaynberg/select2/blob/79b5bf6db918d7560bdd959109b7bcfb47edaf43/select2.js#L1954
            var focusser = angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />");
            $compile(focusser)(scope);
            $select.focusser = focusser;

            //Input that will handle focus
            $select.focusInput = focusser;

            element.parent().append(focusser);
            focusser.bind("focus", function () {
              scope.$evalAsync(function () {
                $select.focus = true;
              });
            });
            focusser.bind("blur", function () {
              scope.$evalAsync(function () {
                $select.focus = false;
              });
            });
            focusser.bind("keydown", function (e) {

              if (e.which === KEY.BACKSPACE) {
                e.preventDefault();
                e.stopPropagation();
                $select.select(undefined);
                scope.$apply();
                return;
              }

              if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                return;
              }

              if (e.which == KEY.DOWN || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE) {
                e.preventDefault();
                e.stopPropagation();
                $select.activate();
              }

              scope.$digest();
            });

            focusser.bind("keyup input", function (e) {

              if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE) {
                return;
              }

              $select.activate(focusser.val()); //User pressed some regular key, so we pass it to the search input
              focusser.val('');
              scope.$digest();
            });
          }
        };
      }]);

      // Make multiple matches sortable
      uis.directive('uiSelectSort', ['$timeout', 'uiSelectConfig', 'uiSelectMinErr', function ($timeout, uiSelectConfig, uiSelectMinErr) {
        return {
          require: ['^^uiSelect', '^ngModel'],
          link: function link(scope, element, attrs, ctrls) {
            if (scope[attrs.uiSelectSort] === null) {
              throw uiSelectMinErr('sort', 'Expected a list to sort');
            }

            var $select = ctrls[0];
            var $ngModel = ctrls[1];

            var options = angular.extend({
              axis: 'horizontal'
            }, scope.$eval(attrs.uiSelectSortOptions));

            var axis = options.axis;
            var draggingClassName = 'dragging';
            var droppingClassName = 'dropping';
            var droppingBeforeClassName = 'dropping-before';
            var droppingAfterClassName = 'dropping-after';

            scope.$watch(function () {
              return $select.sortable;
            }, function (newValue) {
              if (newValue) {
                element.attr('draggable', true);
              } else {
                element.removeAttr('draggable');
              }
            });

            element.on('dragstart', function (event) {
              element.addClass(draggingClassName);

              (event.dataTransfer || event.originalEvent.dataTransfer).setData('text', scope.$index.toString());
            });

            element.on('dragend', function () {
              removeClass(draggingClassName);
            });

            var move = function move(from, to) {
              /*jshint validthis: true */
              this.splice(to, 0, this.splice(from, 1)[0]);
            };

            var removeClass = function removeClass(className) {
              angular.forEach($select.$element.querySelectorAll('.' + className), function (el) {
                angular.element(el).removeClass(className);
              });
            };

            var dragOverHandler = function dragOverHandler(event) {
              event.preventDefault();

              var offset = axis === 'vertical' ? event.offsetY || event.layerY || (event.originalEvent ? event.originalEvent.offsetY : 0) : event.offsetX || event.layerX || (event.originalEvent ? event.originalEvent.offsetX : 0);

              if (offset < this[axis === 'vertical' ? 'offsetHeight' : 'offsetWidth'] / 2) {
                removeClass(droppingAfterClassName);
                element.addClass(droppingBeforeClassName);
              } else {
                removeClass(droppingBeforeClassName);
                element.addClass(droppingAfterClassName);
              }
            };

            var dropTimeout;

            var dropHandler = function dropHandler(event) {
              event.preventDefault();

              var droppedItemIndex = parseInt((event.dataTransfer || event.originalEvent.dataTransfer).getData('text'), 10);

              // prevent event firing multiple times in firefox
              $timeout.cancel(dropTimeout);
              dropTimeout = $timeout(function () {
                _dropHandler(droppedItemIndex);
              }, 20);
            };

            var _dropHandler = function _dropHandler(droppedItemIndex) {
              var theList = scope.$eval(attrs.uiSelectSort);
              var itemToMove = theList[droppedItemIndex];
              var newIndex = null;

              if (element.hasClass(droppingBeforeClassName)) {
                if (droppedItemIndex < scope.$index) {
                  newIndex = scope.$index - 1;
                } else {
                  newIndex = scope.$index;
                }
              } else {
                if (droppedItemIndex < scope.$index) {
                  newIndex = scope.$index;
                } else {
                  newIndex = scope.$index + 1;
                }
              }

              move.apply(theList, [droppedItemIndex, newIndex]);

              $ngModel.$setViewValue(Date.now());

              scope.$apply(function () {
                scope.$emit('uiSelectSort:change', {
                  array: theList,
                  item: itemToMove,
                  from: droppedItemIndex,
                  to: newIndex
                });
              });

              removeClass(droppingClassName);
              removeClass(droppingBeforeClassName);
              removeClass(droppingAfterClassName);

              element.off('drop', dropHandler);
            };

            element.on('dragenter', function () {
              if (element.hasClass(draggingClassName)) {
                return;
              }

              element.addClass(droppingClassName);

              element.on('dragover', dragOverHandler);
              element.on('drop', dropHandler);
            });

            element.on('dragleave', function (event) {
              if (event.target != element) {
                return;
              }

              removeClass(droppingClassName);
              removeClass(droppingBeforeClassName);
              removeClass(droppingAfterClassName);

              element.off('dragover', dragOverHandler);
              element.off('drop', dropHandler);
            });
          }
        };
      }]);

      /**
       * Debounces functions
       *
       * Taken from UI Bootstrap $$debounce source code
       * See https://github.com/angular-ui/bootstrap/blob/master/src/debounce/debounce.js
       *
       */
      uis.factory('$$uisDebounce', ['$timeout', function ($timeout) {
        return function (callback, debounceTime) {
          var timeoutPromise;

          return function () {
            var self = this;
            var args = Array.prototype.slice.call(arguments);
            if (timeoutPromise) {
              $timeout.cancel(timeoutPromise);
            }

            timeoutPromise = $timeout(function () {
              callback.apply(self, args);
            }, debounceTime);
          };
        };
      }]);

      uis.directive('uisOpenClose', ['$parse', '$timeout', function ($parse, $timeout) {
        return {
          restrict: 'A',
          require: 'uiSelect',
          link: function link(scope, element, attrs, $select) {
            $select.onOpenCloseCallback = $parse(attrs.uisOpenClose);

            scope.$watch('$select.open', function (isOpen, previousState) {
              if (isOpen !== previousState) {
                $timeout(function () {
                  $select.onOpenCloseCallback(scope, {
                    isOpen: isOpen
                  });
                });
              }
            });
          }
        };
      }]);

      /**
       * Parses "repeat" attribute.
       *
       * Taken from AngularJS ngRepeat source code
       * See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L211
       *
       * Original discussion about parsing "repeat" attribute instead of fully relying on ng-repeat:
       * https://github.com/angular-ui/ui-select/commit/5dd63ad#commitcomment-5504697
       */

      uis.service('uisRepeatParser', ['uiSelectMinErr', '$parse', function (uiSelectMinErr, $parse) {
        var self = this;

        /**
         * Example:
         * expression = "address in addresses | filter: {street: $select.search} track by $index"
         * itemName = "address",
         * source = "addresses | filter: {street: $select.search}",
         * trackByExp = "$index",
         */
        self.parse = function (expression) {

          var match;
          //var isObjectCollection = /\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)/.test(expression);
          // If an array is used as collection

          // if (isObjectCollection){
          // 000000000000000000000000000000111111111000000000000000222222222222220033333333333333333333330000444444444444444444000000000000000055555555555000000000000000000000066666666600000000
          match = expression.match(/^\s*(?:([\s\S]+?)\s+as\s+)?(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(\s*[\s\S]+?)?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);

          // 1 Alias
          // 2 Item
          // 3 Key on (key,value)
          // 4 Value on (key,value)
          // 5 Source expression (including filters)
          // 6 Track by

          if (!match) {
            throw uiSelectMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
          }

          var source = match[5],
              filters = '';

          // When using (key,value) ui-select requires filters to be extracted, since the object
          // is converted to an array for $select.items 
          // (in which case the filters need to be reapplied)
          if (match[3]) {
            // Remove any enclosing parenthesis
            source = match[5].replace(/(^\()|(\)$)/g, '');
            // match all after | but not after ||
            var filterMatch = match[5].match(/^\s*(?:[\s\S]+?)(?:[^\|]|\|\|)+([\s\S]*)\s*$/);
            if (filterMatch && filterMatch[1].trim()) {
              filters = filterMatch[1];
              source = source.replace(filters, '');
            }
          }

          return {
            itemName: match[4] || match[2], // (lhs) Left-hand side,
            keyName: match[3], //for (key, value) syntax
            source: $parse(source),
            filters: filters,
            trackByExp: match[6],
            modelMapper: $parse(match[1] || match[4] || match[2]),
            repeatExpression: function repeatExpression(grouped) {
              var expression = this.itemName + ' in ' + (grouped ? '$group.items' : '$select.items');
              if (this.trackByExp) {
                expression += ' track by ' + this.trackByExp;
              }
              return expression;
            }
          };
        };

        self.getGroupNgRepeatExpression = function () {
          return '$group in $select.groups track by $group.name';
        };
      }]);
    })();
    angular.module("ui.select").run(["$templateCache", function ($templateCache) {
      $templateCache.put("bootstrap/choices.tpl.html", "<ul class=\"ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu\" role=\"listbox\" ng-show=\"$select.open && $select.items.length > 0\"><li class=\"ui-select-choices-group\" id=\"ui-select-choices-{{ $select.generatedId }}\"><div class=\"divider\" ng-show=\"$select.isGrouped && $index > 0\"></div><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label dropdown-header\" ng-bind=\"$group.name\"></div><div ng-attr-id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\" role=\"option\"><span class=\"ui-select-choices-row-inner\"></span></div></li></ul>");
      $templateCache.put("bootstrap/match-multiple.tpl.html", "<span class=\"ui-select-match\"><span ng-repeat=\"$item in $select.selected track by $index\"><span class=\"ui-select-match-item btn btn-default btn-xs\" tabindex=\"-1\" type=\"button\" ng-disabled=\"$select.disabled\" ng-click=\"$selectMultiple.activeMatchIndex = $index;\" ng-class=\"{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span class=\"close ui-select-match-close\" ng-hide=\"$select.disabled\" ng-click=\"$selectMultiple.removeChoice($index)\">&nbsp;&times;</span> <span uis-transclude-append=\"\"></span></span></span></span>");
      $templateCache.put("bootstrap/match.tpl.html", "<div class=\"ui-select-match\" ng-hide=\"$select.open && $select.searchEnabled\" ng-disabled=\"$select.disabled\" ng-class=\"{\'btn-default-focus\':$select.focus}\"><span tabindex=\"-1\" class=\"btn btn-default form-control ui-select-toggle\" aria-label=\"{{ $select.baseTitle }} activate\" ng-disabled=\"$select.disabled\" ng-click=\"$select.activate()\" style=\"outline: 0;\"><span ng-show=\"$select.isEmpty()\" class=\"ui-select-placeholder text-muted\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"ui-select-match-text pull-left\" ng-class=\"{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}\" ng-transclude=\"\"></span> <i class=\"caret pull-right\" ng-click=\"$select.toggle($event)\"></i> <a ng-show=\"$select.allowClear && !$select.isEmpty() && ($select.disabled !== true)\" aria-label=\"{{ $select.baseTitle }} clear\" style=\"margin-right: 10px\" ng-click=\"$select.clear($event)\" class=\"btn btn-xs btn-link pull-right\"><i class=\"glyphicon glyphicon-remove\" aria-hidden=\"true\"></i></a></span></div>");
      $templateCache.put("bootstrap/no-choice.tpl.html", "<ul class=\"ui-select-no-choice dropdown-menu\" ng-show=\"$select.items.length == 0\"><li ng-transclude=\"\"></li></ul>");
      $templateCache.put("bootstrap/select-multiple.tpl.html", "<div class=\"ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control\" ng-class=\"{open: $select.open}\"><div><div class=\"ui-select-match\"></div><input type=\"search\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" class=\"ui-select-search input-xs\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-click=\"$select.activate()\" ng-model=\"$select.search\" role=\"combobox\" aria-label=\"{{ $select.baseTitle }}\" ondrop=\"return false;\"></div><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div>");
      $templateCache.put("bootstrap/select.tpl.html", "<div class=\"ui-select-container ui-select-bootstrap dropdown\" ng-class=\"{open: $select.open}\"><div class=\"ui-select-match\"></div><input type=\"search\" autocomplete=\"off\" tabindex=\"-1\" aria-expanded=\"true\" aria-label=\"{{ $select.baseTitle }}\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"form-control ui-select-search\" ng-class=\"{ \'ui-select-search-hidden\' : !$select.searchEnabled }\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-show=\"$select.open\"><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div>");
      $templateCache.put("select2/choices.tpl.html", "<ul tabindex=\"-1\" class=\"ui-select-choices ui-select-choices-content select2-results\"><li class=\"ui-select-choices-group\" ng-class=\"{\'select2-result-with-children\': $select.choiceGrouped($group) }\"><div ng-show=\"$select.choiceGrouped($group)\" class=\"ui-select-choices-group-label select2-result-label\" ng-bind=\"$group.name\"></div><ul role=\"listbox\" id=\"ui-select-choices-{{ $select.generatedId }}\" ng-class=\"{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }\"><li role=\"option\" ng-attr-id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}\"><div class=\"select2-result-label ui-select-choices-row-inner\"></div></li></ul></li></ul>");
      $templateCache.put("select2/match-multiple.tpl.html", "<span class=\"ui-select-match\"><li class=\"ui-select-match-item select2-search-choice\" ng-repeat=\"$item in $select.selected track by $index\" ng-class=\"{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span uis-transclude-append=\"\"></span> <a href=\"javascript:;\" class=\"ui-select-match-close select2-search-choice-close\" ng-click=\"$selectMultiple.removeChoice($index)\" tabindex=\"-1\"></a></li></span>");
      $templateCache.put("select2/match.tpl.html", "<a class=\"select2-choice ui-select-match\" ng-class=\"{\'select2-default\': $select.isEmpty()}\" ng-click=\"$select.toggle($event)\" aria-label=\"{{ $select.baseTitle }} select\"><span ng-show=\"$select.isEmpty()\" class=\"select2-chosen\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"select2-chosen\" ng-transclude=\"\"></span> <abbr ng-if=\"$select.allowClear && !$select.isEmpty()\" class=\"select2-search-choice-close\" ng-click=\"$select.clear($event)\"></abbr> <span class=\"select2-arrow ui-select-toggle\"><b></b></span></a>");
      $templateCache.put("select2/no-choice.tpl.html", "<div class=\"ui-select-no-choice dropdown\" ng-show=\"$select.items.length == 0\"><div class=\"dropdown-content\"><div data-selectable=\"\" ng-transclude=\"\"></div></div></div>");
      $templateCache.put("select2/select-multiple.tpl.html", "<div class=\"ui-select-container ui-select-multiple select2 select2-container select2-container-multi\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}\"><ul class=\"select2-choices\"><span class=\"ui-select-match\"></span><li class=\"select2-search-field\"><input type=\"search\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"select2-input ui-select-search\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-hide=\"$select.disabled\" ng-model=\"$select.search\" ng-click=\"$select.activate()\" style=\"width: 34px;\" ondrop=\"return false;\"></li></ul><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open || $select.items.length === 0}\"><div class=\"ui-select-choices\"></div></div></div>");
      $templateCache.put("select2/select.tpl.html", "<div class=\"ui-select-container select2 select2-container\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}\"><div class=\"ui-select-match\"></div><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open}\"><div class=\"search-container\" ng-class=\"{\'ui-select-search-hidden\':!$select.searchEnabled, \'select2-search\':$select.searchEnabled}\"><input type=\"search\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"ui-select-search select2-input\" ng-model=\"$select.search\"></div><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div></div>");
      $templateCache.put("selectize/choices.tpl.html", "<div ng-show=\"$select.open\" class=\"ui-select-choices ui-select-dropdown selectize-dropdown single\"><div class=\"ui-select-choices-content selectize-dropdown-content\"><div class=\"ui-select-choices-group optgroup\" role=\"listbox\"><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label optgroup-header\" ng-bind=\"$group.name\"></div><div role=\"option\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\"><div class=\"option ui-select-choices-row-inner\" data-selectable=\"\"></div></div></div></div></div>");
      $templateCache.put("selectize/match.tpl.html", "<div ng-hide=\"$select.searchEnabled && ($select.open || $select.isEmpty())\" class=\"ui-select-match\"><span ng-show=\"!$select.searchEnabled && ($select.isEmpty() || $select.open)\" class=\"ui-select-placeholder text-muted\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty() || $select.open\" ng-transclude=\"\"></span></div>");
      $templateCache.put("selectize/no-choice.tpl.html", "<div class=\"ui-select-no-choice selectize-dropdown\" ng-show=\"$select.items.length == 0\"><div class=\"selectize-dropdown-content\"><div data-selectable=\"\" ng-transclude=\"\"></div></div></div>");
      $templateCache.put("selectize/select.tpl.html", "<div class=\"ui-select-container selectize-control single\" ng-class=\"{\'open\': $select.open}\"><div class=\"selectize-input\" ng-class=\"{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}\" ng-click=\"$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()\"><div class=\"ui-select-match\"></div><input type=\"search\" autocomplete=\"off\" tabindex=\"-1\" class=\"ui-select-search ui-select-toggle\" ng-class=\"{\'ui-select-search-hidden\':!$select.searchEnabled}\" ng-click=\"$select.toggle($event)\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-hide=\"!$select.isEmpty() && !$select.open\" ng-disabled=\"$select.disabled\" aria-label=\"{{ $select.baseTitle }}\"></div><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div>");
    }]);
  }, {}], 3: [function (require, module, exports) {
    require('./dist/select.js');
    module.exports = 'ui.select';
  }, { "./dist/select.js": 2 }], 4: [function (require, module, exports) {
    /*!
    angular-xeditable - 0.5.0
    Edit-in-place for angular.js
    Build date: 2016-10-27 
    */
    /**
     * Angular-xeditable module 
     *
     */
    angular.module('xeditable', [])

    /**
     * Default options. 
     *
     * @namespace editable-options
     */
    //todo: maybe better have editableDefaults, not options...
    .value('editableOptions', {
      /**
       * Theme. Possible values `bs3`, `bs2`, `default`.  
       * Default is `default`
       * 
       * @var {string} theme
       * @memberOf editable-options
       */
      theme: 'default',
      /**
       * Icon Set. Possible values `font-awesome`, `default`.  
       * Default is `default`
       * 
       * @var {string} icon set
       * @memberOf editable-options
       */
      icon_set: 'default',
      /**
       * Whether to show buttons for single editable element.  
       * Possible values `right`, `no`.  
       * Default is `right`
       * 
       * @var {string} buttons
       * @memberOf editable-options
       */
      buttons: 'right',
      /**
       * Default value for `blur` attribute of single editable element.  
       * Can be `cancel|submit|ignore`.  
       * Default is `cancel`
       * 
       * @var {string} blurElem
       * @memberOf editable-options
       */
      blurElem: 'cancel',
      /**
       * Default value for `blur` attribute of editable form.  
       * Can be `cancel|submit|ignore`.  
       * Default is `ignore`.
       * 
       * @var {string} blurForm
       * @memberOf editable-options
       */
      blurForm: 'ignore',
      /**
       * How input elements get activated. Possible values: `focus|select|none`.  
       * Default is `focus`
       *
       * @var {string} activate
       * @memberOf editable-options
       */
      activate: 'focus',
      /**
       * Whether to disable x-editable. Can be overloaded on each element.  
       * Default is `false`
       *
       * @var {boolean} isDisabled
       * @memberOf editable-options
       */
      isDisabled: false,

      /**
       * Event, on which the edit mode gets activated. 
       * Can be any event.  
       * Default is `click`
       *
       * @var {string} activationEvent
       * @memberOf editable-options
       */
      activationEvent: 'click',

      /**
       * The default title of the submit button.  
       * Default is `Submit`
       *
       * @var {string} submitButtonTitle
       * @memberOf editable-options
       */
      submitButtonTitle: 'Submit',

      /**
       * The default aria label of the submit button.  
       * Default is `Submit`
       *
       * @var {string} submitButtonAriaLabel
       * @memberOf editable-options
       */
      submitButtonAriaLabel: 'Submit',

      /**
       * The default title of the cancel button.  
       * Default is `Cancel`
       *
       * @var {string} cancelButtonTitle
       * @memberOf editable-options
       */
      cancelButtonTitle: 'Cancel',

      /**
       * The default aria label of the cancel button.  
       * Default is `Cancel`
       *
       * @var {string} cancelButtonAriaLabel
       * @memberOf editable-options
       */
      cancelButtonAriaLabel: 'Cancel',

      /**
       * The default title of the clear button.  
       * Default is `Clear`
       *
       * @var {string} clearButtonTitle
       * @memberOf editable-options
       */
      clearButtonTitle: 'Clear',

      /**
       * The default aria label of the clear button.  
       * Default is `Clear`
       *
       * @var {string} clearButtonAriaLabel
       * @memberOf editable-options
       */
      clearButtonAriaLabel: 'Clear',

      /**
       * Whether to display the clear button.  
       * Default is `false`
       *
       * @var {boolean} displayClearButton
       * @memberOf editable-options
       */
      displayClearButton: false
    });

    /*
     Angular-ui bootstrap datepicker
     http://angular-ui.github.io/bootstrap/#/datepicker
     */
    angular.module('xeditable').directive('editableBsdate', ['editableDirectiveFactory', function (editableDirectiveFactory) {
      return editableDirectiveFactory({
        directiveName: 'editableBsdate',
        inputTpl: '<div></div>',
        render: function render() {
          /** This basically renders a datepicker as in the example shown in
           **  http://angular-ui.github.io/bootstrap/#/datepicker
           **  The attributes are all the same as in the bootstrap-ui datepicker with e- as prefix
           **/
          this.parent.render.call(this);

          var inputDatePicker = angular.element('<input type="text" class="form-control" data-ng-model="$parent.$data"/>');

          inputDatePicker.attr('uib-datepicker-popup', this.attrs.eDatepickerPopupXEditable || 'yyyy/MM/dd');
          inputDatePicker.attr('is-open', this.attrs.eIsOpen);
          inputDatePicker.attr('date-disabled', this.attrs.eDateDisabled);
          inputDatePicker.attr('uib-datepicker-popup', this.attrs.eDatepickerPopup);
          inputDatePicker.attr('year-range', this.attrs.eYearRange || 20);
          inputDatePicker.attr('show-button-bar', this.attrs.eShowButtonBar || true);
          inputDatePicker.attr('current-text', this.attrs.eCurrentText || 'Today');
          inputDatePicker.attr('clear-text', this.attrs.eClearText || 'Clear');
          inputDatePicker.attr('close-text', this.attrs.eCloseText || 'Done');
          inputDatePicker.attr('close-on-date-selection', this.attrs.eCloseOnDateSelection || true);
          inputDatePicker.attr('datepicker-append-to-body', this.attrs.eDatePickerAppendToBody || false);
          inputDatePicker.attr('date-disabled', this.attrs.eDateDisabled);
          inputDatePicker.attr('name', this.attrs.eName);
          inputDatePicker.attr('on-open-focus', this.attrs.eOnOpenFocus || true);
          inputDatePicker.attr('ng-readonly', this.attrs.eReadonly || false);

          if (this.attrs.eNgChange) {
            inputDatePicker.attr('ng-change', this.attrs.eNgChange);
            this.inputEl.removeAttr('ng-change');
          }

          if (this.attrs.eStyle) {
            inputDatePicker.attr('style', this.attrs.eStyle);
            this.inputEl.removeAttr('style');
          }

          this.scope.dateOptions = {
            formatDay: this.attrs.eFormatDay || 'dd',
            formatMonth: this.attrs.eFormatMonth || 'MMMM',
            formatYear: this.attrs.eFormatYear || 'yyyy',
            formatDayHeader: this.attrs.eFormatDayHeader || 'EEE',
            formatDayTitle: this.attrs.eFormatDayTitle || 'MMMM yyyy',
            formatMonthTitle: this.attrs.eFormatMonthTitle || 'yyyy',
            showWeeks: this.attrs.eShowWeeks ? this.attrs.eShowWeeks.toLowerCase() === 'true' : true,
            startingDay: this.attrs.eStartingDay || 0,
            minMode: this.attrs.eMinMode || 'day',
            maxMode: this.attrs.eMaxMode || 'year',
            initDate: this.scope.$eval(this.attrs.eInitDate) || new Date(),
            datepickerMode: this.attrs.eDatepickerMode || 'day',
            maxDate: this.scope.$eval(this.attrs.eMaxDate) || null,
            minDate: this.scope.$eval(this.attrs.eMinDate) || null
          };

          var showCalendarButton = angular.isDefined(this.attrs.eShowCalendarButton) ? this.attrs.eShowCalendarButton : "true";

          //See if calendar button should be displayed
          if (showCalendarButton === "true") {
            var buttonDatePicker = angular.element('<button type="button" class="btn btn-default"><i class="glyphicon glyphicon-calendar"></i></button>');
            var buttonWrapper = angular.element('<span class="input-group-btn"></span>');

            buttonDatePicker.attr('ng-click', this.attrs.eNgClick);

            buttonWrapper.append(buttonDatePicker);

            this.inputEl.append(buttonWrapper);
          } else {
            //If no calendar button, display calendar popup on click of input field
            inputDatePicker.attr('ng-click', this.attrs.eNgClick);
          }

          inputDatePicker.attr('datepicker-options', "dateOptions");

          this.inputEl.prepend(inputDatePicker);

          this.inputEl.removeAttr('class');
          this.inputEl.removeAttr('ng-click');
          this.inputEl.removeAttr('is-open');
          this.inputEl.removeAttr('init-date');
          this.inputEl.removeAttr('datepicker-popup');
          this.inputEl.removeAttr('required');
          this.inputEl.removeAttr('ng-model');
          this.inputEl.removeAttr('date-picker-append-to-body');
          this.inputEl.removeAttr('name');
          this.inputEl.attr('class', 'input-group');
        }
      });
    }]);
    /*
    Angular-ui bootstrap editable timepicker
    http://angular-ui.github.io/bootstrap/#/timepicker
    */
    angular.module('xeditable').directive('editableBstime', ['editableDirectiveFactory', function (editableDirectiveFactory) {
      return editableDirectiveFactory({
        directiveName: 'editableBstime',
        inputTpl: '<uib-timepicker></uib-timepicker>',
        render: function render() {
          this.parent.render.call(this);

          // timepicker can't update model when ng-model set directly to it
          // see: https://github.com/angular-ui/bootstrap/issues/1141
          // so we wrap it into DIV
          var div = angular.element('<div class="well well-small" style="display:inline-block;"></div>');

          // move ng-model to wrapping div
          div.attr('ng-model', this.inputEl.attr('ng-model'));
          this.inputEl.removeAttr('ng-model');

          // move ng-change to wrapping div
          if (this.attrs.eNgChange) {
            div.attr('ng-change', this.inputEl.attr('ng-change'));
            this.inputEl.removeAttr('ng-change');
          }

          // wrap
          this.inputEl.wrap(div);
        }
      });
    }]);
    //checkbox
    angular.module('xeditable').directive('editableCheckbox', ['editableDirectiveFactory', function (editableDirectiveFactory) {
      return editableDirectiveFactory({
        directiveName: 'editableCheckbox',
        inputTpl: '<input type="checkbox">',
        render: function render() {
          this.parent.render.call(this);
          if (this.attrs.eTitle) {
            this.inputEl.wrap('<label></label>');
            this.inputEl.parent().append('<span>' + this.attrs.eTitle + '</span>');
          }
        },
        autosubmit: function autosubmit() {
          var self = this;
          self.inputEl.bind('change', function () {
            setTimeout(function () {
              self.scope.$apply(function () {
                self.scope.$form.$submit();
              });
            }, 500);
          });
        }
      });
    }]);

    // checklist
    angular.module('xeditable').directive('editableChecklist', ['editableDirectiveFactory', 'editableNgOptionsParser', function (editableDirectiveFactory, editableNgOptionsParser) {
      return editableDirectiveFactory({
        directiveName: 'editableChecklist',
        inputTpl: '<span></span>',
        useCopy: true,
        render: function render() {
          this.parent.render.call(this);
          var parsed = editableNgOptionsParser(this.attrs.eNgOptions);
          var ngChangeHtml = '';
          var ngChecklistComparatorHtml = '';

          if (this.attrs.eNgChange) {
            ngChangeHtml = ' ng-change="' + this.attrs.eNgChange + '"';
          }

          if (this.attrs.eChecklistComparator) {
            ngChecklistComparatorHtml = ' checklist-comparator="' + this.attrs.eChecklistComparator + '"';
          }

          var html = '<label ng-repeat="' + parsed.ngRepeat + '">' + '<input type="checkbox" checklist-model="$parent.$parent.$data" checklist-value="' + parsed.locals.valueFn + '"' + ngChangeHtml + ngChecklistComparatorHtml + '>' + '<span ng-bind="' + parsed.locals.displayFn + '"></span></label>';

          this.inputEl.removeAttr('ng-model');
          this.inputEl.removeAttr('ng-options');
          this.inputEl.removeAttr('ng-change');
          this.inputEl.removeAttr('checklist-comparator');
          this.inputEl.html(html);
        }
      });
    }]);

    angular.module('xeditable').directive('editableCombodate', ['editableDirectiveFactory', 'editableCombodate', function (editableDirectiveFactory, editableCombodate) {
      return editableDirectiveFactory({
        directiveName: 'editableCombodate',
        inputTpl: '<input type="text">',
        render: function render() {
          this.parent.render.call(this);

          var options = {
            value: new Date(this.scope.$data)
          };
          var self = this;
          angular.forEach(["format", "template", "minYear", "maxYear", "yearDescending", "minuteStep", "secondStep", "firstItem", "errorClass", "customClass", "roundTime", "smartDays"], function (name) {

            var attrName = "e" + name.charAt(0).toUpperCase() + name.slice(1);
            if (attrName in self.attrs) {
              options[name] = self.attrs[attrName];
            }
          });

          var combodate = editableCombodate.getInstance(this.inputEl, options);
          combodate.$widget.find('select').bind('change', function (e) {
            self.scope.$data = new Date(combodate.getValue()).toISOString();
          });
        }
      });
    }]);

    /*
    Input types: text|password|email|tel|number|url|search|color|date|datetime|datetime-local|time|month|week|file
    */

    (function () {

      var camelCase = function camelCase(dashDelimitedString) {
        return dashDelimitedString.toLowerCase().replace(/-(.)/g, function (match, word) {
          return word.toUpperCase();
        });
      };

      var types = 'text|password|email|tel|number|url|search|color|date|datetime|datetime-local|time|month|week|file'.split('|');

      //todo: datalist

      // generate directives
      angular.forEach(types, function (type) {
        var directiveName = camelCase('editable' + '-' + type);
        angular.module('xeditable').directive(directiveName, ['editableDirectiveFactory', function (editableDirectiveFactory) {
          return editableDirectiveFactory({
            directiveName: directiveName,
            inputTpl: '<input type="' + type + '">',
            render: function render() {
              this.parent.render.call(this);

              //Add bootstrap simple input groups
              if (this.attrs.eInputgroupleft || this.attrs.eInputgroupright) {
                this.inputEl.wrap('<div class="input-group"></div>');

                if (this.attrs.eInputgroupleft) {
                  var inputGroupLeft = angular.element('<span class="input-group-addon">' + this.attrs.eInputgroupleft + '</span>');
                  this.inputEl.parent().prepend(inputGroupLeft);
                }

                if (this.attrs.eInputgroupright) {
                  var inputGroupRight = angular.element('<span class="input-group-addon">' + this.attrs.eInputgroupright + '</span>');
                  this.inputEl.parent().append(inputGroupRight);
                }
              }

              // Add label to the input
              if (this.attrs.eLabel) {
                var label = angular.element('<label>' + this.attrs.eLabel + '</label>');
                if (this.attrs.eInputgroupleft || this.attrs.eInputgroupright) {
                  this.inputEl.parent().parent().prepend(label);
                } else {
                  this.inputEl.parent().prepend(label);
                }
              }

              // Add classes to the form
              if (this.attrs.eFormclass) {
                this.editorEl.addClass(this.attrs.eFormclass);
              }
            }
          });
        }]);
      });

      //`range` is bit specific
      angular.module('xeditable').directive('editableRange', ['editableDirectiveFactory', '$interpolate', function (editableDirectiveFactory, $interpolate) {
        return editableDirectiveFactory({
          directiveName: 'editableRange',
          inputTpl: '<input type="range" id="range" name="range">',
          render: function render() {
            this.parent.render.call(this);
            this.inputEl.after('<output>' + $interpolate.startSymbol() + '$data' + $interpolate.endSymbol() + '</output>');
          }
        });
      }]);
    })();

    /*
     Tags input directive for AngularJS
     https://github.com/mbenford/ngTagsInput
     */
    angular.module('xeditable').directive('editableTagsInput', ['editableDirectiveFactory', 'editableUtils', function (editableDirectiveFactory, editableUtils) {
      var dir = editableDirectiveFactory({
        directiveName: 'editableTagsInput',
        inputTpl: '<tags-input></tags-input>',
        render: function render() {
          this.parent.render.call(this);
          this.inputEl.append(editableUtils.rename('auto-complete', this.attrs.$autoCompleteElement));
          this.inputEl.removeAttr('ng-model');
          this.inputEl.attr('ng-model', '$parent.$data');
        }
      });

      var linkOrg = dir.link;

      dir.link = function (scope, el, attrs, ctrl) {
        var autoCompleteEl = el.find('editable-tags-input-auto-complete');

        attrs.$autoCompleteElement = autoCompleteEl.clone();

        autoCompleteEl.remove();

        return linkOrg(scope, el, attrs, ctrl);
      };

      return dir;
    }]);
    // radiolist
    angular.module('xeditable').directive('editableRadiolist', ['editableDirectiveFactory', 'editableNgOptionsParser', '$interpolate', function (editableDirectiveFactory, editableNgOptionsParser, $interpolate) {
      return editableDirectiveFactory({
        directiveName: 'editableRadiolist',
        inputTpl: '<span></span>',
        render: function render() {
          this.parent.render.call(this);
          var parsed = editableNgOptionsParser(this.attrs.eNgOptions);
          var ngChangeHtml = '';

          if (this.attrs.eNgChange) {
            ngChangeHtml = 'ng-change="' + this.attrs.eNgChange + '"';
          }

          var html = '<label data-ng-repeat="' + parsed.ngRepeat + '">' + '<input type="radio" data-ng-disabled="::' + this.attrs.eNgDisabled + '" data-ng-model="$parent.$parent.$data" data-ng-value="' + $interpolate.startSymbol() + '::' + parsed.locals.valueFn + $interpolate.endSymbol() + '"' + ngChangeHtml + '>' + '<span data-ng-bind="::' + parsed.locals.displayFn + '"></span></label>';

          this.inputEl.removeAttr('ng-model');
          this.inputEl.removeAttr('ng-options');
          this.inputEl.removeAttr('ng-change');
          this.inputEl.html(html);
        },
        autosubmit: function autosubmit() {
          var self = this;
          self.inputEl.bind('change', function () {
            setTimeout(function () {
              self.scope.$apply(function () {
                self.scope.$form.$submit();
              });
            }, 500);
          });
        }
      });
    }]);

    //select
    angular.module('xeditable').directive('editableSelect', ['editableDirectiveFactory', function (editableDirectiveFactory) {
      return editableDirectiveFactory({
        directiveName: 'editableSelect',
        inputTpl: '<select></select>',
        render: function render() {
          this.parent.render.call(this);

          if (this.attrs.ePlaceholder) {
            var placeholder = angular.element('<option value="">' + this.attrs.ePlaceholder + '</option>');
            this.inputEl.append(placeholder);
          }
        },
        autosubmit: function autosubmit() {
          var self = this;
          self.inputEl.bind('change', function () {
            self.scope.$apply(function () {
              self.scope.$form.$submit();
            });
          });
        }
      });
    }]);
    //textarea
    angular.module('xeditable').directive('editableTextarea', ['editableDirectiveFactory', function (editableDirectiveFactory) {
      return editableDirectiveFactory({
        directiveName: 'editableTextarea',
        inputTpl: '<textarea></textarea>',
        addListeners: function addListeners() {
          var self = this;
          self.parent.addListeners.call(self);
          // submit textarea by ctrl+enter even with buttons
          if (self.single && self.buttons !== 'no') {
            self.autosubmit();
          }
        },
        autosubmit: function autosubmit() {
          var self = this;
          self.inputEl.bind('keydown', function (e) {
            if ((e.ctrlKey || e.metaKey) && e.keyCode === 13) {
              self.scope.$apply(function () {
                self.scope.$form.$submit();
              });
            }
          });
        }
      });
    }]);

    /*
     AngularJS-native version of Select2 and Selectize
     https://github.com/angular-ui/ui-select
     */
    angular.module('xeditable').directive('editableUiSelect', ['editableDirectiveFactory', 'editableUtils', function (editableDirectiveFactory, editableUtils) {
      var dir = editableDirectiveFactory({
        directiveName: 'editableUiSelect',
        inputTpl: '<ui-select></ui-select>',
        render: function render() {
          this.parent.render.call(this);
          this.inputEl.append(editableUtils.rename('ui-select-match', this.attrs.$matchElement));
          this.inputEl.append(editableUtils.rename('ui-select-choices', this.attrs.$choicesElement));
          this.inputEl.removeAttr('ng-model');
          this.inputEl.attr('ng-model', '$parent.$parent.$data');
        }
      });

      var linkOrg = dir.link;

      dir.link = function (scope, el, attrs, ctrl) {
        var matchEl = el.find('editable-ui-select-match');
        var choicesEl = el.find('editable-ui-select-choices');

        attrs.$matchElement = matchEl.clone();
        attrs.$choicesElement = choicesEl.clone();

        matchEl.remove();
        choicesEl.remove();

        return linkOrg(scope, el, attrs, ctrl);
      };

      return dir;
    }]);
    /**
     * EditableController class. 
     * Attached to element with `editable-xxx` directive.
     *
     * @namespace editable-element
     */
    /*
    TODO: this file should be refactored to work more clear without closures!
    */
    angular.module('xeditable').factory('editableController', ['$q', 'editableUtils', function ($q, editableUtils) {

      //EditableController function
      EditableController.$inject = ['$scope', '$attrs', '$element', '$parse', 'editableThemes', 'editableIcons', 'editableOptions', '$rootScope', '$compile', '$q'];
      function EditableController($scope, $attrs, $element, $parse, editableThemes, editableIcons, editableOptions, $rootScope, $compile, $q) {
        var valueGetter;

        //if control is disabled - it does not participate in waiting process
        var inWaiting;

        var self = this;

        self.scope = $scope;
        self.elem = $element;
        self.attrs = $attrs;
        self.inputEl = null;
        self.editorEl = null;
        self.single = true;
        self.error = '';
        self.theme = editableThemes[$attrs.editableTheme] || editableThemes[editableOptions.theme] || editableThemes['default'];
        self.parent = {};

        //will be undefined if icon_set is default and theme is default
        self.icon_set = editableOptions.icon_set === 'default' ? editableIcons.default[editableOptions.theme] : editableIcons.external[editableOptions.icon_set];

        //to be overwritten by directive
        self.inputTpl = '';
        self.directiveName = '';

        // with majority of controls copy is not needed, but..
        // copy MUST NOT be used for `select-multiple` with objects as items
        // copy MUST be used for `checklist`
        self.useCopy = false;

        //runtime (defaults)
        self.single = null;

        /**
         * Attributes defined with `e-*` prefix automatically transferred from original element to
         * control.  
         * For example, if you set `<span editable-text="user.name" e-style="width: 100px"`>
         * then input will appear as `<input style="width: 100px">`.  
         * See [demo](#text-customize).
         * 
         * @var {any|attribute} e-*
         * @memberOf editable-element
         */

        /**
         * Whether to show ok/cancel buttons. Values: `right|no`.
         * If set to `no` control automatically submitted when value changed.  
         * If control is part of form buttons will never be shown. 
         * 
         * @var {string|attribute} buttons
         * @memberOf editable-element
         */
        self.buttons = 'right';
        /**
         * Action when control losses focus. Values: `cancel|submit|ignore`.
         * Has sense only for single editable element.
         * Otherwise, if control is part of form - you should set `blur` of form, not of individual element.
         * 
         * @var {string|attribute} blur
         * @memberOf editable-element
         */
        // no real `blur` property as it is transferred to editable form

        //init
        self.init = function (single) {
          self.single = single;

          self.name = $attrs.eName || $attrs[self.directiveName];
          /*
          if(!$attrs[directiveName] && !$attrs.eNgModel && ($attrs.eValue === undefined)) {
            throw 'You should provide value for `'+directiveName+'` or `e-value` in editable element!';
          }
          */
          if ($attrs[self.directiveName]) {
            valueGetter = $parse($attrs[self.directiveName]);
          } else {
            throw 'You should provide value for `' + self.directiveName + '` in editable element!';
          }

          // settings for single and non-single
          if (!self.single) {
            // hide buttons for non-single
            self.buttons = 'no';
          } else {
            self.buttons = self.attrs.buttons || editableOptions.buttons;
          }

          //if name defined --> watch changes and update $data in form
          if ($attrs.eName) {
            self.scope.$watch('$data', function (newVal) {
              self.scope.$form.$data[$attrs.eName] = newVal;
            });
          }

          /**
           * Called when control is shown.  
           * See [demo](#select-remote).
           * 
           * @var {method|attribute} onshow
           * @memberOf editable-element
           */
          if ($attrs.onshow) {
            self.onshow = function () {
              return self.catchError($parse($attrs.onshow)($scope));
            };
          }

          /**
           * Called when control is hidden after both save or cancel.  
           * 
           * @var {method|attribute} onhide
           * @memberOf editable-element
           */
          if ($attrs.onhide) {
            self.onhide = function () {
              return $parse($attrs.onhide)($scope);
            };
          }

          /**
           * Called when control is cancelled.  
           * 
           * @var {method|attribute} oncancel
           * @memberOf editable-element
           */
          if ($attrs.oncancel) {
            self.oncancel = function () {
              return $parse($attrs.oncancel)($scope);
            };
          }

          /**
           * Called during submit before value is saved to model.  
           * See [demo](#onbeforesave).
           * 
           * @var {method|attribute} onbeforesave
           * @memberOf editable-element
           */
          if ($attrs.onbeforesave) {
            self.onbeforesave = function () {
              return self.catchError($parse($attrs.onbeforesave)($scope));
            };
          }

          /**
           * Called during submit after value is saved to model.  
           * See [demo](#onaftersave).
           * 
           * @var {method|attribute} onaftersave
           * @memberOf editable-element
           */
          if ($attrs.onaftersave) {
            self.onaftersave = function () {
              return self.catchError($parse($attrs.onaftersave)($scope));
            };
          }

          // watch change of model to update editable element
          // now only add/remove `editable-empty` class.
          // Initially this method called with newVal = undefined, oldVal = undefined
          // so no need initially call handleEmpty() explicitly
          $scope.$parent.$watch($attrs[self.directiveName], function (newVal, oldVal) {
            self.setLocalValue();
            self.handleEmpty();
          });
        };

        self.render = function () {
          var theme = self.theme;

          //build input
          self.inputEl = angular.element(self.inputTpl);

          //build controls
          self.controlsEl = angular.element(theme.controlsTpl);
          self.controlsEl.append(self.inputEl);

          //build buttons
          if (self.buttons !== 'no') {
            self.buttonsEl = angular.element(theme.buttonsTpl);
            self.submitEl = angular.element(theme.submitTpl);
            self.resetEl = angular.element(theme.resetTpl);
            self.cancelEl = angular.element(theme.cancelTpl);
            self.submitEl.attr('title', editableOptions.submitButtonTitle);
            self.submitEl.attr('aria-label', editableOptions.submitButtonAriaLabel);
            self.cancelEl.attr('title', editableOptions.cancelButtonTitle);
            self.cancelEl.attr('aria-label', editableOptions.cancelButtonAriaLabel);
            self.resetEl.attr('title', editableOptions.clearButtonTitle);
            self.resetEl.attr('aria-label', editableOptions.clearButtonAriaLabel);

            if (self.icon_set) {
              self.submitEl.find('span').addClass(self.icon_set.ok);
              self.cancelEl.find('span').addClass(self.icon_set.cancel);
              self.resetEl.find('span').addClass(self.icon_set.clear);
            }

            self.buttonsEl.append(self.submitEl).append(self.cancelEl);

            if (editableOptions.displayClearButton) {
              self.buttonsEl.append(self.resetEl);
            }

            self.controlsEl.append(self.buttonsEl);

            self.inputEl.addClass('editable-has-buttons');
          }

          //build error
          self.errorEl = angular.element(theme.errorTpl);
          self.controlsEl.append(self.errorEl);

          //build editor
          self.editorEl = angular.element(self.single ? theme.formTpl : theme.noformTpl);
          self.editorEl.append(self.controlsEl);

          // transfer `e-*|data-e-*|x-e-*` attributes
          for (var k in $attrs.$attr) {
            if (k.length <= 1) {
              continue;
            }
            var transferAttr = false;
            var nextLetter = k.substring(1, 2);

            // if starts with `e` + uppercase letter
            if (k.substring(0, 1) === 'e' && nextLetter === nextLetter.toUpperCase()) {
              transferAttr = k.substring(1); // cut `e`
            } else {
              continue;
            }

            // exclude `form` and `ng-submit`, 
            if (transferAttr === 'Form' || transferAttr === 'NgSubmit') {
              continue;
            }

            var firstLetter = transferAttr.substring(0, 1);
            var secondLetter = transferAttr.substring(1, 2);

            // convert back to lowercase style
            if (secondLetter === secondLetter.toUpperCase() && firstLetter === firstLetter.toUpperCase()) {
              transferAttr = firstLetter.toLowerCase() + '-' + editableUtils.camelToDash(transferAttr.substring(1));
            } else {
              transferAttr = firstLetter.toLowerCase() + editableUtils.camelToDash(transferAttr.substring(1));
            }

            // workaround for attributes without value (e.g. `multiple = "multiple"`)
            // except for 'e-value'
            var attrValue = transferAttr !== 'value' && $attrs[k] === '' ? transferAttr : $attrs[k];

            // set attributes to input
            self.inputEl.attr(transferAttr, attrValue);
          }

          self.inputEl.addClass('editable-input');
          self.inputEl.attr('ng-model', '$parent.$data');

          // add directiveName class to editor, e.g. `editable-text`
          self.editorEl.addClass(editableUtils.camelToDash(self.directiveName));

          if (self.single) {
            self.editorEl.attr('editable-form', '$form');
            // transfer `blur` to form
            self.editorEl.attr('blur', self.attrs.blur || (self.buttons === 'no' ? 'cancel' : editableOptions.blurElem));
          }

          //apply `postrender` method of theme
          if (angular.isFunction(theme.postrender)) {
            theme.postrender.call(self);
          }
        };

        // with majority of controls copy is not needed, but..
        // copy MUST NOT be used for `select-multiple` with objects as items
        // copy MUST be used for `checklist`
        self.setLocalValue = function () {
          self.scope.$data = self.useCopy ? angular.copy(valueGetter($scope.$parent)) : valueGetter($scope.$parent);
        };

        // reference of the scope to use for $compile
        var newScope = null;
        //show
        self.show = function () {
          // set value of scope.$data
          self.setLocalValue();

          /*
          Originally render() was inside init() method, but some directives polluting editorEl,
          so it is broken on second openning.
          Cloning is not a solution as jqLite can not clone with event handler's.
          */
          self.render();

          // insert into DOM
          $element.after(self.editorEl);

          // compile (needed to attach ng-* events from markup)
          newScope = $scope.$new();
          $compile(self.editorEl)(newScope);

          // attach listeners (`escape`, autosubmit, etc)
          self.addListeners();

          // hide element
          $element.addClass('editable-hide');

          // onshow
          return self.onshow();
        };

        //hide
        self.hide = function () {

          // destroy the scope to prevent memory leak
          newScope.$destroy();

          self.controlsEl.remove();
          self.editorEl.remove();
          $element.removeClass('editable-hide');

          // onhide
          return self.onhide();
        };

        // cancel
        self.cancel = function () {
          // oncancel
          self.oncancel();
          // don't call hide() here as it called in form's code
        };

        /*
        Called after show to attach listeners
        */
        self.addListeners = function () {
          // bind keyup for `escape`
          self.inputEl.bind('keyup', function (e) {
            if (!self.single) {
              return;
            }

            // todo: move this to editable-form!
            switch (e.keyCode) {
              // hide on `escape` press
              case 27:
                self.scope.$apply(function () {
                  self.scope.$form.$cancel();
                });
                break;
            }
          });

          // autosubmit when `no buttons`
          if (self.single && self.buttons === 'no') {
            self.autosubmit();
          }

          // click - mark element as clicked to exclude in document click handler
          self.editorEl.bind('click', function (e) {
            // ignore right/middle button click
            if (e.which && e.which !== 1) {
              return;
            }

            if (self.scope.$form.$visible) {
              self.scope.$form._clicked = true;
            }
          });
        };

        // setWaiting
        self.setWaiting = function (value) {
          if (value) {
            // participate in waiting only if not disabled
            inWaiting = !self.inputEl.attr('disabled') && !self.inputEl.attr('ng-disabled') && !self.inputEl.attr('ng-enabled');
            if (inWaiting) {
              self.inputEl.attr('disabled', 'disabled');
              if (self.buttonsEl) {
                self.buttonsEl.find('button').attr('disabled', 'disabled');
              }
            }
          } else {
            if (inWaiting) {
              self.inputEl.removeAttr('disabled');
              if (self.buttonsEl) {
                self.buttonsEl.find('button').removeAttr('disabled');
              }
            }
          }
        };

        self.activate = function (start, end) {
          setTimeout(function () {
            var el = self.inputEl[0];

            if (editableOptions.activate === 'focus' && el.focus) {
              if (start) {
                end = end || start;
                el.onfocus = function () {
                  var that = this;
                  setTimeout(function () {
                    that.setSelectionRange(start, end);
                  });
                };
              }

              if (self.directiveName == 'editableRadiolist' || self.directiveName == 'editableChecklist' || self.directiveName == 'editableBsdate' || self.directiveName == 'editableTagsInput') {
                //Set focus to first pristine element in the list
                el.querySelector('.ng-pristine').focus();
              } else {
                el.focus();
              }
            } else if (editableOptions.activate === 'select') {
              if (el.select) {
                el.select();
              } else if (el.focus) {
                el.focus();
              }
            }
          }, 0);
        };

        self.setError = function (msg) {
          if (!angular.isObject(msg)) {
            $scope.$error = msg;
            self.error = msg;
          }
        };

        /*
        Checks that result is string or promise returned string and shows it as error message
        Applied to onshow, onbeforesave, onaftersave
        */
        self.catchError = function (result, noPromise) {
          if (angular.isObject(result) && noPromise !== true) {
            $q.when(result).then(
            //success and fail handlers are equal
            angular.bind(this, function (r) {
              this.catchError(r, true);
            }), angular.bind(this, function (r) {
              this.catchError(r, true);
            }));
            //check $http error
          } else if (noPromise && angular.isObject(result) && result.status && result.status !== 200 && result.data && angular.isString(result.data)) {
            this.setError(result.data);
            //set result to string: to let form know that there was error
            result = result.data;
          } else if (angular.isString(result)) {
            this.setError(result);
          }
          return result;
        };

        self.save = function () {
          valueGetter.assign($scope.$parent, self.useCopy ? angular.copy(self.scope.$data) : self.scope.$data);

          // no need to call handleEmpty here as we are watching change of model value
          // self.handleEmpty();
        };

        /*
        attach/detach `editable-empty` class to element
        */
        self.handleEmpty = function () {
          var val = valueGetter($scope.$parent);
          var isEmpty = val === null || val === undefined || val === "" || angular.isArray(val) && val.length === 0;
          $element.toggleClass('editable-empty', isEmpty);
        };

        /*
        Called when `buttons = "no"` to submit automatically
        */
        self.autosubmit = angular.noop;

        self.onshow = angular.noop;
        self.onhide = angular.noop;
        self.oncancel = angular.noop;
        self.onbeforesave = angular.noop;
        self.onaftersave = angular.noop;
      }

      return EditableController;
    }]);

    /*
    editableFactory is used to generate editable directives (see `/directives` folder)
    Inside it does several things:
    - detect form for editable element. Form may be one of three types:
      1. autogenerated form (for single editable elements)
      2. wrapper form (element wrapped by <form> tag)
      3. linked form (element has `e-form` attribute pointing to existing form)
    
    - attach editableController to element
    
    Depends on: editableController, editableFormFactory
    */
    angular.module('xeditable').factory('editableDirectiveFactory', ['$parse', '$compile', 'editableThemes', '$rootScope', '$document', 'editableController', 'editableFormController', 'editableOptions', function ($parse, $compile, editableThemes, $rootScope, $document, editableController, editableFormController, editableOptions) {

      //directive object
      return function (overwrites) {
        return {
          restrict: 'A',
          scope: true,
          require: [overwrites.directiveName, '?^form'],
          controller: editableController,
          link: function link(scope, elem, attrs, ctrl) {
            // editable controller
            var eCtrl = ctrl[0];

            // form controller
            var eFormCtrl;

            // this variable indicates is element is bound to some existing form,
            // or it's single element who's form will be generated automatically
            // By default consider single element without any linked form.
            var hasForm = false;

            // element wrapped by form
            if (ctrl[1]) {
              eFormCtrl = ctrl[1];
              hasForm = attrs.eSingle === undefined;
            } else if (attrs.eForm) {
              // element not wrapped by <form>, but we have `e-form` attr
              var getter = $parse(attrs.eForm)(scope);
              if (getter) {
                // form exists in scope (above), e.g. editable column
                eFormCtrl = getter;
                hasForm = true;
              } else if (elem && typeof elem.parents === "function" && elem.parents().last().find('form[name=' + attrs.eForm + ']').length) {
                // form exists below or not exist at all: check document.forms
                // form is below and not processed yet
                eFormCtrl = null;
                hasForm = true;
              } else {
                // form exists below or not exist at all: check document.forms
                for (var i = 0; i < $document[0].forms.length; i++) {
                  if ($document[0].forms[i].name === attrs.eForm) {
                    // form is below and not processed yet
                    eFormCtrl = null;
                    hasForm = true;
                    break;
                  }
                }
              }
            }

            /*
            if(hasForm && !attrs.eName) {
              throw 'You should provide `e-name` for editable element inside form!';
            }
            */

            //check for `editable-form` attr in form
            /*
            if(eFormCtrl && ) {
              throw 'You should provide `e-name` for editable element inside form!';
            }
            */

            // store original props to `parent` before merge
            angular.forEach(overwrites, function (v, k) {
              if (eCtrl[k] !== undefined) {
                eCtrl.parent[k] = eCtrl[k];
              }
            });

            // merge overwrites to base editable controller
            angular.extend(eCtrl, overwrites);

            // x-editable can be disabled using editableOption or edit-disabled attribute
            var is_disabled = function is_disabled() {
              return angular.isDefined(attrs.editDisabled) ? scope.$eval(attrs.editDisabled) : editableOptions.isDisabled;
            };

            // init editable ctrl
            eCtrl.init(!hasForm);

            // publich editable controller as `$editable` to be referenced in html
            scope.$editable = eCtrl;

            // add `editable` class to element
            elem.addClass('editable');

            // hasForm
            if (hasForm) {
              if (eFormCtrl) {
                scope.$form = eFormCtrl;
                if (!scope.$form.$addEditable) {
                  throw 'Form with editable elements should have `editable-form` attribute.';
                }
                scope.$form.$addEditable(eCtrl);
              } else {
                // future form (below): add editable controller to buffer and add to form later
                $rootScope.$$editableBuffer = $rootScope.$$editableBuffer || {};
                $rootScope.$$editableBuffer[attrs.eForm] = $rootScope.$$editableBuffer[attrs.eForm] || [];
                $rootScope.$$editableBuffer[attrs.eForm].push(eCtrl);
                scope.$form = null; //will be re-assigned later
              }
              // !hasForm
            } else {
              // create editableform controller
              scope.$form = editableFormController();
              // add self to editable controller
              scope.$form.$addEditable(eCtrl);

              // if `e-form` provided, publish local $form in scope
              if (attrs.eForm) {
                ($parse(attrs.eForm).assign || angular.noop)(scope.$parent, scope.$form);
              }

              // bind click - if no external form defined
              if (!attrs.eForm || attrs.eClickable) {
                elem.addClass('editable-click');
                elem.bind(editableOptions.activationEvent, function (e) {
                  e.preventDefault();
                  e.editable = eCtrl;
                  if (!is_disabled()) {
                    scope.$apply(function () {
                      scope.$form.$show();
                    });
                  }
                });
              }
            }
          }
        };
      };
    }]);

    /*
    Returns editableForm controller
    */
    angular.module('xeditable').factory('editableFormController', ['$parse', '$document', '$rootScope', 'editablePromiseCollection', 'editableUtils', function ($parse, $document, $rootScope, editablePromiseCollection, editableUtils) {

      // array of opened editable forms
      var shown = [];

      //Check if the child element correspond or is a descendant of the parent element
      var isSelfOrDescendant = function isSelfOrDescendant(parent, child) {
        if (child == parent) {
          return true;
        }

        var node = child.parentNode;
        while (node !== null) {
          if (node == parent) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      };

      //Check if it is a real blur : if the click event appear on a shown editable elem, this is not a blur.
      var isBlur = function isBlur(shown, event) {
        var isBlur = true;

        var editables = shown.$editables;
        angular.forEach(editables, function (v) {
          var element = v.editorEl[0];
          if (isSelfOrDescendant(element, event.target)) isBlur = false;
        });
        return isBlur;
      };

      // bind click to body: cancel|submit|ignore forms
      $document.bind('click', function (e) {
        // ignore right/middle button click
        if (e.which && e.which !== 1) {
          return;
        }

        var toCancel = [];
        var toSubmit = [];
        for (var i = 0; i < shown.length; i++) {

          // exclude clicked
          if (shown[i]._clicked) {
            shown[i]._clicked = false;
            continue;
          }

          // exclude waiting
          if (shown[i].$waiting) {
            continue;
          }

          if (shown[i]._blur === 'cancel' && isBlur(shown[i], e)) {
            toCancel.push(shown[i]);
          }

          if (shown[i]._blur === 'submit' && isBlur(shown[i], e)) {
            toSubmit.push(shown[i]);
          }
        }

        if (toCancel.length || toSubmit.length) {
          $rootScope.$apply(function () {
            angular.forEach(toCancel, function (v) {
              v.$cancel();
            });
            angular.forEach(toSubmit, function (v) {
              v.$submit();
            });
          });
        }
      });

      $rootScope.$on('closeEdit', function () {
        for (var i = 0; i < shown.length; i++) {
          shown[i].$hide();
        }
      });

      var base = {
        $addEditable: function $addEditable(editable) {
          //console.log('add editable', editable.elem, editable.elem.bind);
          this.$editables.push(editable);

          //'on' is not supported in angular 1.0.8
          editable.elem.bind('$destroy', angular.bind(this, this.$removeEditable, editable));

          //bind editable's local $form to self (if not bound yet, below form) 
          if (!editable.scope.$form) {
            editable.scope.$form = this;
          }

          //if form already shown - call show() of new editable
          if (this.$visible) {
            editable.catchError(editable.show());
          }
          editable.catchError(editable.setWaiting(this.$waiting));
        },

        $removeEditable: function $removeEditable(editable) {
          //arrayRemove
          for (var i = 0; i < this.$editables.length; i++) {
            if (this.$editables[i] === editable) {
              this.$editables.splice(i, 1);
              return;
            }
          }
        },

        /**
         * Shows form with editable controls.
         * 
         * @method $show()
         * @memberOf editable-form
         */
        $show: function $show() {
          if (this.$visible) {
            return;
          }

          this.$visible = true;

          var pc = editablePromiseCollection();

          //own show
          pc.when(this.$onshow());

          //clear errors
          this.$setError(null, '');

          //children show
          angular.forEach(this.$editables, function (editable) {
            pc.when(editable.show());
          });

          //wait promises and activate
          pc.then({
            onWait: angular.bind(this, this.$setWaiting),
            onTrue: angular.bind(this, this.$activate),
            onFalse: angular.bind(this, this.$activate),
            onString: angular.bind(this, this.$activate)
          });

          // add to internal list of shown forms
          // setTimeout needed to prevent closing right after opening (e.g. when trigger by button)
          setTimeout(angular.bind(this, function () {
            // clear `clicked` to get ready for clicks on visible form
            this._clicked = false;
            if (editableUtils.indexOf(shown, this) === -1) {
              shown.push(this);
            }
          }), 0);
        },

        /**
         * Sets focus on form field specified by `name`.<br/>
         * When trying to set the focus on a form field of a new row in the editable table, the `$activate` call needs to be wrapped in a `$timeout` call so that the form is rendered before the `$activate` function is called.
         * 
         * @method $activate(name)
         * @param {string} name name of field
         * @memberOf editable-form
         */
        $activate: function $activate(name) {
          var i;
          if (this.$editables.length) {
            //activate by name
            if (angular.isString(name)) {
              for (i = 0; i < this.$editables.length; i++) {
                if (this.$editables[i].name === name) {
                  this.$editables[i].activate();
                  return;
                }
              }
            }

            //try activate error field
            for (i = 0; i < this.$editables.length; i++) {
              if (this.$editables[i].error) {
                this.$editables[i].activate();
                return;
              }
            }

            //by default activate first field
            this.$editables[0].activate(this.$editables[0].elem[0].selectionStart, this.$editables[0].elem[0].selectionEnd);
          }
        },

        /**
         * Hides form with editable controls without saving.
         * 
         * @method $hide()
         * @memberOf editable-form
         */
        $hide: function $hide() {
          if (!this.$visible) {
            return;
          }
          this.$visible = false;
          // self hide
          this.$onhide();
          // children's hide
          angular.forEach(this.$editables, function (editable) {
            editable.hide();
          });

          // remove from internal list of shown forms
          editableUtils.arrayRemove(shown, this);
        },

        /**
         * Triggers `oncancel` event and calls `$hide()`.
         * 
         * @method $cancel()
         * @memberOf editable-form
         */
        $cancel: function $cancel() {
          if (!this.$visible) {
            return;
          }
          // self cancel
          this.$oncancel();
          // children's cancel      
          angular.forEach(this.$editables, function (editable) {
            editable.cancel();
          });
          // self hide
          this.$hide();
        },

        $setWaiting: function $setWaiting(value) {
          this.$waiting = !!value;
          // we can't just set $waiting variable and use it via ng-disabled in children
          // because in editable-row form is not accessible
          angular.forEach(this.$editables, function (editable) {
            editable.setWaiting(!!value);
          });
        },

        /**
         * Shows error message for particular field.
         * 
         * @method $setError(name, msg)
         * @param {string} name name of field
         * @param {string} msg error message
         * @memberOf editable-form
         */
        $setError: function $setError(name, msg) {
          angular.forEach(this.$editables, function (editable) {
            if (!name || editable.name === name) {
              editable.setError(msg);
            }
          });
        },

        $submit: function $submit() {
          if (this.$waiting) {
            return;
          }

          //clear errors
          this.$setError(null, '');

          //children onbeforesave
          var pc = editablePromiseCollection();
          angular.forEach(this.$editables, function (editable) {
            pc.when(editable.onbeforesave());
          });

          /*
          onbeforesave result:
          - true/undefined: save data and close form
          - false: close form without saving
          - string: keep form open and show error
          */
          pc.then({
            onWait: angular.bind(this, this.$setWaiting),
            onTrue: angular.bind(this, checkSelf, true),
            onFalse: angular.bind(this, checkSelf, false),
            onString: angular.bind(this, this.$activate)
          });

          //save
          function checkSelf(childrenTrue) {
            var pc = editablePromiseCollection();
            pc.when(this.$onbeforesave());
            pc.then({
              onWait: angular.bind(this, this.$setWaiting),
              onTrue: childrenTrue ? angular.bind(this, this.$save) : angular.bind(this, this.$hide),
              onFalse: angular.bind(this, this.$hide),
              onString: angular.bind(this, this.$activate)
            });
          }
        },

        $save: function $save() {
          // write model for each editable
          angular.forEach(this.$editables, function (editable) {
            editable.save();
          });

          //call onaftersave of self and children
          var pc = editablePromiseCollection();
          pc.when(this.$onaftersave());
          angular.forEach(this.$editables, function (editable) {
            pc.when(editable.onaftersave());
          });

          /*
          onaftersave result:
          - true/undefined/false: just close form
          - string: keep form open and show error
          */
          pc.then({
            onWait: angular.bind(this, this.$setWaiting),
            onTrue: angular.bind(this, this.$hide),
            onFalse: angular.bind(this, this.$hide),
            onString: angular.bind(this, this.$activate)
          });
        },

        $onshow: angular.noop,
        $oncancel: angular.noop,
        $onhide: angular.noop,
        $onbeforesave: angular.noop,
        $onaftersave: angular.noop
      };

      return function () {
        return angular.extend({
          $editables: [],
          /**
           * Form visibility flag.
           * 
           * @var {bool} $visible
           * @memberOf editable-form
           */
          $visible: false,
          /**
           * Form waiting flag. It becomes `true` when form is loading or saving data.
           * 
           * @var {bool} $waiting
           * @memberOf editable-form
           */
          $waiting: false,
          $data: {},
          _clicked: false,
          _blur: null
        }, base);
      };
    }]);

    /**
     * EditableForm directive. Should be defined in <form> containing editable controls.  
     * It add some usefull methods to form variable exposed to scope by `name="myform"` attribute.
     *
     * @namespace editable-form
     */
    angular.module('xeditable').directive('editableForm', ['$rootScope', '$parse', 'editableFormController', 'editableOptions', function ($rootScope, $parse, editableFormController, editableOptions) {
      return {
        restrict: 'A',
        require: ['form'],
        //require: ['form', 'editableForm'],
        //controller: EditableFormController,
        compile: function compile() {
          return {
            pre: function pre(scope, elem, attrs, ctrl) {
              var form = ctrl[0];
              var eForm;

              //if `editableForm` has value - publish smartly under this value
              //this is required only for single editor form that is created and removed
              if (attrs.editableForm) {
                if (scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
                  eForm = scope[attrs.editableForm];
                  angular.extend(form, eForm);
                } else {
                  eForm = editableFormController();
                  scope[attrs.editableForm] = eForm;
                  angular.extend(eForm, form);
                }
              } else {
                //just merge to form and publish if form has name
                eForm = editableFormController();
                angular.extend(form, eForm);
              }

              //read editables from buffer (that appeared before FORM tag)
              var buf = $rootScope.$$editableBuffer;
              var name = form.$name;
              if (name && buf && buf[name]) {
                angular.forEach(buf[name], function (editable) {
                  eForm.$addEditable(editable);
                });
                delete buf[name];
              }
            },
            post: function post(scope, elem, attrs, ctrl) {
              var eForm;

              if (attrs.editableForm && scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
                eForm = scope[attrs.editableForm];
              } else {
                eForm = ctrl[0];
              }

              /**
               * Called when form is shown.
               * 
               * @var {method|attribute} onshow 
               * @memberOf editable-form
               */
              if (attrs.onshow) {
                eForm.$onshow = angular.bind(eForm, $parse(attrs.onshow), scope);
              }

              /**
               * Called when form hides after both save or cancel.
               * 
               * @var {method|attribute} onhide 
               * @memberOf editable-form
               */
              if (attrs.onhide) {
                eForm.$onhide = angular.bind(eForm, $parse(attrs.onhide), scope);
              }

              /**
               * Called when form is cancelled.
               * 
               * @var {method|attribute} oncancel
               * @memberOf editable-form
               */
              if (attrs.oncancel) {
                eForm.$oncancel = angular.bind(eForm, $parse(attrs.oncancel), scope);
              }

              /**
               * Whether form initially rendered in shown state.
               *
               * @var {bool|attribute} shown
               * @memberOf editable-form
               */
              if (attrs.shown && $parse(attrs.shown)(scope)) {
                eForm.$show();
              }

              /**
               * Action when form losses focus. Values: `cancel|submit|ignore`.
               * Default is `ignore`.
               * 
               * @var {string|attribute} blur
               * @memberOf editable-form
               */
              eForm._blur = attrs.blur || editableOptions.blurForm;

              // onbeforesave, onaftersave
              if (!attrs.ngSubmit && !attrs.submit) {
                /**
                 * Called after all children `onbeforesave` callbacks but before saving form values
                 * to model.  
                 * If at least one children callback returns `non-string` - it will not not be called.  
                 * See [editable-form demo](#editable-form) for details.
                 * 
                 * @var {method|attribute} onbeforesave
                 * @memberOf editable-form
                 * 
                 */
                if (attrs.onbeforesave) {
                  eForm.$onbeforesave = function () {
                    return $parse(attrs.onbeforesave)(scope, { $data: eForm.$data });
                  };
                }

                /**
                 * Called when form values are saved to model.  
                 * See [editable-form demo](#editable-form) for details.
                 * 
                 * @var {method|attribute} onaftersave 
                 * @memberOf editable-form
                 * 
                 */
                if (attrs.onaftersave) {
                  eForm.$onaftersave = function () {
                    return $parse(attrs.onaftersave)(scope, { $data: eForm.$data });
                  };
                }

                elem.bind('submit', function (event) {
                  event.preventDefault();
                  scope.$apply(function () {
                    eForm.$submit();
                  });
                });
              }

              // click - mark form as clicked to exclude in document click handler
              elem.bind('click', function (e) {
                // ignore right/middle button click
                if (e.which && e.which !== 1) {
                  return;
                }

                if (eForm.$visible) {
                  eForm._clicked = true;
                }
              });
            }
          };
        }
      };
    }]);
    /**
     * editablePromiseCollection
     *  
     * Collect results of function calls. Shows waiting if there are promises. 
     * Finally, applies callbacks if:
     * - onTrue(): all results are true and all promises resolved to true
     * - onFalse(): at least one result is false or promise resolved to false
     * - onString(): at least one result is string or promise rejected or promise resolved to string
     */

    angular.module('xeditable').factory('editablePromiseCollection', ['$q', function ($q) {

      function promiseCollection() {
        return {
          promises: [],
          hasFalse: false,
          hasString: false,
          when: function when(result, noPromise) {
            if (result === false) {
              this.hasFalse = true;
            } else if (!noPromise && angular.isObject(result)) {
              this.promises.push($q.when(result));
            } else if (angular.isString(result)) {
              this.hasString = true;
            } else {
              //result === true || result === undefined || result === null
              return;
            }
          },
          //callbacks: onTrue, onFalse, onString
          then: function then(callbacks) {
            callbacks = callbacks || {};
            var onTrue = callbacks.onTrue || angular.noop;
            var onFalse = callbacks.onFalse || angular.noop;
            var onString = callbacks.onString || angular.noop;
            var onWait = callbacks.onWait || angular.noop;

            var self = this;

            if (this.promises.length) {
              onWait(true);
              $q.all(this.promises).then(
              //all resolved       
              function (results) {
                onWait(false);
                //check all results via same `when` method (without checking promises)
                angular.forEach(results, function (result) {
                  self.when(result, true);
                });
                applyCallback();
              },
              //some rejected
              function (error) {
                onWait(false);
                onString();
              });
            } else {
              applyCallback();
            }

            function applyCallback() {
              if (!self.hasString && !self.hasFalse) {
                onTrue();
              } else if (!self.hasString && self.hasFalse) {
                onFalse();
              } else {
                onString();
              }
            }
          }
        };
      }

      return promiseCollection;
    }]);

    /**
     * editableUtils
     */
    angular.module('xeditable').factory('editableUtils', [function () {
      return {
        indexOf: function indexOf(array, obj) {
          if (array.indexOf) return array.indexOf(obj);

          for (var i = 0; i < array.length; i++) {
            if (obj === array[i]) return i;
          }
          return -1;
        },

        arrayRemove: function arrayRemove(array, value) {
          var index = this.indexOf(array, value);
          if (index >= 0) {
            array.splice(index, 1);
          }
          return value;
        },

        // copy from https://github.com/angular/angular.js/blob/master/src/Angular.js
        camelToDash: function camelToDash(str) {
          var SNAKE_CASE_REGEXP = /[A-Z]/g;
          return str.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
            return (pos ? '-' : '') + letter.toLowerCase();
          });
        },

        dashToCamel: function dashToCamel(str) {
          var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
          var MOZ_HACK_REGEXP = /^moz([A-Z])/;
          return str.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
          }).replace(MOZ_HACK_REGEXP, 'Moz$1');
        },

        rename: function rename(tag, el) {
          if (el[0] && el[0].attributes) {
            var newEl = angular.element('<' + tag + '/>');
            newEl.html(el.html());
            var attrs = el[0].attributes;
            for (var i = 0; i < attrs.length; ++i) {
              newEl.attr(attrs.item(i).nodeName, attrs.item(i).value);
            }
            return newEl;
          }
        }
      };
    }]);

    /**
     * editableNgOptionsParser
     *
     * see: https://github.com/angular/angular.js/blob/master/src/ng/directive/select.js#L131
     */
    angular.module('xeditable').factory('editableNgOptionsParser', [function () {
      //0000111110000000000022220000000000000000000000333300000000000000444444444444444000000000555555555555555000000066666666666666600000000000000007777000000000000000000088888
      var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/;

      function parser(optionsExp) {
        var match;

        if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
          throw 'ng-options parse error';
        }

        var displayFn = match[2] || match[1],
            valueName = match[4] || match[6],
            keyName = match[5],
            groupByFn = match[3] || '',
            valueFn = match[2] ? match[1] : valueName,
            valuesFn = match[7],
            track = match[8],
            trackFn = track ? match[8] : null;

        var ngRepeat;
        if (keyName === undefined) {
          // array
          ngRepeat = valueName + ' in ' + valuesFn;
          if (track !== undefined) {
            ngRepeat += ' track by ' + trackFn;
          }
        } else {
          // object
          ngRepeat = '(' + keyName + ', ' + valueName + ') in ' + valuesFn;
        }

        // group not supported yet
        return {
          ngRepeat: ngRepeat,
          locals: {
            valueName: valueName,
            keyName: keyName,
            valueFn: valueFn,
            displayFn: displayFn
          }
        };
      }

      return parser;
    }]);

    /**
     * editableCombodate
     *
     * angular version of https://github.com/vitalets/combodate
     */
    angular.module('xeditable').factory('editableCombodate', [function () {
      function Combodate(element, options) {
        this.$element = angular.element(element);

        if (this.$element[0].nodeName != 'INPUT') {
          throw 'Combodate should be applied to INPUT element';
        }

        var currentYear = new Date().getFullYear();
        this.defaults = {
          //in this format value stored in original input
          format: 'YYYY-MM-DD HH:mm',
          //in this format items in dropdowns are displayed
          template: 'D / MMM / YYYY   H : mm',
          //initial value, can be `new Date()`
          value: null,
          minYear: 1970,
          maxYear: currentYear,
          yearDescending: true,
          minuteStep: 5,
          secondStep: 1,
          firstItem: 'empty', //'name', 'empty', 'none'
          errorClass: null,
          customClass: '',
          roundTime: true, // whether to round minutes and seconds if step > 1
          smartDays: true // whether days in combo depend on selected month: 31, 30, 28
        };

        this.options = angular.extend({}, this.defaults, options);
        this.init();
      }

      Combodate.prototype = {
        constructor: Combodate,
        init: function init() {
          this.map = {
            //key   regexp    moment.method
            day: ['D', 'date'],
            month: ['M', 'month'],
            year: ['Y', 'year'],
            hour: ['[Hh]', 'hours'],
            minute: ['m', 'minutes'],
            second: ['s', 'seconds'],
            ampm: ['[Aa]', '']
          };

          this.$widget = angular.element('<span class="combodate"></span>').html(this.getTemplate());

          this.initCombos();

          if (this.options.smartDays) {
            var combo = this;
            this.$widget.find('select').bind('change', function (e) {
              // update days count if month or year changes
              if (angular.element(e.target).hasClass('month') || angular.element(e.target).hasClass('year')) {
                combo.fillCombo('day');
              }
            });
          }

          this.$widget.find('select').css('width', 'auto');

          // hide original input and insert widget                                       
          this.$element.css('display', 'none').after(this.$widget);

          // set initial value
          this.setValue(this.$element.val() || this.options.value);
        },

        /*
         Replace tokens in template with <select> elements 
         */
        getTemplate: function getTemplate() {
          var tpl = this.options.template;
          var customClass = this.options.customClass;

          //first pass
          angular.forEach(this.map, function (v, k) {
            v = v[0];
            var r = new RegExp(v + '+');
            var token = v.length > 1 ? v.substring(1, 2) : v;

            tpl = tpl.replace(r, '{' + token + '}');
          });

          //replace spaces with &nbsp;
          tpl = tpl.replace(/ /g, '&nbsp;');

          //second pass
          angular.forEach(this.map, function (v, k) {
            v = v[0];
            var token = v.length > 1 ? v.substring(1, 2) : v;

            tpl = tpl.replace('{' + token + '}', '<select class="' + k + ' ' + customClass + '"></select>');
          });

          return tpl;
        },

        /*
         Initialize combos that presents in template 
         */
        initCombos: function initCombos() {
          for (var k in this.map) {
            var c = this.$widget[0].querySelectorAll('.' + k);
            // set properties like this.$day, this.$month etc.
            this['$' + k] = c.length ? angular.element(c) : null;
            // fill with items
            this.fillCombo(k);
          }
        },

        /*
         Fill combo with items 
         */
        fillCombo: function fillCombo(k) {
          var $combo = this['$' + k];
          if (!$combo) {
            return;
          }

          // define method name to fill items, e.g `fillDays`
          var f = 'fill' + k.charAt(0).toUpperCase() + k.slice(1);
          var items = this[f]();
          var value = $combo.val();

          $combo.html('');
          for (var i = 0; i < items.length; i++) {
            $combo.append('<option value="' + items[i][0] + '">' + items[i][1] + '</option>');
          }

          $combo.val(value);
        },

        /*
         Initialize items of combos. Handles `firstItem` option 
         */
        fillCommon: function fillCommon(key) {
          var values = [],
              relTime;

          if (this.options.firstItem === 'name') {
            //need both to support moment ver < 2 and  >= 2
            relTime = moment.relativeTime || moment.langData()._relativeTime;
            var header = typeof relTime[key] === 'function' ? relTime[key](1, true, key, false) : relTime[key];
            //take last entry (see momentjs lang files structure) 
            header = header.split(' ').reverse()[0];
            values.push(['', header]);
          } else if (this.options.firstItem === 'empty') {
            values.push(['', '']);
          }
          return values;
        },

        /*
        fill day
        */
        fillDay: function fillDay() {
          var items = this.fillCommon('d'),
              name,
              i,
              twoDigit = this.options.template.indexOf('DD') !== -1,
              daysCount = 31;

          // detect days count (depends on month and year)
          // originally https://github.com/vitalets/combodate/pull/7
          if (this.options.smartDays && this.$month && this.$year) {
            var month = parseInt(this.$month.val(), 10);
            var year = parseInt(this.$year.val(), 10);

            if (!isNaN(month) && !isNaN(year)) {
              daysCount = moment([year, month]).daysInMonth();
            }
          }

          for (i = 1; i <= daysCount; i++) {
            name = twoDigit ? this.leadZero(i) : i;
            items.push([i, name]);
          }
          return items;
        },

        /*
        fill month
        */
        fillMonth: function fillMonth() {
          var items = this.fillCommon('M'),
              name,
              i,
              longNames = this.options.template.indexOf('MMMM') !== -1,
              shortNames = this.options.template.indexOf('MMM') !== -1,
              twoDigit = this.options.template.indexOf('MM') !== -1;

          for (i = 0; i <= 11; i++) {
            if (longNames) {
              //see https://github.com/timrwood/momentjs.com/pull/36
              name = moment().date(1).month(i).format('MMMM');
            } else if (shortNames) {
              name = moment().date(1).month(i).format('MMM');
            } else if (twoDigit) {
              name = this.leadZero(i + 1);
            } else {
              name = i + 1;
            }
            items.push([i, name]);
          }
          return items;
        },

        /*
        fill year
        */
        fillYear: function fillYear() {
          var items = [],
              name,
              i,
              longNames = this.options.template.indexOf('YYYY') !== -1;

          for (i = this.options.maxYear; i >= this.options.minYear; i--) {
            name = longNames ? i : (i + '').substring(2);
            items[this.options.yearDescending ? 'push' : 'unshift']([i, name]);
          }

          items = this.fillCommon('y').concat(items);

          return items;
        },

        /*
        fill hour
        */
        fillHour: function fillHour() {
          var items = this.fillCommon('h'),
              name,
              i,
              h12 = this.options.template.indexOf('h') !== -1,
              h24 = this.options.template.indexOf('H') !== -1,
              twoDigit = this.options.template.toLowerCase().indexOf('hh') !== -1,
              min = h12 ? 1 : 0,
              max = h12 ? 12 : 23;

          for (i = min; i <= max; i++) {
            name = twoDigit ? this.leadZero(i) : i;
            items.push([i, name]);
          }
          return items;
        },

        /*
        fill minute
        */
        fillMinute: function fillMinute() {
          var items = this.fillCommon('m'),
              name,
              i,
              twoDigit = this.options.template.indexOf('mm') !== -1;

          for (i = 0; i <= 59; i += this.options.minuteStep) {
            name = twoDigit ? this.leadZero(i) : i;
            items.push([i, name]);
          }
          return items;
        },

        /*
        fill second
        */
        fillSecond: function fillSecond() {
          var items = this.fillCommon('s'),
              name,
              i,
              twoDigit = this.options.template.indexOf('ss') !== -1;

          for (i = 0; i <= 59; i += this.options.secondStep) {
            name = twoDigit ? this.leadZero(i) : i;
            items.push([i, name]);
          }
          return items;
        },

        /*
        fill ampm
        */
        fillAmpm: function fillAmpm() {
          var ampmL = this.options.template.indexOf('a') !== -1,
              ampmU = this.options.template.indexOf('A') !== -1,
              items = [['am', ampmL ? 'am' : 'AM'], ['pm', ampmL ? 'pm' : 'PM']];
          return items;
        },

        /*
         Returns current date value from combos. 
         If format not specified - `options.format` used.
         If format = `null` - Moment object returned.
         */
        getValue: function getValue(format) {
          var dt,
              values = {},
              that = this,
              notSelected = false;

          //getting selected values    
          angular.forEach(this.map, function (v, k) {
            if (k === 'ampm') {
              return;
            }
            var def = k === 'day' ? 1 : 0;

            values[k] = that['$' + k] ? parseInt(that['$' + k].val(), 10) : def;

            if (isNaN(values[k])) {
              notSelected = true;
              return false;
            }
          });

          //if at least one visible combo not selected - return empty string
          if (notSelected) {
            return '';
          }

          //convert hours 12h --> 24h 
          if (this.$ampm) {
            //12:00 pm --> 12:00 (24-h format, midday), 12:00 am --> 00:00 (24-h format, midnight, start of day)
            if (values.hour === 12) {
              values.hour = this.$ampm.val() === 'am' ? 0 : 12;
            } else {
              values.hour = this.$ampm.val() === 'am' ? values.hour : values.hour + 12;
            }
          }

          dt = moment([values.year, values.month, values.day, values.hour, values.minute, values.second]);

          //highlight invalid date
          this.highlight(dt);

          format = format === undefined ? this.options.format : format;
          if (format === null) {
            return dt.isValid() ? dt : null;
          } else {
            return dt.isValid() ? dt.format(format) : '';
          }
        },

        setValue: function setValue(value) {
          if (!value) {
            return;
          }

          // parse in strict mode (third param `true`)
          var dt = typeof value === 'string' ? moment(value, this.options.format, true) : moment(value),
              that = this,
              values = {};

          //function to find nearest value in select options
          function getNearest($select, value) {
            var delta = {};
            angular.forEach($select.children('option'), function (opt, i) {
              var optValue = angular.element(opt).attr('value');

              if (optValue === '') return;
              var distance = Math.abs(optValue - value);
              if (typeof delta.distance === 'undefined' || distance < delta.distance) {
                delta = { value: optValue, distance: distance };
              }
            });
            return delta.value;
          }

          if (dt.isValid()) {
            //read values from date object
            angular.forEach(this.map, function (v, k) {
              if (k === 'ampm') {
                return;
              }
              values[k] = dt[v[1]]();
            });

            if (this.$ampm) {
              //12:00 pm --> 12:00 (24-h format, midday), 12:00 am --> 00:00 (24-h format, midnight, start of day)
              if (values.hour >= 12) {
                values.ampm = 'pm';
                if (values.hour > 12) {
                  values.hour -= 12;
                }
              } else {
                values.ampm = 'am';
                if (values.hour === 0) {
                  values.hour = 12;
                }
              }
            }

            angular.forEach(values, function (v, k) {
              //call val() for each existing combo, e.g. this.$hour.val()
              if (that['$' + k]) {

                if (k === 'minute' && that.options.minuteStep > 1 && that.options.roundTime) {
                  v = getNearest(that['$' + k], v);
                }

                if (k === 'second' && that.options.secondStep > 1 && that.options.roundTime) {
                  v = getNearest(that['$' + k], v);
                }

                that['$' + k].val(v);
              }
            });

            // update days count
            if (this.options.smartDays) {
              this.fillCombo('day');
            }

            this.$element.val(dt.format(this.options.format)).triggerHandler('change');
          }
        },

        /*
         highlight combos if date is invalid
         */
        highlight: function highlight(dt) {
          if (!dt.isValid()) {
            if (this.options.errorClass) {
              this.$widget.addClass(this.options.errorClass);
            } else {
              //store original border color
              if (!this.borderColor) {
                this.borderColor = this.$widget.find('select').css('border-color');
              }
              this.$widget.find('select').css('border-color', 'red');
            }
          } else {
            if (this.options.errorClass) {
              this.$widget.removeClass(this.options.errorClass);
            } else {
              this.$widget.find('select').css('border-color', this.borderColor);
            }
          }
        },

        leadZero: function leadZero(v) {
          return v <= 9 ? '0' + v : v;
        },

        destroy: function destroy() {
          this.$widget.remove();
          this.$element.removeData('combodate').show();
        }

      };

      return {
        getInstance: function getInstance(element, options) {
          return new Combodate(element, options);
        }
      };
    }]);

    /*
    Editable icons:
    - default
    - font-awesome
    
    */
    angular.module('xeditable').factory('editableIcons', function () {

      var icons = {
        //Icon-set to use, defaults to bootstrap icons
        default: {
          'bs2': {
            ok: 'icon-ok icon-white',
            cancel: 'icon-remove',
            clear: 'icon-trash'
          },
          'bs3': {
            ok: 'glyphicon glyphicon-ok',
            cancel: 'glyphicon glyphicon-remove',
            clear: 'glyphicon glyphicon-trash'
          }
        },
        external: {
          'font-awesome': {
            ok: 'fa fa-check',
            cancel: 'fa fa-times',
            clear: 'fa fa-trash'
          }
        }
      };

      return icons;
    });

    /* jshint -W086 */
    /*
    Editable themes:
    - default
    - bootstrap 2
    - bootstrap 3
    - semantic-ui
    
    Note: in postrender() `this` is instance of editableController
    */
    angular.module('xeditable').factory('editableThemes', function () {
      var themes = {
        //default
        'default': {
          formTpl: '<form class="editable-wrap"></form>',
          noformTpl: '<span class="editable-wrap"></span>',
          controlsTpl: '<span class="editable-controls"></span>',
          inputTpl: '',
          errorTpl: '<div class="editable-error" data-ng-if="$error" data-ng-bind="$error"></div>',
          buttonsTpl: '<span class="editable-buttons"></span>',
          submitTpl: '<button type="submit">save</button>',
          cancelTpl: '<button type="button" ng-click="$form.$cancel()">cancel</button>',
          resetTpl: '<button type="reset">clear</button>'
        },

        //bs2
        'bs2': {
          formTpl: '<form class="form-inline editable-wrap" role="form"></form>',
          noformTpl: '<span class="editable-wrap"></span>',
          controlsTpl: '<div class="editable-controls controls control-group" ng-class="{\'error\': $error}"></div>',
          inputTpl: '',
          errorTpl: '<div class="editable-error help-block" data-ng-if="$error" data-ng-bind="$error"></div>',
          buttonsTpl: '<span class="editable-buttons"></span>',
          submitTpl: '<button type="submit" class="btn btn-primary"><span></span></button>',
          cancelTpl: '<button type="button" class="btn" ng-click="$form.$cancel()">' + '<span></span>' + '</button>',
          resetTpl: '<button type="reset" class="btn btn-danger">clear</button>'

        },

        //bs3
        'bs3': {
          formTpl: '<form class="form-inline editable-wrap" role="form"></form>',
          noformTpl: '<span class="editable-wrap"></span>',
          controlsTpl: '<div class="editable-controls form-group" ng-class="{\'has-error\': $error}"></div>',
          inputTpl: '',
          errorTpl: '<div class="editable-error help-block" data-ng-if="$error" data-ng-bind="$error"></div>',
          buttonsTpl: '<span class="editable-buttons"></span>',
          submitTpl: '<button type="submit" class="btn btn-primary"><span></span></button>',
          cancelTpl: '<button type="button" class="btn btn-default" ng-click="$form.$cancel()">' + '<span></span>' + '</button>',
          resetTpl: '<button type="reset" class="btn btn-danger">clear</button>',

          //bs3 specific prop to change buttons class: btn-sm, btn-lg
          buttonsClass: '',
          //bs3 specific prop to change standard inputs class: input-sm, input-lg
          inputClass: '',
          postrender: function postrender() {
            //apply `form-control` class to std inputs
            switch (this.directiveName) {
              case 'editableText':
              case 'editableSelect':
              case 'editableTextarea':
              case 'editableEmail':
              case 'editableTel':
              case 'editableNumber':
              case 'editableUrl':
              case 'editableSearch':
              case 'editableDate':
              case 'editableDatetime':
              case 'editableBsdate':
              case 'editableTime':
              case 'editableMonth':
              case 'editableWeek':
              case 'editablePassword':
              case 'editableDatetimeLocal':
                this.inputEl.addClass('form-control');
                if (this.theme.inputClass) {
                  // don`t apply `input-sm` and `input-lg` to select multiple
                  // should be fixed in bs itself!
                  if (this.inputEl.attr('multiple') && (this.theme.inputClass === 'input-sm' || this.theme.inputClass === 'input-lg')) {
                    break;
                  }
                  this.inputEl.addClass(this.theme.inputClass);
                }
                break;
              case 'editableCheckbox':
                this.editorEl.addClass('checkbox');
            }

            //apply buttonsClass (bs3 specific!)
            if (this.buttonsEl && this.theme.buttonsClass) {
              this.buttonsEl.find('button').addClass(this.theme.buttonsClass);
            }
          }
        },

        //semantic-ui
        'semantic': {
          formTpl: '<form class="editable-wrap ui form" ng-class="{\'error\': $error}" role="form"></form>',
          noformTpl: '<span class="editable-wrap"></span>',
          controlsTpl: '<div class="editable-controls ui fluid input" ng-class="{\'error\': $error}"></div>',
          inputTpl: '',
          errorTpl: '<div class="editable-error ui error message" data-ng-if="$error" data-ng-bind="$error"></div>',
          buttonsTpl: '<span class="mini ui buttons"></span>',
          submitTpl: '<button type="submit" class="ui primary button"><i class="ui check icon"></i></button>',
          cancelTpl: '<button type="button" class="ui button" ng-click="$form.$cancel()">' + '<i class="ui cancel icon"></i>' + '</button>',
          resetTpl: '<button type="reset" class="ui button">clear</button>'
        }
      };

      return themes;
    });
  }, {}], 5: [function (require, module, exports) {
    (function (window) {
      var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
      };

      function sprintf() {
        var key = arguments[0],
            cache = sprintf.cache;
        if (!(cache[key] && cache.hasOwnProperty(key))) {
          cache[key] = sprintf.parse(key);
        }
        return sprintf.format.call(null, cache[key], arguments);
      }

      sprintf.format = function (parse_tree, argv) {
        var cursor = 1,
            tree_length = parse_tree.length,
            node_type = "",
            arg,
            output = [],
            i,
            k,
            match,
            pad,
            pad_character,
            pad_length,
            is_positive = true,
            sign = "";
        for (i = 0; i < tree_length; i++) {
          node_type = get_type(parse_tree[i]);
          if (node_type === "string") {
            output[output.length] = parse_tree[i];
          } else if (node_type === "array") {
            match = parse_tree[i]; // convenience purposes only
            if (match[2]) {
              // keyword argument
              arg = argv[cursor];
              for (k = 0; k < match[2].length; k++) {
                if (!arg.hasOwnProperty(match[2][k])) {
                  throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]));
                }
                arg = arg[match[2][k]];
              }
            } else if (match[1]) {
              // positional argument (explicit)
              arg = argv[match[1]];
            } else {
              // positional argument (implicit)
              arg = argv[cursor++];
            }

            if (get_type(arg) == "function") {
              arg = arg();
            }

            if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && get_type(arg) != "number" && isNaN(arg)) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)));
            }

            if (re.number.test(match[8])) {
              is_positive = arg >= 0;
            }

            switch (match[8]) {
              case "b":
                arg = arg.toString(2);
                break;
              case "c":
                arg = String.fromCharCode(arg);
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0);
                break;
              case "e":
                arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
                break;
              case "f":
                arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                break;
              case "g":
                arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg);
                break;
              case "o":
                arg = arg.toString(8);
                break;
              case "s":
                arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;
                break;
              case "u":
                arg = arg >>> 0;
                break;
              case "x":
                arg = arg.toString(16);
                break;
              case "X":
                arg = arg.toString(16).toUpperCase();
                break;
            }
            if (re.json.test(match[8])) {
              output[output.length] = arg;
            } else {
              if (re.number.test(match[8]) && (!is_positive || match[3])) {
                sign = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign = "";
              }
              pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " ";
              pad_length = match[6] - (sign + arg).length;
              pad = match[6] ? pad_length > 0 ? str_repeat(pad_character, pad_length) : "" : "";
              output[output.length] = match[5] ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
            }
          }
        }
        return output.join("");
      };

      sprintf.cache = {};

      sprintf.parse = function (fmt) {
        var _fmt = fmt,
            match = [],
            parse_tree = [],
            arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree[parse_tree.length] = match[0];
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree[parse_tree.length] = "%";
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [],
                  replacement_field = match[2],
                  field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list[field_list.length] = field_match[1];
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list[field_list.length] = field_match[1];
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list[field_list.length] = field_match[1];
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree[parse_tree.length] = match;
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return parse_tree;
      };

      var vsprintf = function vsprintf(fmt, argv, _argv) {
        _argv = (argv || []).slice(0);
        _argv.splice(0, 0, fmt);
        return sprintf.apply(null, _argv);
      };

      /**
       * helpers
       */
      function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
      }

      function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input);
      }

      /**
       * export to either browser or node.js
       */
      if (typeof exports !== "undefined") {
        exports.sprintf = sprintf;
        exports.vsprintf = vsprintf;
      } else {
        window.sprintf = sprintf;
        window.vsprintf = vsprintf;

        if (typeof define === "function" && define.amd) {
          define(function () {
            return {
              sprintf: sprintf,
              vsprintf: vsprintf
            };
          });
        }
      }
    })(typeof window === "undefined" ? this : window);
  }, {}], 6: [function (require, module, exports) {
    /*
     * angular-ui-bootstrap
     * http://angular-ui.github.io/bootstrap/
    
     * Version: 2.2.0 - 2016-10-10
     * License: MIT
     */angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.tabindex", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.datepicker", "ui.bootstrap.position", "ui.bootstrap.datepickerPopup", "ui.bootstrap.debounce", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
    angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/year.html", "uib/template/datepickerPopup/popup.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html"]);
    angular.module('ui.bootstrap.collapse', []).directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function ($animate, $q, $parse, $injector) {
      var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
      return {
        link: function link(scope, element, attrs) {
          var expandingExpr = $parse(attrs.expanding),
              expandedExpr = $parse(attrs.expanded),
              collapsingExpr = $parse(attrs.collapsing),
              collapsedExpr = $parse(attrs.collapsed),
              horizontal = false,
              css = {},
              cssTo = {};

          init();

          function init() {
            horizontal = !!('horizontal' in attrs);
            if (horizontal) {
              css = {
                width: ''
              };
              cssTo = { width: '0' };
            } else {
              css = {
                height: ''
              };
              cssTo = { height: '0' };
            }
            if (!scope.$eval(attrs.uibCollapse)) {
              element.addClass('in').addClass('collapse').attr('aria-expanded', true).attr('aria-hidden', false).css(css);
            }
          }

          function getScrollFromElement(element) {
            if (horizontal) {
              return { width: element.scrollWidth + 'px' };
            }
            return { height: element.scrollHeight + 'px' };
          }

          function expand() {
            if (element.hasClass('collapse') && element.hasClass('in')) {
              return;
            }

            $q.resolve(expandingExpr(scope)).then(function () {
              element.removeClass('collapse').addClass('collapsing').attr('aria-expanded', true).attr('aria-hidden', false);

              if ($animateCss) {
                $animateCss(element, {
                  addClass: 'in',
                  easing: 'ease',
                  css: {
                    overflow: 'hidden'
                  },
                  to: getScrollFromElement(element[0])
                }).start()['finally'](expandDone);
              } else {
                $animate.addClass(element, 'in', {
                  css: {
                    overflow: 'hidden'
                  },
                  to: getScrollFromElement(element[0])
                }).then(expandDone);
              }
            });
          }

          function expandDone() {
            element.removeClass('collapsing').addClass('collapse').css(css);
            expandedExpr(scope);
          }

          function collapse() {
            if (!element.hasClass('collapse') && !element.hasClass('in')) {
              return collapseDone();
            }

            $q.resolve(collapsingExpr(scope)).then(function () {
              element
              // IMPORTANT: The width must be set before adding "collapsing" class.
              // Otherwise, the browser attempts to animate from width 0 (in
              // collapsing class) to the given width here.
              .css(getScrollFromElement(element[0]))
              // initially all panel collapse have the collapse class, this removal
              // prevents the animation from jumping to collapsed state
              .removeClass('collapse').addClass('collapsing').attr('aria-expanded', false).attr('aria-hidden', true);

              if ($animateCss) {
                $animateCss(element, {
                  removeClass: 'in',
                  to: cssTo
                }).start()['finally'](collapseDone);
              } else {
                $animate.removeClass(element, 'in', {
                  to: cssTo
                }).then(collapseDone);
              }
            });
          }

          function collapseDone() {
            element.css(cssTo); // Required so that collapse works when animation is disabled
            element.removeClass('collapsing').addClass('collapse');
            collapsedExpr(scope);
          }

          scope.$watch(attrs.uibCollapse, function (shouldCollapse) {
            if (shouldCollapse) {
              collapse();
            } else {
              expand();
            }
          });
        }
      };
    }]);

    angular.module('ui.bootstrap.tabindex', []).directive('uibTabindexToggle', function () {
      return {
        restrict: 'A',
        link: function link(scope, elem, attrs) {
          attrs.$observe('disabled', function (disabled) {
            attrs.$set('tabindex', disabled ? -1 : null);
          });
        }
      };
    });

    angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex']).constant('uibAccordionConfig', {
      closeOthers: true
    }).controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function ($scope, $attrs, accordionConfig) {
      // This array keeps track of the accordion groups
      this.groups = [];

      // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
      this.closeOthers = function (openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        if (closeOthers) {
          angular.forEach(this.groups, function (group) {
            if (group !== openGroup) {
              group.isOpen = false;
            }
          });
        }
      };

      // This is called from the accordion-group directive to add itself to the accordion
      this.addGroup = function (groupScope) {
        var that = this;
        this.groups.push(groupScope);

        groupScope.$on('$destroy', function (event) {
          that.removeGroup(groupScope);
        });
      };

      // This is called from the accordion-group directive when to remove itself
      this.removeGroup = function (group) {
        var index = this.groups.indexOf(group);
        if (index !== -1) {
          this.groups.splice(index, 1);
        }
      };
    }])

    // The accordion directive simply sets up the directive controller
    // and adds an accordion CSS class to itself element.
    .directive('uibAccordion', function () {
      return {
        controller: 'UibAccordionController',
        controllerAs: 'accordion',
        transclude: true,
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/accordion/accordion.html';
        }
      };
    })

    // The accordion-group directive indicates a block of html that will expand and collapse in an accordion
    .directive('uibAccordionGroup', function () {
      return {
        require: '^uibAccordion', // We need this directive to be inside an accordion
        transclude: true, // It transcludes the contents of the directive into the template
        restrict: 'A',
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
        },
        scope: {
          heading: '@', // Interpolate the heading attribute onto this scope
          panelClass: '@?', // Ditto with panelClass
          isOpen: '=?',
          isDisabled: '=?'
        },
        controller: function controller() {
          this.setHeading = function (element) {
            this.heading = element;
          };
        },
        link: function link(scope, element, attrs, accordionCtrl) {
          element.addClass('panel');
          accordionCtrl.addGroup(scope);

          scope.openClass = attrs.openClass || 'panel-open';
          scope.panelClass = attrs.panelClass || 'panel-default';
          scope.$watch('isOpen', function (value) {
            element.toggleClass(scope.openClass, !!value);
            if (value) {
              accordionCtrl.closeOthers(scope);
            }
          });

          scope.toggleOpen = function ($event) {
            if (!scope.isDisabled) {
              if (!$event || $event.which === 32) {
                scope.isOpen = !scope.isOpen;
              }
            }
          };

          var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
          scope.headingId = id + '-tab';
          scope.panelId = id + '-panel';
        }
      };
    })

    // Use accordion-heading below an accordion-group to provide a heading containing HTML
    .directive('uibAccordionHeading', function () {
      return {
        transclude: true, // Grab the contents to be used as the heading
        template: '', // In effect remove this element!
        replace: true,
        require: '^uibAccordionGroup',
        link: function link(scope, element, attrs, accordionGroupCtrl, transclude) {
          // Pass the heading to the accordion-group controller
          // so that it can be transcluded into the right place in the template
          // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
          accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
      };
    })

    // Use in the accordion-group template to indicate where you want the heading to be transcluded
    // You must provide the property on the accordion-group controller that will hold the transcluded element
    .directive('uibAccordionTransclude', function () {
      return {
        require: '^uibAccordionGroup',
        link: function link(scope, element, attrs, controller) {
          scope.$watch(function () {
            return controller[attrs.uibAccordionTransclude];
          }, function (heading) {
            if (heading) {
              var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
              elem.html('');
              elem.append(heading);
            }
          });
        }
      };

      function getHeaderSelectors() {
        return 'uib-accordion-header,' + 'data-uib-accordion-header,' + 'x-uib-accordion-header,' + 'uib\\:accordion-header,' + '[uib-accordion-header],' + '[data-uib-accordion-header],' + '[x-uib-accordion-header]';
      }
    });

    angular.module('ui.bootstrap.alert', []).controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function ($scope, $element, $attrs, $interpolate, $timeout) {
      $scope.closeable = !!$attrs.close;
      $element.addClass('alert');
      $attrs.$set('role', 'alert');
      if ($scope.closeable) {
        $element.addClass('alert-dismissible');
      }

      var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ? $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;

      if (dismissOnTimeout) {
        $timeout(function () {
          $scope.close();
        }, parseInt(dismissOnTimeout, 10));
      }
    }]).directive('uibAlert', function () {
      return {
        controller: 'UibAlertController',
        controllerAs: 'alert',
        restrict: 'A',
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/alert/alert.html';
        },
        transclude: true,
        scope: {
          close: '&'
        }
      };
    });

    angular.module('ui.bootstrap.buttons', []).constant('uibButtonConfig', {
      activeClass: 'active',
      toggleEvent: 'click'
    }).controller('UibButtonsController', ['uibButtonConfig', function (buttonConfig) {
      this.activeClass = buttonConfig.activeClass || 'active';
      this.toggleEvent = buttonConfig.toggleEvent || 'click';
    }]).directive('uibBtnRadio', ['$parse', function ($parse) {
      return {
        require: ['uibBtnRadio', 'ngModel'],
        controller: 'UibButtonsController',
        controllerAs: 'buttons',
        link: function link(scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          var uncheckableExpr = $parse(attrs.uibUncheckable);

          element.find('input').css({ display: 'none' });

          //model -> UI
          ngModelCtrl.$render = function () {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
          };

          //ui->model
          element.on(buttonsCtrl.toggleEvent, function () {
            if (attrs.disabled) {
              return;
            }

            var isActive = element.hasClass(buttonsCtrl.activeClass);

            if (!isActive || angular.isDefined(attrs.uncheckable)) {
              scope.$apply(function () {
                ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
                ngModelCtrl.$render();
              });
            }
          });

          if (attrs.uibUncheckable) {
            scope.$watch(uncheckableExpr, function (uncheckable) {
              attrs.$set('uncheckable', uncheckable ? '' : undefined);
            });
          }
        }
      };
    }]).directive('uibBtnCheckbox', function () {
      return {
        require: ['uibBtnCheckbox', 'ngModel'],
        controller: 'UibButtonsController',
        controllerAs: 'button',
        link: function link(scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];

          element.find('input').css({ display: 'none' });

          function getTrueValue() {
            return getCheckboxValue(attrs.btnCheckboxTrue, true);
          }

          function getFalseValue() {
            return getCheckboxValue(attrs.btnCheckboxFalse, false);
          }

          function getCheckboxValue(attribute, defaultValue) {
            return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
          }

          //model -> UI
          ngModelCtrl.$render = function () {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
          };

          //ui->model
          element.on(buttonsCtrl.toggleEvent, function () {
            if (attrs.disabled) {
              return;
            }

            scope.$apply(function () {
              ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
              ngModelCtrl.$render();
            });
          });
        }
      };
    });

    angular.module('ui.bootstrap.carousel', []).controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function ($scope, $element, $interval, $timeout, $animate) {
      var self = this,
          slides = self.slides = $scope.slides = [],
          SLIDE_DIRECTION = 'uib-slideDirection',
          currentIndex = $scope.active,
          currentInterval,
          isPlaying,
          bufferedTransitions = [];

      var destroyed = false;
      $element.addClass('carousel');

      self.addSlide = function (slide, element) {
        slides.push({
          slide: slide,
          element: element
        });
        slides.sort(function (a, b) {
          return +a.slide.index - +b.slide.index;
        });
        //if this is the first slide or the slide is set to active, select it
        if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
          if ($scope.$currentTransition) {
            $scope.$currentTransition = null;
          }

          currentIndex = slide.index;
          $scope.active = slide.index;
          setActive(currentIndex);
          self.select(slides[findSlideIndex(slide)]);
          if (slides.length === 1) {
            $scope.play();
          }
        }
      };

      self.getCurrentIndex = function () {
        for (var i = 0; i < slides.length; i++) {
          if (slides[i].slide.index === currentIndex) {
            return i;
          }
        }
      };

      self.next = $scope.next = function () {
        var newIndex = (self.getCurrentIndex() + 1) % slides.length;

        if (newIndex === 0 && $scope.noWrap()) {
          $scope.pause();
          return;
        }

        return self.select(slides[newIndex], 'next');
      };

      self.prev = $scope.prev = function () {
        var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

        if ($scope.noWrap() && newIndex === slides.length - 1) {
          $scope.pause();
          return;
        }

        return self.select(slides[newIndex], 'prev');
      };

      self.removeSlide = function (slide) {
        var index = findSlideIndex(slide);

        var bufferedIndex = bufferedTransitions.indexOf(slides[index]);
        if (bufferedIndex !== -1) {
          bufferedTransitions.splice(bufferedIndex, 1);
        }

        //get the index of the slide inside the carousel
        slides.splice(index, 1);
        if (slides.length > 0 && currentIndex === index) {
          if (index >= slides.length) {
            currentIndex = slides.length - 1;
            $scope.active = currentIndex;
            setActive(currentIndex);
            self.select(slides[slides.length - 1]);
          } else {
            currentIndex = index;
            $scope.active = currentIndex;
            setActive(currentIndex);
            self.select(slides[index]);
          }
        } else if (currentIndex > index) {
          currentIndex--;
          $scope.active = currentIndex;
        }

        //clean the active value when no more slide
        if (slides.length === 0) {
          currentIndex = null;
          $scope.active = null;
          clearBufferedTransitions();
        }
      };

      /* direction: "prev" or "next" */
      self.select = $scope.select = function (nextSlide, direction) {
        var nextIndex = findSlideIndex(nextSlide.slide);
        //Decide direction if it's not given
        if (direction === undefined) {
          direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
        }
        //Prevent this user-triggered transition from occurring if there is already one in progress
        if (nextSlide.slide.index !== currentIndex && !$scope.$currentTransition) {
          goNext(nextSlide.slide, nextIndex, direction);
        } else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {
          bufferedTransitions.push(slides[nextIndex]);
        }
      };

      /* Allow outside people to call indexOf on slides array */
      $scope.indexOfSlide = function (slide) {
        return +slide.slide.index;
      };

      $scope.isActive = function (slide) {
        return $scope.active === slide.slide.index;
      };

      $scope.isPrevDisabled = function () {
        return $scope.active === 0 && $scope.noWrap();
      };

      $scope.isNextDisabled = function () {
        return $scope.active === slides.length - 1 && $scope.noWrap();
      };

      $scope.pause = function () {
        if (!$scope.noPause) {
          isPlaying = false;
          resetTimer();
        }
      };

      $scope.play = function () {
        if (!isPlaying) {
          isPlaying = true;
          restartTimer();
        }
      };

      $element.on('mouseenter', $scope.pause);
      $element.on('mouseleave', $scope.play);

      $scope.$on('$destroy', function () {
        destroyed = true;
        resetTimer();
      });

      $scope.$watch('noTransition', function (noTransition) {
        $animate.enabled($element, !noTransition);
      });

      $scope.$watch('interval', restartTimer);

      $scope.$watchCollection('slides', resetTransition);

      $scope.$watch('active', function (index) {
        if (angular.isNumber(index) && currentIndex !== index) {
          for (var i = 0; i < slides.length; i++) {
            if (slides[i].slide.index === index) {
              index = i;
              break;
            }
          }

          var slide = slides[index];
          if (slide) {
            setActive(index);
            self.select(slides[index]);
            currentIndex = index;
          }
        }
      });

      function clearBufferedTransitions() {
        while (bufferedTransitions.length) {
          bufferedTransitions.shift();
        }
      }

      function getSlideByIndex(index) {
        for (var i = 0, l = slides.length; i < l; ++i) {
          if (slides[i].index === index) {
            return slides[i];
          }
        }
      }

      function setActive(index) {
        for (var i = 0; i < slides.length; i++) {
          slides[i].slide.active = i === index;
        }
      }

      function goNext(slide, index, direction) {
        if (destroyed) {
          return;
        }

        angular.extend(slide, { direction: direction });
        angular.extend(slides[currentIndex].slide || {}, { direction: direction });
        if ($animate.enabled($element) && !$scope.$currentTransition && slides[index].element && self.slides.length > 1) {
          slides[index].element.data(SLIDE_DIRECTION, slide.direction);
          var currentIdx = self.getCurrentIndex();

          if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
            slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
          }

          $scope.$currentTransition = true;
          $animate.on('addClass', slides[index].element, function (element, phase) {
            if (phase === 'close') {
              $scope.$currentTransition = null;
              $animate.off('addClass', element);
              if (bufferedTransitions.length) {
                var nextSlide = bufferedTransitions.pop().slide;
                var nextIndex = nextSlide.index;
                var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
                clearBufferedTransitions();

                goNext(nextSlide, nextIndex, nextDirection);
              }
            }
          });
        }

        $scope.active = slide.index;
        currentIndex = slide.index;
        setActive(index);

        //every time you change slides, reset the timer
        restartTimer();
      }

      function findSlideIndex(slide) {
        for (var i = 0; i < slides.length; i++) {
          if (slides[i].slide === slide) {
            return i;
          }
        }
      }

      function resetTimer() {
        if (currentInterval) {
          $interval.cancel(currentInterval);
          currentInterval = null;
        }
      }

      function resetTransition(slides) {
        if (!slides.length) {
          $scope.$currentTransition = null;
          clearBufferedTransitions();
        }
      }

      function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        if (!isNaN(interval) && interval > 0) {
          currentInterval = $interval(timerFn, interval);
        }
      }

      function timerFn() {
        var interval = +$scope.interval;
        if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
          $scope.next();
        } else {
          $scope.pause();
        }
      }
    }]).directive('uibCarousel', function () {
      return {
        transclude: true,
        controller: 'UibCarouselController',
        controllerAs: 'carousel',
        restrict: 'A',
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/carousel/carousel.html';
        },
        scope: {
          active: '=',
          interval: '=',
          noTransition: '=',
          noPause: '=',
          noWrap: '&'
        }
      };
    }).directive('uibSlide', ['$animate', function ($animate) {
      return {
        require: '^uibCarousel',
        restrict: 'A',
        transclude: true,
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/carousel/slide.html';
        },
        scope: {
          actual: '=?',
          index: '=?'
        },
        link: function link(scope, element, attrs, carouselCtrl) {
          element.addClass('item');
          carouselCtrl.addSlide(scope, element);
          //when the scope is destroyed then remove the slide from the current slides array
          scope.$on('$destroy', function () {
            carouselCtrl.removeSlide(scope);
          });

          scope.$watch('active', function (active) {
            $animate[active ? 'addClass' : 'removeClass'](element, 'active');
          });
        }
      };
    }]).animation('.item', ['$animateCss', function ($animateCss) {
      var SLIDE_DIRECTION = 'uib-slideDirection';

      function removeClass(element, className, callback) {
        element.removeClass(className);
        if (callback) {
          callback();
        }
      }

      return {
        beforeAddClass: function beforeAddClass(element, className, done) {
          if (className === 'active') {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction === 'next' ? 'left' : 'right';
            var removeClassFn = removeClass.bind(this, element, directionClass + ' ' + direction, done);
            element.addClass(direction);

            $animateCss(element, { addClass: directionClass }).start().done(removeClassFn);

            return function () {
              stopped = true;
            };
          }
          done();
        },
        beforeRemoveClass: function beforeRemoveClass(element, className, done) {
          if (className === 'active') {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction === 'next' ? 'left' : 'right';
            var removeClassFn = removeClass.bind(this, element, directionClass, done);

            $animateCss(element, { addClass: directionClass }).start().done(removeClassFn);

            return function () {
              stopped = true;
            };
          }
          done();
        }
      };
    }]);

    angular.module('ui.bootstrap.dateparser', []).service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function ($log, $locale, dateFilter, orderByFilter) {
      // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
      var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

      var localeId;
      var formatCodeToRegex;

      this.init = function () {
        localeId = $locale.id;

        this.parsers = {};
        this.formatters = {};

        formatCodeToRegex = [{
          key: 'yyyy',
          regex: '\\d{4}',
          apply: function apply(value) {
            this.year = +value;
          },
          formatter: function formatter(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'yyyy');
          }
        }, {
          key: 'yy',
          regex: '\\d{2}',
          apply: function apply(value) {
            value = +value;this.year = value < 69 ? value + 2000 : value + 1900;
          },
          formatter: function formatter(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'yy');
          }
        }, {
          key: 'y',
          regex: '\\d{1,4}',
          apply: function apply(value) {
            this.year = +value;
          },
          formatter: function formatter(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'y');
          }
        }, {
          key: 'M!',
          regex: '0?[1-9]|1[0-2]',
          apply: function apply(value) {
            this.month = value - 1;
          },
          formatter: function formatter(date) {
            var value = date.getMonth();
            if (/^[0-9]$/.test(value)) {
              return dateFilter(date, 'MM');
            }

            return dateFilter(date, 'M');
          }
        }, {
          key: 'MMMM',
          regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
          apply: function apply(value) {
            this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'MMMM');
          }
        }, {
          key: 'MMM',
          regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
          apply: function apply(value) {
            this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'MMM');
          }
        }, {
          key: 'MM',
          regex: '0[1-9]|1[0-2]',
          apply: function apply(value) {
            this.month = value - 1;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'MM');
          }
        }, {
          key: 'M',
          regex: '[1-9]|1[0-2]',
          apply: function apply(value) {
            this.month = value - 1;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'M');
          }
        }, {
          key: 'd!',
          regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
          apply: function apply(value) {
            this.date = +value;
          },
          formatter: function formatter(date) {
            var value = date.getDate();
            if (/^[1-9]$/.test(value)) {
              return dateFilter(date, 'dd');
            }

            return dateFilter(date, 'd');
          }
        }, {
          key: 'dd',
          regex: '[0-2][0-9]{1}|3[0-1]{1}',
          apply: function apply(value) {
            this.date = +value;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'dd');
          }
        }, {
          key: 'd',
          regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
          apply: function apply(value) {
            this.date = +value;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'd');
          }
        }, {
          key: 'EEEE',
          regex: $locale.DATETIME_FORMATS.DAY.join('|'),
          formatter: function formatter(date) {
            return dateFilter(date, 'EEEE');
          }
        }, {
          key: 'EEE',
          regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
          formatter: function formatter(date) {
            return dateFilter(date, 'EEE');
          }
        }, {
          key: 'HH',
          regex: '(?:0|1)[0-9]|2[0-3]',
          apply: function apply(value) {
            this.hours = +value;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'HH');
          }
        }, {
          key: 'hh',
          regex: '0[0-9]|1[0-2]',
          apply: function apply(value) {
            this.hours = +value;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'hh');
          }
        }, {
          key: 'H',
          regex: '1?[0-9]|2[0-3]',
          apply: function apply(value) {
            this.hours = +value;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'H');
          }
        }, {
          key: 'h',
          regex: '[0-9]|1[0-2]',
          apply: function apply(value) {
            this.hours = +value;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'h');
          }
        }, {
          key: 'mm',
          regex: '[0-5][0-9]',
          apply: function apply(value) {
            this.minutes = +value;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'mm');
          }
        }, {
          key: 'm',
          regex: '[0-9]|[1-5][0-9]',
          apply: function apply(value) {
            this.minutes = +value;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'm');
          }
        }, {
          key: 'sss',
          regex: '[0-9][0-9][0-9]',
          apply: function apply(value) {
            this.milliseconds = +value;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'sss');
          }
        }, {
          key: 'ss',
          regex: '[0-5][0-9]',
          apply: function apply(value) {
            this.seconds = +value;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'ss');
          }
        }, {
          key: 's',
          regex: '[0-9]|[1-5][0-9]',
          apply: function apply(value) {
            this.seconds = +value;
          },
          formatter: function formatter(date) {
            return dateFilter(date, 's');
          }
        }, {
          key: 'a',
          regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
          apply: function apply(value) {
            if (this.hours === 12) {
              this.hours = 0;
            }

            if (value === 'PM') {
              this.hours += 12;
            }
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'a');
          }
        }, {
          key: 'Z',
          regex: '[+-]\\d{4}',
          apply: function apply(value) {
            var matches = value.match(/([+-])(\d{2})(\d{2})/),
                sign = matches[1],
                hours = matches[2],
                minutes = matches[3];
            this.hours += toInt(sign + hours);
            this.minutes += toInt(sign + minutes);
          },
          formatter: function formatter(date) {
            return dateFilter(date, 'Z');
          }
        }, {
          key: 'ww',
          regex: '[0-4][0-9]|5[0-3]',
          formatter: function formatter(date) {
            return dateFilter(date, 'ww');
          }
        }, {
          key: 'w',
          regex: '[0-9]|[1-4][0-9]|5[0-3]',
          formatter: function formatter(date) {
            return dateFilter(date, 'w');
          }
        }, {
          key: 'GGGG',
          regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
          formatter: function formatter(date) {
            return dateFilter(date, 'GGGG');
          }
        }, {
          key: 'GGG',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function formatter(date) {
            return dateFilter(date, 'GGG');
          }
        }, {
          key: 'GG',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function formatter(date) {
            return dateFilter(date, 'GG');
          }
        }, {
          key: 'G',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function formatter(date) {
            return dateFilter(date, 'G');
          }
        }];
      };

      this.init();

      function createParser(format) {
        var map = [],
            regex = format.split('');

        // check for literal values
        var quoteIndex = format.indexOf('\'');
        if (quoteIndex > -1) {
          var inLiteral = false;
          format = format.split('');
          for (var i = quoteIndex; i < format.length; i++) {
            if (inLiteral) {
              if (format[i] === '\'') {
                if (i + 1 < format.length && format[i + 1] === '\'') {
                  // escaped single quote
                  format[i + 1] = '$';
                  regex[i + 1] = '';
                } else {
                  // end of literal
                  regex[i] = '';
                  inLiteral = false;
                }
              }
              format[i] = '$';
            } else {
              if (format[i] === '\'') {
                // start of literal
                format[i] = '$';
                regex[i] = '';
                inLiteral = true;
              }
            }
          }

          format = format.join('');
        }

        angular.forEach(formatCodeToRegex, function (data) {
          var index = format.indexOf(data.key);

          if (index > -1) {
            format = format.split('');

            regex[index] = '(' + data.regex + ')';
            format[index] = '$'; // Custom symbol to define consumed part of format
            for (var i = index + 1, n = index + data.key.length; i < n; i++) {
              regex[i] = '';
              format[i] = '$';
            }
            format = format.join('');

            map.push({
              index: index,
              key: data.key,
              apply: data.apply,
              matcher: data.regex
            });
          }
        });

        return {
          regex: new RegExp('^' + regex.join('') + '$'),
          map: orderByFilter(map, 'index')
        };
      }

      function createFormatter(format) {
        var formatters = [];
        var i = 0;
        var formatter, literalIdx;
        while (i < format.length) {
          if (angular.isNumber(literalIdx)) {
            if (format.charAt(i) === '\'') {
              if (i + 1 >= format.length || format.charAt(i + 1) !== '\'') {
                formatters.push(constructLiteralFormatter(format, literalIdx, i));
                literalIdx = null;
              }
            } else if (i === format.length) {
              while (literalIdx < format.length) {
                formatter = constructFormatterFromIdx(format, literalIdx);
                formatters.push(formatter);
                literalIdx = formatter.endIdx;
              }
            }

            i++;
            continue;
          }

          if (format.charAt(i) === '\'') {
            literalIdx = i;
            i++;
            continue;
          }

          formatter = constructFormatterFromIdx(format, i);

          formatters.push(formatter.parser);
          i = formatter.endIdx;
        }

        return formatters;
      }

      function constructLiteralFormatter(format, literalIdx, endIdx) {
        return function () {
          return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
        };
      }

      function constructFormatterFromIdx(format, i) {
        var currentPosStr = format.substr(i);
        for (var j = 0; j < formatCodeToRegex.length; j++) {
          if (new RegExp('^' + formatCodeToRegex[j].key).test(currentPosStr)) {
            var data = formatCodeToRegex[j];
            return {
              endIdx: i + data.key.length,
              parser: data.formatter
            };
          }
        }

        return {
          endIdx: i + 1,
          parser: function parser() {
            return currentPosStr.charAt(0);
          }
        };
      }

      this.filter = function (date, format) {
        if (!angular.isDate(date) || isNaN(date) || !format) {
          return '';
        }

        format = $locale.DATETIME_FORMATS[format] || format;

        if ($locale.id !== localeId) {
          this.init();
        }

        if (!this.formatters[format]) {
          this.formatters[format] = createFormatter(format);
        }

        var formatters = this.formatters[format];

        return formatters.reduce(function (str, formatter) {
          return str + formatter(date);
        }, '');
      };

      this.parse = function (input, format, baseDate) {
        if (!angular.isString(input) || !format) {
          return input;
        }

        format = $locale.DATETIME_FORMATS[format] || format;
        format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

        if ($locale.id !== localeId) {
          this.init();
        }

        if (!this.parsers[format]) {
          this.parsers[format] = createParser(format, 'apply');
        }

        var parser = this.parsers[format],
            regex = parser.regex,
            map = parser.map,
            results = input.match(regex),
            tzOffset = false;
        if (results && results.length) {
          var fields, dt;
          if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
            fields = {
              year: baseDate.getFullYear(),
              month: baseDate.getMonth(),
              date: baseDate.getDate(),
              hours: baseDate.getHours(),
              minutes: baseDate.getMinutes(),
              seconds: baseDate.getSeconds(),
              milliseconds: baseDate.getMilliseconds()
            };
          } else {
            if (baseDate) {
              $log.warn('dateparser:', 'baseDate is not a valid date');
            }
            fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
          }

          for (var i = 1, n = results.length; i < n; i++) {
            var mapper = map[i - 1];
            if (mapper.matcher === 'Z') {
              tzOffset = true;
            }

            if (mapper.apply) {
              mapper.apply.call(fields, results[i]);
            }
          }

          var datesetter = tzOffset ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear;
          var timesetter = tzOffset ? Date.prototype.setUTCHours : Date.prototype.setHours;

          if (isValid(fields.year, fields.month, fields.date)) {
            if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
              dt = new Date(baseDate);
              datesetter.call(dt, fields.year, fields.month, fields.date);
              timesetter.call(dt, fields.hours, fields.minutes, fields.seconds, fields.milliseconds);
            } else {
              dt = new Date(0);
              datesetter.call(dt, fields.year, fields.month, fields.date);
              timesetter.call(dt, fields.hours || 0, fields.minutes || 0, fields.seconds || 0, fields.milliseconds || 0);
            }
          }

          return dt;
        }
      };

      // Check if date is valid for specific month (and year for February).
      // Month: 0 = Jan, 1 = Feb, etc
      function isValid(year, month, date) {
        if (date < 1) {
          return false;
        }

        if (month === 1 && date > 28) {
          return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
        }

        if (month === 3 || month === 5 || month === 8 || month === 10) {
          return date < 31;
        }

        return true;
      }

      function toInt(str) {
        return parseInt(str, 10);
      }

      this.toTimezone = toTimezone;
      this.fromTimezone = fromTimezone;
      this.timezoneToOffset = timezoneToOffset;
      this.addDateMinutes = addDateMinutes;
      this.convertTimezoneToLocal = convertTimezoneToLocal;

      function toTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
      }

      function fromTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
      }

      //https://github.com/angular/angular.js/blob/622c42169699ec07fc6daaa19fe6d224e5d2f70e/src/Angular.js#L1207
      function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(/:/g, '');
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }

      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }

      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
      }
    }]);

    // Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to
    // at most one element.
    angular.module('ui.bootstrap.isClass', []).directive('uibIsClass', ['$animate', function ($animate) {
      //                    11111111          22222222
      var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
      //                    11111111           22222222
      var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;

      var dataPerTracked = {};

      return {
        restrict: 'A',
        compile: function compile(tElement, tAttrs) {
          var linkedScopes = [];
          var instances = [];
          var expToData = {};
          var lastActivated = null;
          var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
          var onExp = onExpMatches[2];
          var expsStr = onExpMatches[1];
          var exps = expsStr.split(',');

          return linkFn;

          function linkFn(scope, element, attrs) {
            linkedScopes.push(scope);
            instances.push({
              scope: scope,
              element: element
            });

            exps.forEach(function (exp, k) {
              addForExp(exp, scope);
            });

            scope.$on('$destroy', removeScope);
          }

          function addForExp(exp, scope) {
            var matches = exp.match(IS_REGEXP);
            var clazz = scope.$eval(matches[1]);
            var compareWithExp = matches[2];
            var data = expToData[exp];
            if (!data) {
              var watchFn = function watchFn(compareWithVal) {
                var newActivated = null;
                instances.some(function (instance) {
                  var thisVal = instance.scope.$eval(onExp);
                  if (thisVal === compareWithVal) {
                    newActivated = instance;
                    return true;
                  }
                });
                if (data.lastActivated !== newActivated) {
                  if (data.lastActivated) {
                    $animate.removeClass(data.lastActivated.element, clazz);
                  }
                  if (newActivated) {
                    $animate.addClass(newActivated.element, clazz);
                  }
                  data.lastActivated = newActivated;
                }
              };
              expToData[exp] = data = {
                lastActivated: null,
                scope: scope,
                watchFn: watchFn,
                compareWithExp: compareWithExp,
                watcher: scope.$watch(compareWithExp, watchFn)
              };
            }
            data.watchFn(scope.$eval(compareWithExp));
          }

          function removeScope(e) {
            var removedScope = e.targetScope;
            var index = linkedScopes.indexOf(removedScope);
            linkedScopes.splice(index, 1);
            instances.splice(index, 1);
            if (linkedScopes.length) {
              var newWatchScope = linkedScopes[0];
              angular.forEach(expToData, function (data) {
                if (data.scope === removedScope) {
                  data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
                  data.scope = newWatchScope;
                }
              });
            } else {
              expToData = {};
            }
          }
        }
      };
    }]);
    angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass']).value('$datepickerSuppressError', false).value('$datepickerLiteralWarning', true).constant('uibDatepickerConfig', {
      datepickerMode: 'day',
      formatDay: 'dd',
      formatMonth: 'MMMM',
      formatYear: 'yyyy',
      formatDayHeader: 'EEE',
      formatDayTitle: 'MMMM yyyy',
      formatMonthTitle: 'yyyy',
      maxDate: null,
      maxMode: 'year',
      minDate: null,
      minMode: 'day',
      monthColumns: 3,
      ngModelOptions: {},
      shortcutPropagation: false,
      showWeeks: true,
      yearColumns: 5,
      yearRows: 4
    }).controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser', function ($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
      var self = this,
          ngModelCtrl = { $setViewValue: angular.noop },
          // nullModelCtrl;
      ngModelOptions = {},
          watchListeners = [];

      $element.addClass('uib-datepicker');
      $attrs.$set('role', 'application');

      if (!$scope.datepickerOptions) {
        $scope.datepickerOptions = {};
      }

      // Modes chain
      this.modes = ['day', 'month', 'year'];

      ['customClass', 'dateDisabled', 'datepickerMode', 'formatDay', 'formatDayHeader', 'formatDayTitle', 'formatMonth', 'formatMonthTitle', 'formatYear', 'maxDate', 'maxMode', 'minDate', 'minMode', 'monthColumns', 'showWeeks', 'shortcutPropagation', 'startingDay', 'yearColumns', 'yearRows'].forEach(function (key) {
        switch (key) {
          case 'customClass':
          case 'dateDisabled':
            $scope[key] = $scope.datepickerOptions[key] || angular.noop;
            break;
          case 'datepickerMode':
            $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ? $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
            break;
          case 'formatDay':
          case 'formatDayHeader':
          case 'formatDayTitle':
          case 'formatMonth':
          case 'formatMonthTitle':
          case 'formatYear':
            self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];
            break;
          case 'monthColumns':
          case 'showWeeks':
          case 'shortcutPropagation':
          case 'yearColumns':
          case 'yearRows':
            self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $scope.datepickerOptions[key] : datepickerConfig[key];
            break;
          case 'startingDay':
            if (angular.isDefined($scope.datepickerOptions.startingDay)) {
              self.startingDay = $scope.datepickerOptions.startingDay;
            } else if (angular.isNumber(datepickerConfig.startingDay)) {
              self.startingDay = datepickerConfig.startingDay;
            } else {
              self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
            }

            break;
          case 'maxDate':
          case 'minDate':
            $scope.$watch('datepickerOptions.' + key, function (value) {
              if (value) {
                if (angular.isDate(value)) {
                  self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
                } else {
                  if ($datepickerLiteralWarning) {
                    $log.warn('Literal date support has been deprecated, please switch to date object usage');
                  }

                  self[key] = new Date(dateFilter(value, 'medium'));
                }
              } else {
                self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;
              }

              self.refreshView();
            });

            break;
          case 'maxMode':
          case 'minMode':
            if ($scope.datepickerOptions[key]) {
              $scope.$watch(function () {
                return $scope.datepickerOptions[key];
              }, function (value) {
                self[key] = $scope[key] = angular.isDefined(value) ? value : $scope.datepickerOptions[key];
                if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) || key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
                  $scope.datepickerMode = self[key];
                  $scope.datepickerOptions.datepickerMode = self[key];
                }
              });
            } else {
              self[key] = $scope[key] = datepickerConfig[key] || null;
            }

            break;
        }
      });

      $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

      $scope.disabled = angular.isDefined($attrs.disabled) || false;
      if (angular.isDefined($attrs.ngDisabled)) {
        watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function (disabled) {
          $scope.disabled = disabled;
          self.refreshView();
        }));
      }

      $scope.isActive = function (dateObject) {
        if (self.compare(dateObject.date, self.activeDate) === 0) {
          $scope.activeDateId = dateObject.uid;
          return true;
        }
        return false;
      };

      this.init = function (ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelOptions = ngModelCtrl_.$options || $scope.datepickerOptions.ngModelOptions || datepickerConfig.ngModelOptions;
        if ($scope.datepickerOptions.initDate) {
          self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();
          $scope.$watch('datepickerOptions.initDate', function (initDate) {
            if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
              self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
              self.refreshView();
            }
          });
        } else {
          self.activeDate = new Date();
        }

        var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
        this.activeDate = !isNaN(date) ? dateParser.fromTimezone(date, ngModelOptions.timezone) : dateParser.fromTimezone(new Date(), ngModelOptions.timezone);

        ngModelCtrl.$render = function () {
          self.render();
        };
      };

      this.render = function () {
        if (ngModelCtrl.$viewValue) {
          var date = new Date(ngModelCtrl.$viewValue),
              isValid = !isNaN(date);

          if (isValid) {
            this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);
          } else if (!$datepickerSuppressError) {
            $log.error('Datepicker directive: "ng-model" value must be a Date object');
          }
        }
        this.refreshView();
      };

      this.refreshView = function () {
        if (this.element) {
          $scope.selectedDt = null;
          this._refreshView();
          if ($scope.activeDt) {
            $scope.activeDateId = $scope.activeDt.uid;
          }

          var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
          date = dateParser.fromTimezone(date, ngModelOptions.timezone);
          ngModelCtrl.$setValidity('dateDisabled', !date || this.element && !this.isDisabled(date));
        }
      };

      this.createDateObject = function (date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        model = dateParser.fromTimezone(model, ngModelOptions.timezone);
        var today = new Date();
        today = dateParser.fromTimezone(today, ngModelOptions.timezone);
        var time = this.compare(date, today);
        var dt = {
          date: date,
          label: dateParser.filter(date, format),
          selected: model && this.compare(date, model) === 0,
          disabled: this.isDisabled(date),
          past: time < 0,
          current: time === 0,
          future: time > 0,
          customClass: this.customClass(date) || null
        };

        if (model && this.compare(date, model) === 0) {
          $scope.selectedDt = dt;
        }

        if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
          $scope.activeDt = dt;
        }

        return dt;
      };

      this.isDisabled = function (date) {
        return $scope.disabled || this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $scope.dateDisabled && $scope.dateDisabled({ date: date, mode: $scope.datepickerMode });
      };

      this.customClass = function (date) {
        return $scope.customClass({ date: date, mode: $scope.datepickerMode });
      };

      // Split array into smaller arrays
      this.split = function (arr, size) {
        var arrays = [];
        while (arr.length > 0) {
          arrays.push(arr.splice(0, size));
        }
        return arrays;
      };

      $scope.select = function (date) {
        if ($scope.datepickerMode === self.minMode) {
          var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
          dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
          dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
          ngModelCtrl.$setViewValue(dt);
          ngModelCtrl.$render();
        } else {
          self.activeDate = date;
          setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);

          $scope.$emit('uib:datepicker.mode');
        }

        $scope.$broadcast('uib:datepicker.focus');
      };

      $scope.move = function (direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
            month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1);
        self.refreshView();
      };

      $scope.toggleMode = function (direction) {
        direction = direction || 1;

        if ($scope.datepickerMode === self.maxMode && direction === 1 || $scope.datepickerMode === self.minMode && direction === -1) {
          return;
        }

        setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);

        $scope.$emit('uib:datepicker.mode');
      };

      // Key event mapper
      $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

      var focusElement = function focusElement() {
        self.element[0].focus();
      };

      // Listen for focus requests from popup directive
      $scope.$on('uib:datepicker.focus', focusElement);

      $scope.keydown = function (evt) {
        var key = $scope.keys[evt.which];

        if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
          return;
        }

        evt.preventDefault();
        if (!self.shortcutPropagation) {
          evt.stopPropagation();
        }

        if (key === 'enter' || key === 'space') {
          if (self.isDisabled(self.activeDate)) {
            return; // do nothing
          }
          $scope.select(self.activeDate);
        } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
          $scope.toggleMode(key === 'up' ? 1 : -1);
        } else {
          self.handleKeyDown(key, evt);
          self.refreshView();
        }
      };

      $element.on('keydown', function (evt) {
        $scope.$apply(function () {
          $scope.keydown(evt);
        });
      });

      $scope.$on('$destroy', function () {
        //Clear all watch listeners on destroy
        while (watchListeners.length) {
          watchListeners.shift()();
        }
      });

      function setMode(mode) {
        $scope.datepickerMode = mode;
        $scope.datepickerOptions.datepickerMode = mode;
      }
    }]).controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

      this.step = { months: 1 };
      this.element = $element;
      function getDaysInMonth(year, month) {
        return month === 1 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
      }

      this.init = function (ctrl) {
        angular.extend(ctrl, this);
        scope.showWeeks = ctrl.showWeeks;
        ctrl.refreshView();
      };

      this.getDates = function (startDate, n) {
        var dates = new Array(n),
            current = new Date(startDate),
            i = 0,
            date;
        while (i < n) {
          date = new Date(current);
          dates[i++] = date;
          current.setDate(current.getDate() + 1);
        }
        return dates;
      };

      this._refreshView = function () {
        var year = this.activeDate.getFullYear(),
            month = this.activeDate.getMonth(),
            firstDayOfMonth = new Date(this.activeDate);

        firstDayOfMonth.setFullYear(year, month, 1);

        var difference = this.startingDay - firstDayOfMonth.getDay(),
            numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference,
            firstDate = new Date(firstDayOfMonth);

        if (numDisplayedFromPreviousMonth > 0) {
          firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
        }

        // 42 is the number of days on a six-week calendar
        var days = this.getDates(firstDate, 42);
        for (var i = 0; i < 42; i++) {
          days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.labels = new Array(7);
        for (var j = 0; j < 7; j++) {
          scope.labels[j] = {
            abbr: dateFilter(days[j].date, this.formatDayHeader),
            full: dateFilter(days[j].date, 'EEEE')
          };
        }

        scope.title = dateFilter(this.activeDate, this.formatDayTitle);
        scope.rows = this.split(days, 7);

        if (scope.showWeeks) {
          scope.weekNumbers = [];
          var thursdayIndex = (4 + 7 - this.startingDay) % 7,
              numWeeks = scope.rows.length;
          for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
            scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
          }
        }
      };

      this.compare = function (date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
        var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
        _date1.setFullYear(date1.getFullYear());
        _date2.setFullYear(date2.getFullYear());
        return _date1 - _date2;
      };

      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
        var time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }

      this.handleKeyDown = function (key, evt) {
        var date = this.activeDate.getDate();

        if (key === 'left') {
          date = date - 1;
        } else if (key === 'up') {
          date = date - 7;
        } else if (key === 'right') {
          date = date + 1;
        } else if (key === 'down') {
          date = date + 7;
        } else if (key === 'pageup' || key === 'pagedown') {
          var month = this.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
          this.activeDate.setMonth(month, 1);
          date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
        } else if (key === 'home') {
          date = 1;
        } else if (key === 'end') {
          date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
        }
        this.activeDate.setDate(date);
      };
    }]).controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
      this.step = { years: 1 };
      this.element = $element;

      this.init = function (ctrl) {
        angular.extend(ctrl, this);
        ctrl.refreshView();
      };

      this._refreshView = function () {
        var months = new Array(12),
            year = this.activeDate.getFullYear(),
            date;

        for (var i = 0; i < 12; i++) {
          date = new Date(this.activeDate);
          date.setFullYear(year, i, 1);
          months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
        scope.rows = this.split(months, this.monthColumns);
        scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;
      };

      this.compare = function (date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth());
        var _date2 = new Date(date2.getFullYear(), date2.getMonth());
        _date1.setFullYear(date1.getFullYear());
        _date2.setFullYear(date2.getFullYear());
        return _date1 - _date2;
      };

      this.handleKeyDown = function (key, evt) {
        var date = this.activeDate.getMonth();

        if (key === 'left') {
          date = date - 1;
        } else if (key === 'up') {
          date = date - this.monthColumns;
        } else if (key === 'right') {
          date = date + 1;
        } else if (key === 'down') {
          date = date + this.monthColumns;
        } else if (key === 'pageup' || key === 'pagedown') {
          var year = this.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
          this.activeDate.setFullYear(year);
        } else if (key === 'home') {
          date = 0;
        } else if (key === 'end') {
          date = 11;
        }
        this.activeDate.setMonth(date);
      };
    }]).controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
      var columns, range;
      this.element = $element;

      function getStartingYear(year) {
        return parseInt((year - 1) / range, 10) * range + 1;
      }

      this.yearpickerInit = function () {
        columns = this.yearColumns;
        range = this.yearRows * columns;
        this.step = { years: range };
      };

      this._refreshView = function () {
        var years = new Array(range),
            date;

        for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
          date = new Date(this.activeDate);
          date.setFullYear(start + i, 0, 1);
          years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.title = [years[0].label, years[range - 1].label].join(' - ');
        scope.rows = this.split(years, columns);
        scope.columns = columns;
      };

      this.compare = function (date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      };

      this.handleKeyDown = function (key, evt) {
        var date = this.activeDate.getFullYear();

        if (key === 'left') {
          date = date - 1;
        } else if (key === 'up') {
          date = date - columns;
        } else if (key === 'right') {
          date = date + 1;
        } else if (key === 'down') {
          date = date + columns;
        } else if (key === 'pageup' || key === 'pagedown') {
          date += (key === 'pageup' ? -1 : 1) * range;
        } else if (key === 'home') {
          date = getStartingYear(this.activeDate.getFullYear());
        } else if (key === 'end') {
          date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
        }
        this.activeDate.setFullYear(date);
      };
    }]).directive('uibDatepicker', function () {
      return {
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
        },
        scope: {
          datepickerOptions: '=?'
        },
        require: ['uibDatepicker', '^ngModel'],
        restrict: 'A',
        controller: 'UibDatepickerController',
        controllerAs: 'datepicker',
        link: function link(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];

          datepickerCtrl.init(ngModelCtrl);
        }
      };
    }).directive('uibDaypicker', function () {
      return {
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepicker/day.html';
        },
        require: ['^uibDatepicker', 'uibDaypicker'],
        restrict: 'A',
        controller: 'UibDaypickerController',
        link: function link(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0],
              daypickerCtrl = ctrls[1];

          daypickerCtrl.init(datepickerCtrl);
        }
      };
    }).directive('uibMonthpicker', function () {
      return {
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepicker/month.html';
        },
        require: ['^uibDatepicker', 'uibMonthpicker'],
        restrict: 'A',
        controller: 'UibMonthpickerController',
        link: function link(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0],
              monthpickerCtrl = ctrls[1];

          monthpickerCtrl.init(datepickerCtrl);
        }
      };
    }).directive('uibYearpicker', function () {
      return {
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepicker/year.html';
        },
        require: ['^uibDatepicker', 'uibYearpicker'],
        restrict: 'A',
        controller: 'UibYearpickerController',
        link: function link(scope, element, attrs, ctrls) {
          var ctrl = ctrls[0];
          angular.extend(ctrl, ctrls[1]);
          ctrl.yearpickerInit();

          ctrl.refreshView();
        }
      };
    });

    angular.module('ui.bootstrap.position', [])

    /**
     * A set of utility methods for working with the DOM.
     * It is meant to be used where we need to absolute-position elements in
     * relation to another element (this is the case for tooltips, popovers,
     * typeahead suggestions etc.).
     */
    .factory('$uibPosition', ['$document', '$window', function ($document, $window) {
      /**
       * Used by scrollbarWidth() function to cache scrollbar's width.
       * Do not access this variable directly, use scrollbarWidth() instead.
       */
      var SCROLLBAR_WIDTH;
      /**
       * scrollbar on body and html element in IE and Edge overlay
       * content and should be considered 0 width.
       */
      var BODY_SCROLLBAR_WIDTH;
      var OVERFLOW_REGEX = {
        normal: /(auto|scroll)/,
        hidden: /(auto|scroll|hidden)/
      };
      var PLACEMENT_REGEX = {
        auto: /\s?auto?\s?/i,
        primary: /^(top|bottom|left|right)$/,
        secondary: /^(top|bottom|left|right|center)$/,
        vertical: /^(top|bottom)$/
      };
      var BODY_REGEX = /(HTML|BODY)/;

      return {

        /**
         * Provides a raw DOM element from a jQuery/jQLite element.
         *
         * @param {element} elem - The element to convert.
         *
         * @returns {element} A HTML element.
         */
        getRawNode: function getRawNode(elem) {
          return elem.nodeName ? elem : elem[0] || elem;
        },

        /**
         * Provides a parsed number for a style property.  Strips
         * units and casts invalid numbers to 0.
         *
         * @param {string} value - The style value to parse.
         *
         * @returns {number} A valid number.
         */
        parseStyle: function parseStyle(value) {
          value = parseFloat(value);
          return isFinite(value) ? value : 0;
        },

        /**
         * Provides the closest positioned ancestor.
         *
         * @param {element} element - The element to get the offest parent for.
         *
         * @returns {element} The closest positioned ancestor.
         */
        offsetParent: function offsetParent(elem) {
          elem = this.getRawNode(elem);

          var offsetParent = elem.offsetParent || $document[0].documentElement;

          function isStaticPositioned(el) {
            return ($window.getComputedStyle(el).position || 'static') === 'static';
          }

          while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
          }

          return offsetParent || $document[0].documentElement;
        },

        /**
         * Provides the scrollbar width, concept from TWBS measureScrollbar()
         * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js
         * In IE and Edge, scollbar on body and html element overlay and should
         * return a width of 0.
         *
         * @returns {number} The width of the browser scollbar.
         */
        scrollbarWidth: function scrollbarWidth(isBody) {
          if (isBody) {
            if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
              var bodyElem = $document.find('body');
              bodyElem.addClass('uib-position-body-scrollbar-measure');
              BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
              BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
              bodyElem.removeClass('uib-position-body-scrollbar-measure');
            }
            return BODY_SCROLLBAR_WIDTH;
          }

          if (angular.isUndefined(SCROLLBAR_WIDTH)) {
            var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
            $document.find('body').append(scrollElem);
            SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
            SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
            scrollElem.remove();
          }

          return SCROLLBAR_WIDTH;
        },

        /**
         * Provides the padding required on an element to replace the scrollbar.
         *
         * @returns {object} An object with the following properties:
         *   <ul>
         *     <li>**scrollbarWidth**: the width of the scrollbar</li>
         *     <li>**widthOverflow**: whether the the width is overflowing</li>
         *     <li>**right**: the amount of right padding on the element needed to replace the scrollbar</li>
         *     <li>**rightOriginal**: the amount of right padding currently on the element</li>
         *     <li>**heightOverflow**: whether the the height is overflowing</li>
         *     <li>**bottom**: the amount of bottom padding on the element needed to replace the scrollbar</li>
         *     <li>**bottomOriginal**: the amount of bottom padding currently on the element</li>
         *   </ul>
         */
        scrollbarPadding: function scrollbarPadding(elem) {
          elem = this.getRawNode(elem);

          var elemStyle = $window.getComputedStyle(elem);
          var paddingRight = this.parseStyle(elemStyle.paddingRight);
          var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
          var scrollParent = this.scrollParent(elem, false, true);
          var scrollbarWidth = this.scrollbarWidth(BODY_REGEX.test(scrollParent.tagName));

          return {
            scrollbarWidth: scrollbarWidth,
            widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
            right: paddingRight + scrollbarWidth,
            originalRight: paddingRight,
            heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
            bottom: paddingBottom + scrollbarWidth,
            originalBottom: paddingBottom
          };
        },

        /**
         * Checks to see if the element is scrollable.
         *
         * @param {element} elem - The element to check.
         * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
         *   default is false.
         *
         * @returns {boolean} Whether the element is scrollable.
         */
        isScrollable: function isScrollable(elem, includeHidden) {
          elem = this.getRawNode(elem);

          var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
          var elemStyle = $window.getComputedStyle(elem);
          return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
        },

        /**
         * Provides the closest scrollable ancestor.
         * A port of the jQuery UI scrollParent method:
         * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js
         *
         * @param {element} elem - The element to find the scroll parent of.
         * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
         *   default is false.
         * @param {boolean=} [includeSelf=false] - Should the element being passed be
         * included in the scrollable llokup.
         *
         * @returns {element} A HTML element.
         */
        scrollParent: function scrollParent(elem, includeHidden, includeSelf) {
          elem = this.getRawNode(elem);

          var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
          var documentEl = $document[0].documentElement;
          var elemStyle = $window.getComputedStyle(elem);
          if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
            return elem;
          }
          var excludeStatic = elemStyle.position === 'absolute';
          var scrollParent = elem.parentElement || documentEl;

          if (scrollParent === documentEl || elemStyle.position === 'fixed') {
            return documentEl;
          }

          while (scrollParent.parentElement && scrollParent !== documentEl) {
            var spStyle = $window.getComputedStyle(scrollParent);
            if (excludeStatic && spStyle.position !== 'static') {
              excludeStatic = false;
            }

            if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
              break;
            }
            scrollParent = scrollParent.parentElement;
          }

          return scrollParent;
        },

        /**
         * Provides read-only equivalent of jQuery's position function:
         * http://api.jquery.com/position/ - distance to closest positioned
         * ancestor.  Does not account for margins by default like jQuery position.
         *
         * @param {element} elem - The element to caclulate the position on.
         * @param {boolean=} [includeMargins=false] - Should margins be accounted
         * for, default is false.
         *
         * @returns {object} An object with the following properties:
         *   <ul>
         *     <li>**width**: the width of the element</li>
         *     <li>**height**: the height of the element</li>
         *     <li>**top**: distance to top edge of offset parent</li>
         *     <li>**left**: distance to left edge of offset parent</li>
         *   </ul>
         */
        position: function position(elem, includeMagins) {
          elem = this.getRawNode(elem);

          var elemOffset = this.offset(elem);
          if (includeMagins) {
            var elemStyle = $window.getComputedStyle(elem);
            elemOffset.top -= this.parseStyle(elemStyle.marginTop);
            elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
          }
          var parent = this.offsetParent(elem);
          var parentOffset = { top: 0, left: 0 };

          if (parent !== $document[0].documentElement) {
            parentOffset = this.offset(parent);
            parentOffset.top += parent.clientTop - parent.scrollTop;
            parentOffset.left += parent.clientLeft - parent.scrollLeft;
          }

          return {
            width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
            height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
            top: Math.round(elemOffset.top - parentOffset.top),
            left: Math.round(elemOffset.left - parentOffset.left)
          };
        },

        /**
         * Provides read-only equivalent of jQuery's offset function:
         * http://api.jquery.com/offset/ - distance to viewport.  Does
         * not account for borders, margins, or padding on the body
         * element.
         *
         * @param {element} elem - The element to calculate the offset on.
         *
         * @returns {object} An object with the following properties:
         *   <ul>
         *     <li>**width**: the width of the element</li>
         *     <li>**height**: the height of the element</li>
         *     <li>**top**: distance to top edge of viewport</li>
         *     <li>**right**: distance to bottom edge of viewport</li>
         *   </ul>
         */
        offset: function offset(elem) {
          elem = this.getRawNode(elem);

          var elemBCR = elem.getBoundingClientRect();
          return {
            width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
            height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
            top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
            left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
          };
        },

        /**
         * Provides offset distance to the closest scrollable ancestor
         * or viewport.  Accounts for border and scrollbar width.
         *
         * Right and bottom dimensions represent the distance to the
         * respective edge of the viewport element.  If the element
         * edge extends beyond the viewport, a negative value will be
         * reported.
         *
         * @param {element} elem - The element to get the viewport offset for.
         * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead
         * of the first scrollable element, default is false.
         * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element
         * be accounted for, default is true.
         *
         * @returns {object} An object with the following properties:
         *   <ul>
         *     <li>**top**: distance to the top content edge of viewport element</li>
         *     <li>**bottom**: distance to the bottom content edge of viewport element</li>
         *     <li>**left**: distance to the left content edge of viewport element</li>
         *     <li>**right**: distance to the right content edge of viewport element</li>
         *   </ul>
         */
        viewportOffset: function viewportOffset(elem, useDocument, includePadding) {
          elem = this.getRawNode(elem);
          includePadding = includePadding !== false ? true : false;

          var elemBCR = elem.getBoundingClientRect();
          var offsetBCR = { top: 0, left: 0, bottom: 0, right: 0 };

          var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
          var offsetParentBCR = offsetParent.getBoundingClientRect();

          offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
          offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
          if (offsetParent === $document[0].documentElement) {
            offsetBCR.top += $window.pageYOffset;
            offsetBCR.left += $window.pageXOffset;
          }
          offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
          offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;

          if (includePadding) {
            var offsetParentStyle = $window.getComputedStyle(offsetParent);
            offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
            offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
            offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
            offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
          }

          return {
            top: Math.round(elemBCR.top - offsetBCR.top),
            bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
            left: Math.round(elemBCR.left - offsetBCR.left),
            right: Math.round(offsetBCR.right - elemBCR.right)
          };
        },

        /**
         * Provides an array of placement values parsed from a placement string.
         * Along with the 'auto' indicator, supported placement strings are:
         *   <ul>
         *     <li>top: element on top, horizontally centered on host element.</li>
         *     <li>top-left: element on top, left edge aligned with host element left edge.</li>
         *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>
         *     <li>bottom: element on bottom, horizontally centered on host element.</li>
         *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>
         *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>
         *     <li>left: element on left, vertically centered on host element.</li>
         *     <li>left-top: element on left, top edge aligned with host element top edge.</li>
         *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>
         *     <li>right: element on right, vertically centered on host element.</li>
         *     <li>right-top: element on right, top edge aligned with host element top edge.</li>
         *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>
         *   </ul>
         * A placement string with an 'auto' indicator is expected to be
         * space separated from the placement, i.e: 'auto bottom-left'  If
         * the primary and secondary placement values do not match 'top,
         * bottom, left, right' then 'top' will be the primary placement and
         * 'center' will be the secondary placement.  If 'auto' is passed, true
         * will be returned as the 3rd value of the array.
         *
         * @param {string} placement - The placement string to parse.
         *
         * @returns {array} An array with the following values
         * <ul>
         *   <li>**[0]**: The primary placement.</li>
         *   <li>**[1]**: The secondary placement.</li>
         *   <li>**[2]**: If auto is passed: true, else undefined.</li>
         * </ul>
         */
        parsePlacement: function parsePlacement(placement) {
          var autoPlace = PLACEMENT_REGEX.auto.test(placement);
          if (autoPlace) {
            placement = placement.replace(PLACEMENT_REGEX.auto, '');
          }

          placement = placement.split('-');

          placement[0] = placement[0] || 'top';
          if (!PLACEMENT_REGEX.primary.test(placement[0])) {
            placement[0] = 'top';
          }

          placement[1] = placement[1] || 'center';
          if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
            placement[1] = 'center';
          }

          if (autoPlace) {
            placement[2] = true;
          } else {
            placement[2] = false;
          }

          return placement;
        },

        /**
         * Provides coordinates for an element to be positioned relative to
         * another element.  Passing 'auto' as part of the placement parameter
         * will enable smart placement - where the element fits. i.e:
         * 'auto left-top' will check to see if there is enough space to the left
         * of the hostElem to fit the targetElem, if not place right (same for secondary
         * top placement).  Available space is calculated using the viewportOffset
         * function.
         *
         * @param {element} hostElem - The element to position against.
         * @param {element} targetElem - The element to position.
         * @param {string=} [placement=top] - The placement for the targetElem,
         *   default is 'top'. 'center' is assumed as secondary placement for
         *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:
         *   <ul>
         *     <li>top</li>
         *     <li>top-right</li>
         *     <li>top-left</li>
         *     <li>bottom</li>
         *     <li>bottom-left</li>
         *     <li>bottom-right</li>
         *     <li>left</li>
         *     <li>left-top</li>
         *     <li>left-bottom</li>
         *     <li>right</li>
         *     <li>right-top</li>
         *     <li>right-bottom</li>
         *   </ul>
         * @param {boolean=} [appendToBody=false] - Should the top and left values returned
         *   be calculated from the body element, default is false.
         *
         * @returns {object} An object with the following properties:
         *   <ul>
         *     <li>**top**: Value for targetElem top.</li>
         *     <li>**left**: Value for targetElem left.</li>
         *     <li>**placement**: The resolved placement.</li>
         *   </ul>
         */
        positionElements: function positionElements(hostElem, targetElem, placement, appendToBody) {
          hostElem = this.getRawNode(hostElem);
          targetElem = this.getRawNode(targetElem);

          // need to read from prop to support tests.
          var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
          var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');

          placement = this.parsePlacement(placement);

          var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
          var targetElemPos = { top: 0, left: 0, placement: '' };

          if (placement[2]) {
            var viewportOffset = this.viewportOffset(hostElem, appendToBody);

            var targetElemStyle = $window.getComputedStyle(targetElem);
            var adjustedSize = {
              width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
              height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
            };

            placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' : placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' : placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' : placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' : placement[0];

            placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' : placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' : placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' : placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' : placement[1];

            if (placement[1] === 'center') {
              if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
                if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                  placement[1] = 'left';
                } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                  placement[1] = 'right';
                }
              } else {
                var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
                if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                  placement[1] = 'top';
                } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                  placement[1] = 'bottom';
                }
              }
            }
          }

          switch (placement[0]) {
            case 'top':
              targetElemPos.top = hostElemPos.top - targetHeight;
              break;
            case 'bottom':
              targetElemPos.top = hostElemPos.top + hostElemPos.height;
              break;
            case 'left':
              targetElemPos.left = hostElemPos.left - targetWidth;
              break;
            case 'right':
              targetElemPos.left = hostElemPos.left + hostElemPos.width;
              break;
          }

          switch (placement[1]) {
            case 'top':
              targetElemPos.top = hostElemPos.top;
              break;
            case 'bottom':
              targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
              break;
            case 'left':
              targetElemPos.left = hostElemPos.left;
              break;
            case 'right':
              targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
              break;
            case 'center':
              if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
              } else {
                targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
              }
              break;
          }

          targetElemPos.top = Math.round(targetElemPos.top);
          targetElemPos.left = Math.round(targetElemPos.left);
          targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];

          return targetElemPos;
        },

        /**
         * Provides a way to adjust the top positioning after first
         * render to correctly align element to top after content
         * rendering causes resized element height
         *
         * @param {array} placementClasses - The array of strings of classes
         * element should have.
         * @param {object} containerPosition - The object with container
         * position information
         * @param {number} initialHeight - The initial height for the elem.
         * @param {number} currentHeight - The current height for the elem.
         */
        adjustTop: function adjustTop(placementClasses, containerPosition, initialHeight, currentHeight) {
          if (placementClasses.indexOf('top') !== -1 && initialHeight !== currentHeight) {
            return {
              top: containerPosition.top - currentHeight + 'px'
            };
          }
        },

        /**
         * Provides a way for positioning tooltip & dropdown
         * arrows when using placement options beyond the standard
         * left, right, top, or bottom.
         *
         * @param {element} elem - The tooltip/dropdown element.
         * @param {string} placement - The placement for the elem.
         */
        positionArrow: function positionArrow(elem, placement) {
          elem = this.getRawNode(elem);

          var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
          if (!innerElem) {
            return;
          }

          var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');

          var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
          if (!arrowElem) {
            return;
          }

          var arrowCss = {
            top: '',
            bottom: '',
            left: '',
            right: ''
          };

          placement = this.parsePlacement(placement);
          if (placement[1] === 'center') {
            // no adjustment necessary - just reset styles
            angular.element(arrowElem).css(arrowCss);
            return;
          }

          var borderProp = 'border-' + placement[0] + '-width';
          var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];

          var borderRadiusProp = 'border-';
          if (PLACEMENT_REGEX.vertical.test(placement[0])) {
            borderRadiusProp += placement[0] + '-' + placement[1];
          } else {
            borderRadiusProp += placement[1] + '-' + placement[0];
          }
          borderRadiusProp += '-radius';
          var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];

          switch (placement[0]) {
            case 'top':
              arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
              break;
            case 'bottom':
              arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
              break;
            case 'left':
              arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
              break;
            case 'right':
              arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
              break;
          }

          arrowCss[placement[1]] = borderRadius;

          angular.element(arrowElem).css(arrowCss);
        }
      };
    }]);

    angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position']).value('$datepickerPopupLiteralWarning', true).constant('uibDatepickerPopupConfig', {
      altInputFormats: [],
      appendToBody: false,
      clearText: 'Clear',
      closeOnDateSelection: true,
      closeText: 'Done',
      currentText: 'Today',
      datepickerPopup: 'yyyy-MM-dd',
      datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
      datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
      html5Types: {
        date: 'yyyy-MM-dd',
        'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
        'month': 'yyyy-MM'
      },
      onOpenFocus: true,
      showButtonBar: true,
      placement: 'auto bottom-left'
    }).controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning', function ($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
      var cache = {},
          isHtml5DateInput = false;
      var dateFormat,
          closeOnDateSelection,
          appendToBody,
          onOpenFocus,
          datepickerPopupTemplateUrl,
          datepickerTemplateUrl,
          popupEl,
          datepickerEl,
          scrollParentEl,
          ngModel,
          ngModelOptions,
          $popup,
          altInputFormats,
          watchListeners = [];

      this.init = function (_ngModel_) {
        ngModel = _ngModel_;
        ngModelOptions = angular.isObject(_ngModel_.$options) ? _ngModel_.$options : {
          timezone: null
        };
        closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ? $scope.$parent.$eval($attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
        appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ? $scope.$parent.$eval($attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
        onOpenFocus = angular.isDefined($attrs.onOpenFocus) ? $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
        datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ? $attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
        datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ? $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
        altInputFormats = angular.isDefined($attrs.altInputFormats) ? $scope.$parent.$eval($attrs.altInputFormats) : datepickerPopupConfig.altInputFormats;

        $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ? $scope.$parent.$eval($attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;

        if (datepickerPopupConfig.html5Types[$attrs.type]) {
          dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
          isHtml5DateInput = true;
        } else {
          dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
          $attrs.$observe('uibDatepickerPopup', function (value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            // Invalidate the $modelValue to ensure that formatters re-run
            // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
            if (newDateFormat !== dateFormat) {
              dateFormat = newDateFormat;
              ngModel.$modelValue = null;

              if (!dateFormat) {
                throw new Error('uibDatepickerPopup must have a date format specified.');
              }
            }
          });
        }

        if (!dateFormat) {
          throw new Error('uibDatepickerPopup must have a date format specified.');
        }

        if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
          throw new Error('HTML5 date input types do not support custom formats.');
        }

        // popup element used to display calendar
        popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');

        popupEl.attr({
          'ng-model': 'date',
          'ng-change': 'dateSelection(date)',
          'template-url': datepickerPopupTemplateUrl
        });

        // datepicker element
        datepickerEl = angular.element(popupEl.children()[0]);
        datepickerEl.attr('template-url', datepickerTemplateUrl);

        if (!$scope.datepickerOptions) {
          $scope.datepickerOptions = {};
        }

        if (isHtml5DateInput) {
          if ($attrs.type === 'month') {
            $scope.datepickerOptions.datepickerMode = 'month';
            $scope.datepickerOptions.minMode = 'month';
          }
        }

        datepickerEl.attr('datepicker-options', 'datepickerOptions');

        if (!isHtml5DateInput) {
          // Internal API to maintain the correct ng-invalid-[key] class
          ngModel.$$parserName = 'date';
          ngModel.$validators.date = validator;
          ngModel.$parsers.unshift(parseDate);
          ngModel.$formatters.push(function (value) {
            if (ngModel.$isEmpty(value)) {
              $scope.date = value;
              return value;
            }

            if (angular.isNumber(value)) {
              value = new Date(value);
            }

            $scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);

            return dateParser.filter($scope.date, dateFormat);
          });
        } else {
          ngModel.$formatters.push(function (value) {
            $scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);
            return value;
          });
        }

        // Detect changes in the view from the text box
        ngModel.$viewChangeListeners.push(function () {
          $scope.date = parseDateString(ngModel.$viewValue);
        });

        $element.on('keydown', inputKeydownBind);

        $popup = $compile(popupEl)($scope);
        // Prevent jQuery cache memory leak (template is now redundant after linking)
        popupEl.remove();

        if (appendToBody) {
          $document.find('body').append($popup);
        } else {
          $element.after($popup);
        }

        $scope.$on('$destroy', function () {
          if ($scope.isOpen === true) {
            if (!$rootScope.$$phase) {
              $scope.$apply(function () {
                $scope.isOpen = false;
              });
            }
          }

          $popup.remove();
          $element.off('keydown', inputKeydownBind);
          $document.off('click', documentClickBind);
          if (scrollParentEl) {
            scrollParentEl.off('scroll', positionPopup);
          }
          angular.element($window).off('resize', positionPopup);

          //Clear all watch listeners on destroy
          while (watchListeners.length) {
            watchListeners.shift()();
          }
        });
      };

      $scope.getText = function (key) {
        return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
      };

      $scope.isDisabled = function (date) {
        if (date === 'today') {
          date = dateParser.fromTimezone(new Date(), ngModelOptions.timezone);
        }

        var dates = {};
        angular.forEach(['minDate', 'maxDate'], function (key) {
          if (!$scope.datepickerOptions[key]) {
            dates[key] = null;
          } else if (angular.isDate($scope.datepickerOptions[key])) {
            dates[key] = new Date($scope.datepickerOptions[key]);
          } else {
            if ($datepickerPopupLiteralWarning) {
              $log.warn('Literal date support has been deprecated, please switch to date object usage');
            }

            dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
          }
        });

        return $scope.datepickerOptions && dates.minDate && $scope.compare(date, dates.minDate) < 0 || dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
      };

      $scope.compare = function (date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
      };

      // Inner change
      $scope.dateSelection = function (dt) {
        $scope.date = dt;
        var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
        $element.val(date);
        ngModel.$setViewValue(date);

        if (closeOnDateSelection) {
          $scope.isOpen = false;
          $element[0].focus();
        }
      };

      $scope.keydown = function (evt) {
        if (evt.which === 27) {
          evt.stopPropagation();
          $scope.isOpen = false;
          $element[0].focus();
        }
      };

      $scope.select = function (date, evt) {
        evt.stopPropagation();

        if (date === 'today') {
          var today = new Date();
          if (angular.isDate($scope.date)) {
            date = new Date($scope.date);
            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
          } else {
            date = dateParser.fromTimezone(today, ngModelOptions.timezone);
            date.setHours(0, 0, 0, 0);
          }
        }
        $scope.dateSelection(date);
      };

      $scope.close = function (evt) {
        evt.stopPropagation();

        $scope.isOpen = false;
        $element[0].focus();
      };

      $scope.disabled = angular.isDefined($attrs.disabled) || false;
      if ($attrs.ngDisabled) {
        watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function (disabled) {
          $scope.disabled = disabled;
        }));
      }

      $scope.$watch('isOpen', function (value) {
        if (value) {
          if (!$scope.disabled) {
            $timeout(function () {
              positionPopup();

              if (onOpenFocus) {
                $scope.$broadcast('uib:datepicker.focus');
              }

              $document.on('click', documentClickBind);

              var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
              if (appendToBody || $position.parsePlacement(placement)[2]) {
                scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
                if (scrollParentEl) {
                  scrollParentEl.on('scroll', positionPopup);
                }
              } else {
                scrollParentEl = null;
              }

              angular.element($window).on('resize', positionPopup);
            }, 0, false);
          } else {
            $scope.isOpen = false;
          }
        } else {
          $document.off('click', documentClickBind);
          if (scrollParentEl) {
            scrollParentEl.off('scroll', positionPopup);
          }
          angular.element($window).off('resize', positionPopup);
        }
      });

      function cameltoDash(string) {
        return string.replace(/([A-Z])/g, function ($1) {
          return '-' + $1.toLowerCase();
        });
      }

      function parseDateString(viewValue) {
        var date = dateParser.parse(viewValue, dateFormat, $scope.date);
        if (isNaN(date)) {
          for (var i = 0; i < altInputFormats.length; i++) {
            date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
            if (!isNaN(date)) {
              return date;
            }
          }
        }
        return date;
      }

      function parseDate(viewValue) {
        if (angular.isNumber(viewValue)) {
          // presumably timestamp to date object
          viewValue = new Date(viewValue);
        }

        if (!viewValue) {
          return null;
        }

        if (angular.isDate(viewValue) && !isNaN(viewValue)) {
          return viewValue;
        }

        if (angular.isString(viewValue)) {
          var date = parseDateString(viewValue);
          if (!isNaN(date)) {
            return dateParser.fromTimezone(date, ngModelOptions.timezone);
          }
        }

        return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;
      }

      function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;

        if (!$attrs.ngRequired && !value) {
          return true;
        }

        if (angular.isNumber(value)) {
          value = new Date(value);
        }

        if (!value) {
          return true;
        }

        if (angular.isDate(value) && !isNaN(value)) {
          return true;
        }

        if (angular.isString(value)) {
          return !isNaN(parseDateString(value));
        }

        return false;
      }

      function documentClickBind(event) {
        if (!$scope.isOpen && $scope.disabled) {
          return;
        }

        var popup = $popup[0];
        var dpContainsTarget = $element[0].contains(event.target);
        // The popup node may not be an element node
        // In some browsers (IE) only element nodes have the 'contains' function
        var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
        if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
          $scope.$apply(function () {
            $scope.isOpen = false;
          });
        }
      }

      function inputKeydownBind(evt) {
        if (evt.which === 27 && $scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.$apply(function () {
            $scope.isOpen = false;
          });
          $element[0].focus();
        } else if (evt.which === 40 && !$scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.$apply(function () {
            $scope.isOpen = true;
          });
        }
      }

      function positionPopup() {
        if ($scope.isOpen) {
          var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
          var position = $position.positionElements($element, dpElement, placement, appendToBody);
          dpElement.css({ top: position.top + 'px', left: position.left + 'px' });
          if (dpElement.hasClass('uib-position-measure')) {
            dpElement.removeClass('uib-position-measure');
          }
        }
      }

      $scope.$on('uib:datepicker.mode', function () {
        $timeout(positionPopup, 0, false);
      });
    }]).directive('uibDatepickerPopup', function () {
      return {
        require: ['ngModel', 'uibDatepickerPopup'],
        controller: 'UibDatepickerPopupController',
        scope: {
          datepickerOptions: '=?',
          isOpen: '=?',
          currentText: '@',
          clearText: '@',
          closeText: '@'
        },
        link: function link(scope, element, attrs, ctrls) {
          var ngModel = ctrls[0],
              ctrl = ctrls[1];

          ctrl.init(ngModel);
        }
      };
    }).directive('uibDatepickerPopupWrap', function () {
      return {
        restrict: 'A',
        transclude: true,
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
        }
      };
    });

    angular.module('ui.bootstrap.debounce', [])
    /**
     * A helper, internal service that debounces a function
     */
    .factory('$$debounce', ['$timeout', function ($timeout) {
      return function (callback, debounceTime) {
        var timeoutPromise;

        return function () {
          var self = this;
          var args = Array.prototype.slice.call(arguments);
          if (timeoutPromise) {
            $timeout.cancel(timeoutPromise);
          }

          timeoutPromise = $timeout(function () {
            callback.apply(self, args);
          }, debounceTime);
        };
      };
    }]);

    angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position']).constant('uibDropdownConfig', {
      appendToOpenClass: 'uib-dropdown-open',
      openClass: 'open'
    }).service('uibDropdownService', ['$document', '$rootScope', function ($document, $rootScope) {
      var openScope = null;

      this.open = function (dropdownScope, element) {
        if (!openScope) {
          $document.on('click', closeDropdown);
        }

        if (openScope && openScope !== dropdownScope) {
          openScope.isOpen = false;
        }

        openScope = dropdownScope;
      };

      this.close = function (dropdownScope, element) {
        if (openScope === dropdownScope) {
          $document.off('click', closeDropdown);
          $document.off('keydown', this.keybindFilter);
          openScope = null;
        }
      };

      var closeDropdown = function closeDropdown(evt) {
        // This method may still be called during the same mouse event that
        // unbound this event handler. So check openScope before proceeding.
        if (!openScope) {
          return;
        }

        if (evt && openScope.getAutoClose() === 'disabled') {
          return;
        }

        if (evt && evt.which === 3) {
          return;
        }

        var toggleElement = openScope.getToggleElement();
        if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
          return;
        }

        var dropdownElement = openScope.getDropdownElement();
        if (evt && openScope.getAutoClose() === 'outsideClick' && dropdownElement && dropdownElement[0].contains(evt.target)) {
          return;
        }

        openScope.focusToggleElement();
        openScope.isOpen = false;

        if (!$rootScope.$$phase) {
          openScope.$apply();
        }
      };

      this.keybindFilter = function (evt) {
        if (!openScope) {
          // see this.close as ESC could have been pressed which kills the scope so we can not proceed
          return;
        }

        var dropdownElement = openScope.getDropdownElement();
        var toggleElement = openScope.getToggleElement();
        var dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target);
        var toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);
        if (evt.which === 27) {
          evt.stopPropagation();
          openScope.focusToggleElement();
          closeDropdown();
        } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted)) {
          evt.preventDefault();
          evt.stopPropagation();
          openScope.focusDropdownEntry(evt.which);
        }
      };
    }]).controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function ($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
      var self = this,
          scope = $scope.$new(),
          // create a child scope so we are not polluting original one
      templateScope,
          appendToOpenClass = dropdownConfig.appendToOpenClass,
          openClass = dropdownConfig.openClass,
          getIsOpen,
          setIsOpen = angular.noop,
          toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
          appendToBody = false,
          appendTo = null,
          keynavEnabled = false,
          selectedOption = null,
          body = $document.find('body');

      $element.addClass('dropdown');

      this.init = function () {
        if ($attrs.isOpen) {
          getIsOpen = $parse($attrs.isOpen);
          setIsOpen = getIsOpen.assign;

          $scope.$watch(getIsOpen, function (value) {
            scope.isOpen = !!value;
          });
        }

        if (angular.isDefined($attrs.dropdownAppendTo)) {
          var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
          if (appendToEl) {
            appendTo = angular.element(appendToEl);
          }
        }

        appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
        keynavEnabled = angular.isDefined($attrs.keyboardNav);

        if (appendToBody && !appendTo) {
          appendTo = body;
        }

        if (appendTo && self.dropdownMenu) {
          appendTo.append(self.dropdownMenu);
          $element.on('$destroy', function handleDestroyEvent() {
            self.dropdownMenu.remove();
          });
        }
      };

      this.toggle = function (open) {
        scope.isOpen = arguments.length ? !!open : !scope.isOpen;
        if (angular.isFunction(setIsOpen)) {
          setIsOpen(scope, scope.isOpen);
        }

        return scope.isOpen;
      };

      // Allow other directives to watch status
      this.isOpen = function () {
        return scope.isOpen;
      };

      scope.getToggleElement = function () {
        return self.toggleElement;
      };

      scope.getAutoClose = function () {
        return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
      };

      scope.getElement = function () {
        return $element;
      };

      scope.isKeynavEnabled = function () {
        return keynavEnabled;
      };

      scope.focusDropdownEntry = function (keyCode) {
        var elems = self.dropdownMenu ? //If append to body is used.
        angular.element(self.dropdownMenu).find('a') : $element.find('ul').eq(0).find('a');

        switch (keyCode) {
          case 40:
            {
              if (!angular.isNumber(self.selectedOption)) {
                self.selectedOption = 0;
              } else {
                self.selectedOption = self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1;
              }
              break;
            }
          case 38:
            {
              if (!angular.isNumber(self.selectedOption)) {
                self.selectedOption = elems.length - 1;
              } else {
                self.selectedOption = self.selectedOption === 0 ? 0 : self.selectedOption - 1;
              }
              break;
            }
        }
        elems[self.selectedOption].focus();
      };

      scope.getDropdownElement = function () {
        return self.dropdownMenu;
      };

      scope.focusToggleElement = function () {
        if (self.toggleElement) {
          self.toggleElement[0].focus();
        }
      };

      scope.$watch('isOpen', function (isOpen, wasOpen) {
        if (appendTo && self.dropdownMenu) {
          var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
              css,
              rightalign,
              scrollbarPadding,
              scrollbarWidth = 0;

          css = {
            top: pos.top + 'px',
            display: isOpen ? 'block' : 'none'
          };

          rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
          if (!rightalign) {
            css.left = pos.left + 'px';
            css.right = 'auto';
          } else {
            css.left = 'auto';
            scrollbarPadding = $position.scrollbarPadding(appendTo);

            if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
              scrollbarWidth = scrollbarPadding.scrollbarWidth;
            }

            css.right = window.innerWidth - scrollbarWidth - (pos.left + $element.prop('offsetWidth')) + 'px';
          }

          // Need to adjust our positioning to be relative to the appendTo container
          // if it's not the body element
          if (!appendToBody) {
            var appendOffset = $position.offset(appendTo);

            css.top = pos.top - appendOffset.top + 'px';

            if (!rightalign) {
              css.left = pos.left - appendOffset.left + 'px';
            } else {
              css.right = window.innerWidth - (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
            }
          }

          self.dropdownMenu.css(css);
        }

        var openContainer = appendTo ? appendTo : $element;
        var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);

        if (hasOpenClass === !isOpen) {
          $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function () {
            if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
              toggleInvoker($scope, { open: !!isOpen });
            }
          });
        }

        if (isOpen) {
          if (self.dropdownMenuTemplateUrl) {
            $templateRequest(self.dropdownMenuTemplateUrl).then(function (tplContent) {
              templateScope = scope.$new();
              $compile(tplContent.trim())(templateScope, function (dropdownElement) {
                var newEl = dropdownElement;
                self.dropdownMenu.replaceWith(newEl);
                self.dropdownMenu = newEl;
                $document.on('keydown', uibDropdownService.keybindFilter);
              });
            });
          } else {
            $document.on('keydown', uibDropdownService.keybindFilter);
          }

          scope.focusToggleElement();
          uibDropdownService.open(scope, $element);
        } else {
          uibDropdownService.close(scope, $element);
          if (self.dropdownMenuTemplateUrl) {
            if (templateScope) {
              templateScope.$destroy();
            }
            var newEl = angular.element('<ul class="dropdown-menu"></ul>');
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          }

          self.selectedOption = null;
        }

        if (angular.isFunction(setIsOpen)) {
          setIsOpen($scope, isOpen);
        }
      });
    }]).directive('uibDropdown', function () {
      return {
        controller: 'UibDropdownController',
        link: function link(scope, element, attrs, dropdownCtrl) {
          dropdownCtrl.init();
        }
      };
    }).directive('uibDropdownMenu', function () {
      return {
        restrict: 'A',
        require: '?^uibDropdown',
        link: function link(scope, element, attrs, dropdownCtrl) {
          if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
            return;
          }

          element.addClass('dropdown-menu');

          var tplUrl = attrs.templateUrl;
          if (tplUrl) {
            dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
          }

          if (!dropdownCtrl.dropdownMenu) {
            dropdownCtrl.dropdownMenu = element;
          }
        }
      };
    }).directive('uibDropdownToggle', function () {
      return {
        require: '?^uibDropdown',
        link: function link(scope, element, attrs, dropdownCtrl) {
          if (!dropdownCtrl) {
            return;
          }

          element.addClass('dropdown-toggle');

          dropdownCtrl.toggleElement = element;

          var toggleDropdown = function toggleDropdown(event) {
            event.preventDefault();

            if (!element.hasClass('disabled') && !attrs.disabled) {
              scope.$apply(function () {
                dropdownCtrl.toggle();
              });
            }
          };

          element.bind('click', toggleDropdown);

          // WAI-ARIA
          element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
          scope.$watch(dropdownCtrl.isOpen, function (isOpen) {
            element.attr('aria-expanded', !!isOpen);
          });

          scope.$on('$destroy', function () {
            element.unbind('click', toggleDropdown);
          });
        }
      };
    });

    angular.module('ui.bootstrap.stackedMap', [])
    /**
     * A helper, internal data structure that acts as a map but also allows getting / removing
     * elements in the LIFO order
     */
    .factory('$$stackedMap', function () {
      return {
        createNew: function createNew() {
          var stack = [];

          return {
            add: function add(key, value) {
              stack.push({
                key: key,
                value: value
              });
            },
            get: function get(key) {
              for (var i = 0; i < stack.length; i++) {
                if (key === stack[i].key) {
                  return stack[i];
                }
              }
            },
            keys: function keys() {
              var keys = [];
              for (var i = 0; i < stack.length; i++) {
                keys.push(stack[i].key);
              }
              return keys;
            },
            top: function top() {
              return stack[stack.length - 1];
            },
            remove: function remove(key) {
              var idx = -1;
              for (var i = 0; i < stack.length; i++) {
                if (key === stack[i].key) {
                  idx = i;
                  break;
                }
              }
              return stack.splice(idx, 1)[0];
            },
            removeTop: function removeTop() {
              return stack.pop();
            },
            length: function length() {
              return stack.length;
            }
          };
        }
      };
    });
    angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap', 'ui.bootstrap.position'])
    /**
     * A helper, internal data structure that stores all references attached to key
     */
    .factory('$$multiMap', function () {
      return {
        createNew: function createNew() {
          var map = {};

          return {
            entries: function entries() {
              return Object.keys(map).map(function (key) {
                return {
                  key: key,
                  value: map[key]
                };
              });
            },
            get: function get(key) {
              return map[key];
            },
            hasKey: function hasKey(key) {
              return !!map[key];
            },
            keys: function keys() {
              return Object.keys(map);
            },
            put: function put(key, value) {
              if (!map[key]) {
                map[key] = [];
              }

              map[key].push(value);
            },
            remove: function remove(key, value) {
              var values = map[key];

              if (!values) {
                return;
              }

              var idx = values.indexOf(value);

              if (idx !== -1) {
                values.splice(idx, 1);
              }

              if (!values.length) {
                delete map[key];
              }
            }
          };
        }
      };
    })

    /**
     * Pluggable resolve mechanism for the modal resolve resolution
     * Supports UI Router's $resolve service
     */
    .provider('$uibResolve', function () {
      var resolve = this;
      this.resolver = null;

      this.setResolver = function (resolver) {
        this.resolver = resolver;
      };

      this.$get = ['$injector', '$q', function ($injector, $q) {
        var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
        return {
          resolve: function resolve(invocables, locals, parent, self) {
            if (resolver) {
              return resolver.resolve(invocables, locals, parent, self);
            }

            var promises = [];

            angular.forEach(invocables, function (value) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promises.push($q.resolve($injector.invoke(value)));
              } else if (angular.isString(value)) {
                promises.push($q.resolve($injector.get(value)));
              } else {
                promises.push($q.resolve(value));
              }
            });

            return $q.all(promises).then(function (resolves) {
              var resolveObj = {};
              var resolveIter = 0;
              angular.forEach(invocables, function (value, key) {
                resolveObj[key] = resolves[resolveIter++];
              });

              return resolveObj;
            });
          }
        };
      }];
    })

    /**
     * A helper directive for the $modal service. It creates a backdrop element.
     */
    .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack', function ($animate, $injector, $modalStack) {
      return {
        restrict: 'A',
        compile: function compile(tElement, tAttrs) {
          tElement.addClass(tAttrs.backdropClass);
          return linkFn;
        }
      };

      function linkFn(scope, element, attrs) {
        if (attrs.modalInClass) {
          $animate.addClass(element, attrs.modalInClass);

          scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
            var done = setIsAsync();
            if (scope.modalOptions.animation) {
              $animate.removeClass(element, attrs.modalInClass).then(done);
            } else {
              done();
            }
          });
        }
      }
    }]).directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document', function ($modalStack, $q, $animateCss, $document) {
      return {
        scope: {
          index: '@'
        },
        restrict: 'A',
        transclude: true,
        templateUrl: function templateUrl(tElement, tAttrs) {
          return tAttrs.templateUrl || 'uib/template/modal/window.html';
        },
        link: function link(scope, element, attrs) {
          element.addClass(attrs.windowTopClass || '');
          scope.size = attrs.size;

          scope.close = function (evt) {
            var modal = $modalStack.getTop();
            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && evt.target === evt.currentTarget) {
              evt.preventDefault();
              evt.stopPropagation();
              $modalStack.dismiss(modal.key, 'backdrop click');
            }
          };

          // moved from template to fix issue #2280
          element.on('click', scope.close);

          // This property is only added to the scope for the purpose of detecting when this directive is rendered.
          // We can detect that by using this property in the template associated with this directive and then use
          // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
          scope.$isRendered = true;

          // Deferred object that will be resolved when this modal is rendered.
          var modalRenderDeferObj = $q.defer();
          // Resolve render promise post-digest
          scope.$$postDigest(function () {
            modalRenderDeferObj.resolve();
          });

          modalRenderDeferObj.promise.then(function () {
            var animationPromise = null;

            if (attrs.modalInClass) {
              animationPromise = $animateCss(element, {
                addClass: attrs.modalInClass
              }).start();

              scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
                var done = setIsAsync();
                $animateCss(element, {
                  removeClass: attrs.modalInClass
                }).start().then(done);
              });
            }

            $q.when(animationPromise).then(function () {
              // Notify {@link $modalStack} that modal is rendered.
              var modal = $modalStack.getTop();
              if (modal) {
                $modalStack.modalRendered(modal.key);
              }

              /**
               * If something within the freshly-opened modal already has focus (perhaps via a
               * directive that causes focus) then there's no need to try to focus anything.
               */
              if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
                var inputWithAutofocus = element[0].querySelector('[autofocus]');
                /**
                 * Auto-focusing of a freshly-opened modal element causes any child elements
                 * with the autofocus attribute to lose focus. This is an issue on touch
                 * based devices which will show and then hide the onscreen keyboard.
                 * Attempts to refocus the autofocus element via JavaScript will not reopen
                 * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
                 * the modal element if the modal does not contain an autofocus element.
                 */
                if (inputWithAutofocus) {
                  inputWithAutofocus.focus();
                } else {
                  element[0].focus();
                }
              }
            });
          });
        }
      };
    }]).directive('uibModalAnimationClass', function () {
      return {
        compile: function compile(tElement, tAttrs) {
          if (tAttrs.modalAnimation) {
            tElement.addClass(tAttrs.uibModalAnimationClass);
          }
        }
      };
    }).directive('uibModalTransclude', ['$animate', function ($animate) {
      return {
        link: function link(scope, element, attrs, controller, transclude) {
          transclude(scope.$parent, function (clone) {
            element.empty();
            $animate.enter(clone, element);
          });
        }
      };
    }]).factory('$uibModalStack', ['$animate', '$animateCss', '$document', '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition', function ($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
      var OPENED_MODAL_CLASS = 'modal-open';

      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {
        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
      };
      var topModalIndex = 0;
      var previousTopOpenedModal = null;
      var ARIA_HIDDEN_ATTRIBUTE_NAME = 'data-bootstrap-modal-aria-hidden-count';

      //Modal focus behavior
      var tabbableSelector = 'a[href], area[href], input:not([disabled]):not([tabindex=\'-1\']), ' + 'button:not([disabled]):not([tabindex=\'-1\']),select:not([disabled]):not([tabindex=\'-1\']), textarea:not([disabled]):not([tabindex=\'-1\']), ' + 'iframe, object, embed, *[tabindex]:not([tabindex=\'-1\']), *[contenteditable=true]';
      var scrollbarPadding;
      var SNAKE_CASE_REGEXP = /[A-Z]/g;

      // TODO: extract into common dependency with tooltip
      function snake_case(name) {
        var separator = '-';
        return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }

      function isVisible(element) {
        return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
      }

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }

        // If any backdrop exist, ensure that it's index is always
        // right below the top modal
        if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
          topBackdropIndex = topModalIndex;
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value;
        var appendToElement = modalWindow.appendTo;

        //clean up the stack
        openedWindows.remove(modalInstance);
        previousTopOpenedModal = openedWindows.top();
        if (previousTopOpenedModal) {
          topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
        }

        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function () {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          var areAnyOpen = openedClasses.hasKey(modalBodyClass);
          appendToElement.toggleClass(modalBodyClass, areAnyOpen);
          if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
            if (scrollbarPadding.originalRight) {
              appendToElement.css({ paddingRight: scrollbarPadding.originalRight + 'px' });
            } else {
              appendToElement.css({ paddingRight: '' });
            }
            scrollbarPadding = null;
          }
          toggleTopWindowClass(true);
        }, modalWindow.closedDeferred);
        checkRemoveBackdrop();

        //move focus to specified element if available, or else to body
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else if (appendToElement.focus) {
          appendToElement.focus();
        }
      }

      // Add or remove "windowTopClass" from the top window in the stack
      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;

        if (openedWindows.length() > 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
        }
      }

      function checkRemoveBackdrop() {
        //remove backdrop if no longer needed
        if (backdropDomEl && backdropIndex() === -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function () {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }

      function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function setIsAsync() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }

          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

        // Note that it's intentional that asyncPromise might be null.
        // That's when setIsAsync has not been called during the
        // NOW_CLOSING_EVENT broadcast.
        return $q.when(asyncPromise).then(afterAnimating);

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;

          $animate.leave(domEl).then(function () {
            if (done) {
              done();
            }

            domEl.remove();
            if (closedDeferred) {
              closedDeferred.resolve();
            }
          });

          scope.$destroy();
        }
      }

      $document.on('keydown', keydownListener);

      $rootScope.$on('$destroy', function () {
        $document.off('keydown', keydownListener);
      });

      function keydownListener(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }

        var modal = openedWindows.top();
        if (modal) {
          switch (evt.which) {
            case 27:
              {
                if (modal.value.keyboard) {
                  evt.preventDefault();
                  $rootScope.$apply(function () {
                    $modalStack.dismiss(modal.key, 'escape key press');
                  });
                }
                break;
              }
            case 9:
              {
                var list = $modalStack.loadFocusElementList(modal);
                var focusChanged = false;
                if (evt.shiftKey) {
                  if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
                    focusChanged = $modalStack.focusLastFocusableElement(list);
                  }
                } else {
                  if ($modalStack.isFocusInLastItem(evt, list)) {
                    focusChanged = $modalStack.focusFirstFocusableElement(list);
                  }
                }

                if (focusChanged) {
                  evt.preventDefault();
                  evt.stopPropagation();
                }

                break;
              }
          }
        }
      }

      $modalStack.open = function (modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
            modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

        toggleTopWindowClass(false);

        // Store the current top first, to determine what index we ought to use
        // for the current top modal
        previousTopOpenedModal = openedWindows.top();

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          closedDeferred: modal.closedDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass,
          animation: modal.animation,
          appendTo: modal.appendTo
        });

        openedClasses.put(modalBodyClass, modalInstance);

        var appendToElement = modal.appendTo,
            currBackdropIndex = backdropIndex();

        if (!appendToElement.length) {
          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
        }

        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.modalOptions = modal;
          backdropScope.index = currBackdropIndex;
          backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
          backdropDomEl.attr({
            'class': 'modal-backdrop',
            'ng-style': '{\'z-index\': 1040 + (index && 1 || 0) + index*10}',
            'uib-modal-animation-class': 'fade',
            'modal-in-class': 'in'
          });
          if (modal.backdropClass) {
            backdropDomEl.addClass(modal.backdropClass);
          }

          if (modal.animation) {
            backdropDomEl.attr('modal-animation', 'true');
          }
          $compile(backdropDomEl)(backdropScope);
          $animate.enter(backdropDomEl, appendToElement);
          if ($uibPosition.isScrollable(appendToElement)) {
            scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
            if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
              appendToElement.css({ paddingRight: scrollbarPadding.right + 'px' });
            }
          }
        }

        var content;
        if (modal.component) {
          content = document.createElement(snake_case(modal.component.name));
          content = angular.element(content);
          content.attr({
            resolve: '$resolve',
            'modal-instance': '$uibModalInstance',
            close: '$close($value)',
            dismiss: '$dismiss($value)'
          });
        } else {
          content = modal.content;
        }

        // Set the top modal index based on the index of the previous top modal
        topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
          'class': 'modal',
          'template-url': modal.windowTemplateUrl,
          'window-top-class': modal.windowTopClass,
          'role': 'dialog',
          'aria-labelledby': modal.ariaLabelledBy,
          'aria-describedby': modal.ariaDescribedBy,
          'size': modal.size,
          'index': topModalIndex,
          'animate': 'animate',
          'ng-style': '{\'z-index\': 1050 + $$topModalIndex*10, display: \'block\'}',
          'tabindex': -1,
          'uib-modal-animation-class': 'fade',
          'modal-in-class': 'in'
        }).append(content);
        if (modal.windowClass) {
          angularDomEl.addClass(modal.windowClass);
        }

        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }

        appendToElement.addClass(modalBodyClass);
        if (modal.scope) {
          // we need to explicitly add the modal index to the modal scope
          // because it is needed by ngStyle to compute the zIndex property.
          modal.scope.$$topModalIndex = topModalIndex;
        }
        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);

        openedWindows.top().value.modalDomEl = angularDomEl;
        openedWindows.top().value.modalOpener = modalOpener;

        applyAriaHidden(angularDomEl);

        function applyAriaHidden(el) {
          if (!el || el[0].tagName === 'BODY') {
            return;
          }

          getSiblings(el).forEach(function (sibling) {
            var elemIsAlreadyHidden = sibling.getAttribute('aria-hidden') === 'true',
                ariaHiddenCount = parseInt(sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10);

            if (!ariaHiddenCount) {
              ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0;
            }

            sibling.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, ariaHiddenCount + 1);
            sibling.setAttribute('aria-hidden', 'true');
          });

          return applyAriaHidden(el.parent());

          function getSiblings(el) {
            var children = el.parent() ? el.parent().children() : [];

            return Array.prototype.filter.call(children, function (child) {
              return child !== el[0];
            });
          }
        }
      };

      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }

      function unhideBackgroundElements() {
        Array.prototype.forEach.call(document.querySelectorAll('[' + ARIA_HIDDEN_ATTRIBUTE_NAME + ']'), function (hiddenEl) {
          var ariaHiddenCount = parseInt(hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10),
              newHiddenCount = ariaHiddenCount - 1;
          hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount);

          if (!newHiddenCount) {
            hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME);
            hiddenEl.removeAttribute('aria-hidden');
          }
        });
      }

      $modalStack.close = function (modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        unhideBackgroundElements();
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }

        return !modalWindow;
      };

      $modalStack.dismiss = function (modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        unhideBackgroundElements();
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismissAll = function (reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };

      $modalStack.getTop = function () {
        return openedWindows.top();
      };

      $modalStack.modalRendered = function (modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        $modalStack.focusFirstFocusableElement($modalStack.loadFocusElementList(modalWindow));
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };

      $modalStack.focusFirstFocusableElement = function (list) {
        if (list.length > 0) {
          list[0].focus();
          return true;
        }
        return false;
      };

      $modalStack.focusLastFocusableElement = function (list) {
        if (list.length > 0) {
          list[list.length - 1].focus();
          return true;
        }
        return false;
      };

      $modalStack.isModalFocused = function (evt, modalWindow) {
        if (evt && modalWindow) {
          var modalDomEl = modalWindow.value.modalDomEl;
          if (modalDomEl && modalDomEl.length) {
            return (evt.target || evt.srcElement) === modalDomEl[0];
          }
        }
        return false;
      };

      $modalStack.isFocusInFirstItem = function (evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[0];
        }
        return false;
      };

      $modalStack.isFocusInLastItem = function (evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[list.length - 1];
        }
        return false;
      };

      $modalStack.loadFocusElementList = function (modalWindow) {
        if (modalWindow) {
          var modalDomE1 = modalWindow.value.modalDomEl;
          if (modalDomE1 && modalDomE1.length) {
            var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
            return elements ? Array.prototype.filter.call(elements, function (element) {
              return isVisible(element);
            }) : elements;
          }
        }
      };

      return $modalStack;
    }]).provider('$uibModal', function () {
      var $modalProvider = {
        options: {
          animation: true,
          backdrop: true, //can also be false or 'static'
          keyboard: true
        },
        $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack', function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl);
          }

          var promiseChain = null;
          $modal.getPromiseChain = function () {
            return promiseChain;
          };

          $modal.open = function (modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalClosedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              closed: modalClosedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function close(result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function dismiss(reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);

            //verify options
            if (!modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of component or template or templateUrl options is required.');
            }

            var templateAndResolvePromise;
            if (modalOptions.component) {
              templateAndResolvePromise = $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null));
            } else {
              templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);
            }

            function resolveWithTemplate() {
              return templateAndResolvePromise;
            }

            // Wait for the resolution of the existing promise chain.
            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
            // Then add to $modalStack and resolve opened.
            // Finally clean up the chain variable if no subsequent modal has overwritten it.
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain]).then(resolveWithTemplate, resolveWithTemplate).then(function resolveSuccess(tplAndVars) {
              var providedScope = modalOptions.scope || $rootScope;

              var modalScope = providedScope.$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;

              modalScope.$on('$destroy', function () {
                if (!modalScope.$$uibDestructionScheduled) {
                  modalScope.$dismiss('$uibUnscheduledDestruction');
                }
              });

              var modal = {
                scope: modalScope,
                deferred: modalResultDeferred,
                renderDeferred: modalRenderDeferred,
                closedDeferred: modalClosedDeferred,
                animation: modalOptions.animation,
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                backdropClass: modalOptions.backdropClass,
                windowTopClass: modalOptions.windowTopClass,
                windowClass: modalOptions.windowClass,
                windowTemplateUrl: modalOptions.windowTemplateUrl,
                ariaLabelledBy: modalOptions.ariaLabelledBy,
                ariaDescribedBy: modalOptions.ariaDescribedBy,
                size: modalOptions.size,
                openedClass: modalOptions.openedClass,
                appendTo: modalOptions.appendTo
              };

              var component = {};
              var ctrlInstance,
                  ctrlInstantiate,
                  ctrlLocals = {};

              if (modalOptions.component) {
                constructLocals(component, false, true, false);
                component.name = modalOptions.component;
                modal.component = component;
              } else if (modalOptions.controller) {
                constructLocals(ctrlLocals, true, false, true);

                // the third param will make the controller instantiate later,private api
                // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126
                ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);
                if (modalOptions.controllerAs && modalOptions.bindToController) {
                  ctrlInstance = ctrlInstantiate.instance;
                  ctrlInstance.$close = modalScope.$close;
                  ctrlInstance.$dismiss = modalScope.$dismiss;
                  angular.extend(ctrlInstance, {
                    $resolve: ctrlLocals.$scope.$resolve
                  }, providedScope);
                }

                ctrlInstance = ctrlInstantiate();

                if (angular.isFunction(ctrlInstance.$onInit)) {
                  ctrlInstance.$onInit();
                }
              }

              if (!modalOptions.component) {
                modal.content = tplAndVars[0];
              }

              $modalStack.open(modalInstance, modal);
              modalOpenedDeferred.resolve(true);

              function constructLocals(obj, template, instanceOnScope, injectable) {
                obj.$scope = modalScope;
                obj.$scope.$resolve = {};
                if (instanceOnScope) {
                  obj.$scope.$uibModalInstance = modalInstance;
                } else {
                  obj.$uibModalInstance = modalInstance;
                }

                var resolves = template ? tplAndVars[1] : tplAndVars;
                angular.forEach(resolves, function (value, key) {
                  if (injectable) {
                    obj[key] = value;
                  }

                  obj.$scope.$resolve[key] = value;
                });
              }
            }, function resolveError(reason) {
              modalOpenedDeferred.reject(reason);
              modalResultDeferred.reject(reason);
            })['finally'](function () {
              if (promiseChain === samePromise) {
                promiseChain = null;
              }
            });

            return modalInstance;
          };

          return $modal;
        }]
      };

      return $modalProvider;
    });

    angular.module('ui.bootstrap.paging', [])
    /**
     * Helper internal service for generating common controller code between the
     * pager and pagination components
     */
    .factory('uibPaging', ['$parse', function ($parse) {
      return {
        create: function create(ctrl, $scope, $attrs) {
          ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
          ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl
          ctrl._watchers = [];

          ctrl.init = function (ngModelCtrl, config) {
            ctrl.ngModelCtrl = ngModelCtrl;
            ctrl.config = config;

            ngModelCtrl.$render = function () {
              ctrl.render();
            };

            if ($attrs.itemsPerPage) {
              ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function (value) {
                ctrl.itemsPerPage = parseInt(value, 10);
                $scope.totalPages = ctrl.calculateTotalPages();
                ctrl.updatePage();
              }));
            } else {
              ctrl.itemsPerPage = config.itemsPerPage;
            }

            $scope.$watch('totalItems', function (newTotal, oldTotal) {
              if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
                $scope.totalPages = ctrl.calculateTotalPages();
                ctrl.updatePage();
              }
            });
          };

          ctrl.calculateTotalPages = function () {
            var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
            return Math.max(totalPages || 0, 1);
          };

          ctrl.render = function () {
            $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
          };

          $scope.selectPage = function (page, evt) {
            if (evt) {
              evt.preventDefault();
            }

            var clickAllowed = !$scope.ngDisabled || !evt;
            if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
              if (evt && evt.target) {
                evt.target.blur();
              }
              ctrl.ngModelCtrl.$setViewValue(page);
              ctrl.ngModelCtrl.$render();
            }
          };

          $scope.getText = function (key) {
            return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
          };

          $scope.noPrevious = function () {
            return $scope.page === 1;
          };

          $scope.noNext = function () {
            return $scope.page === $scope.totalPages;
          };

          ctrl.updatePage = function () {
            ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable

            if ($scope.page > $scope.totalPages) {
              $scope.selectPage($scope.totalPages);
            } else {
              ctrl.ngModelCtrl.$render();
            }
          };

          $scope.$on('$destroy', function () {
            while (ctrl._watchers.length) {
              ctrl._watchers.shift()();
            }
          });
        }
      };
    }]);

    angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex']).controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function ($scope, $attrs, uibPaging, uibPagerConfig) {
      $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;

      uibPaging.create(this, $scope, $attrs);
    }]).constant('uibPagerConfig', {
      itemsPerPage: 10,
      previousText: ' Previous',
      nextText: 'Next ',
      align: true
    }).directive('uibPager', ['uibPagerConfig', function (uibPagerConfig) {
      return {
        scope: {
          totalItems: '=',
          previousText: '@',
          nextText: '@',
          ngDisabled: '='
        },
        require: ['uibPager', '?ngModel'],
        restrict: 'A',
        controller: 'UibPagerController',
        controllerAs: 'pager',
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/pager/pager.html';
        },
        link: function link(scope, element, attrs, ctrls) {
          element.addClass('pager');
          var paginationCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];

          if (!ngModelCtrl) {
            return; // do nothing if no ng-model
          }

          paginationCtrl.init(ngModelCtrl, uibPagerConfig);
        }
      };
    }]);

    angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex']).controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function ($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
      var ctrl = this;
      // Setup configuration parameters
      var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
          rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
          forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
          boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,
          pageLabel = angular.isDefined($attrs.pageLabel) ? function (idx) {
        return $scope.$parent.$eval($attrs.pageLabel, { $page: idx });
      } : angular.identity;
      $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
      $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;

      uibPaging.create(this, $scope, $attrs);

      if ($attrs.maxSize) {
        ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function (value) {
          maxSize = parseInt(value, 10);
          ctrl.render();
        }));
      }

      // Create page object used in template
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }

      function getPages(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1,
            endPage = totalPages;
        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

        // recompute if maxSize
        if (isMaxSized) {
          if (rotate) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
            endPage = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, pageLabel(number), number === currentPage);
          pages.push(page);
        }

        // Add links to move between page sets
        if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
          if (startPage > 1) {
            if (!boundaryLinkNumbers || startPage > 3) {
              //need ellipsis for all options unless range is too close to beginning
              var previousPageSet = makePage(startPage - 1, '...', false);
              pages.unshift(previousPageSet);
            }
            if (boundaryLinkNumbers) {
              if (startPage === 3) {
                //need to replace ellipsis when the buttons would be sequential
                var secondPageLink = makePage(2, '2', false);
                pages.unshift(secondPageLink);
              }
              //add the first page
              var firstPageLink = makePage(1, '1', false);
              pages.unshift(firstPageLink);
            }
          }

          if (endPage < totalPages) {
            if (!boundaryLinkNumbers || endPage < totalPages - 2) {
              //need ellipsis for all options unless range is too close to end
              var nextPageSet = makePage(endPage + 1, '...', false);
              pages.push(nextPageSet);
            }
            if (boundaryLinkNumbers) {
              if (endPage === totalPages - 2) {
                //need to replace ellipsis when the buttons would be sequential
                var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
                pages.push(secondToLastPageLink);
              }
              //add the last page
              var lastPageLink = makePage(totalPages, totalPages, false);
              pages.push(lastPageLink);
            }
          }
        }
        return pages;
      }

      var originalRender = this.render;
      this.render = function () {
        originalRender();
        if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
          $scope.pages = getPages($scope.page, $scope.totalPages);
        }
      };
    }]).constant('uibPaginationConfig', {
      itemsPerPage: 10,
      boundaryLinks: false,
      boundaryLinkNumbers: false,
      directionLinks: true,
      firstText: 'First',
      previousText: 'Previous',
      nextText: 'Next',
      lastText: 'Last',
      rotate: true,
      forceEllipses: false
    }).directive('uibPagination', ['$parse', 'uibPaginationConfig', function ($parse, uibPaginationConfig) {
      return {
        scope: {
          totalItems: '=',
          firstText: '@',
          previousText: '@',
          nextText: '@',
          lastText: '@',
          ngDisabled: '='
        },
        require: ['uibPagination', '?ngModel'],
        restrict: 'A',
        controller: 'UibPaginationController',
        controllerAs: 'pagination',
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/pagination/pagination.html';
        },
        link: function link(scope, element, attrs, ctrls) {
          element.addClass('pagination');
          var paginationCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];

          if (!ngModelCtrl) {
            return; // do nothing if no ng-model
          }

          paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
        }
      };
    }]);

    /**
     * The following features are still outstanding: animation as a
     * function, placement as a function, inside, support for more triggers than
     * just mouse enter/leave, html tooltips, and selector delegation.
     */
    angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])

    /**
     * The $tooltip service creates tooltip- and popover-like directives as well as
     * houses global options for them.
     */
    .provider('$uibTooltip', function () {
      // The default options tooltip and popover.
      var defaultOptions = {
        placement: 'top',
        placementClassPrefix: '',
        animation: true,
        popupDelay: 0,
        popupCloseDelay: 0,
        useContentExp: false
      };

      // Default hide triggers for each show trigger
      var triggerMap = {
        'mouseenter': 'mouseleave',
        'click': 'click',
        'outsideClick': 'outsideClick',
        'focus': 'blur',
        'none': ''
      };

      // The options specified to the provider globally.
      var globalOptions = {};

      /**
       * `options({})` allows global configuration of all tooltips in the
       * application.
       *
       *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
       *     // place tooltips left instead of top by default
       *     $tooltipProvider.options( { placement: 'left' } );
       *   });
       */
      this.options = function (value) {
        angular.extend(globalOptions, value);
      };

      /**
       * This allows you to extend the set of trigger mappings available. E.g.:
       *
       *   $tooltipProvider.setTriggers( { 'openTrigger': 'closeTrigger' } );
       */
      this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers);
      };

      /**
       * This is a helper function for translating camel-case to snake_case.
       */
      function snake_case(name) {
        var regexp = /[A-Z]/g;
        var separator = '-';
        return name.replace(regexp, function (letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }

      /**
       * Returns the actual instance of the $tooltip service.
       * TODO support multiple triggers
       */
      this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function ($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
        var openedTooltips = $$stackedMap.createNew();
        $document.on('keyup', keypressListener);

        $rootScope.$on('$destroy', function () {
          $document.off('keyup', keypressListener);
        });

        function keypressListener(e) {
          if (e.which === 27) {
            var last = openedTooltips.top();
            if (last) {
              last.value.close();
              last = null;
            }
          }
        }

        return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
          options = angular.extend({}, defaultOptions, globalOptions, options);

          /**
           * Returns an object of show and hide triggers.
           *
           * If a trigger is supplied,
           * it is used to show the tooltip; otherwise, it will use the `trigger`
           * option passed to the `$tooltipProvider.options` method; else it will
           * default to the trigger supplied to this directive factory.
           *
           * The hide trigger is based on the show trigger. If the `trigger` option
           * was passed to the `$tooltipProvider.options` method, it will use the
           * mapped trigger from `triggerMap` or the passed trigger if the map is
           * undefined; otherwise, it uses the `triggerMap` value of the show
           * trigger; else it will just use the show trigger.
           */
          function getTriggers(trigger) {
            var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
            var hide = show.map(function (trigger) {
              return triggerMap[trigger] || trigger;
            });
            return {
              show: show,
              hide: hide
            };
          }

          var directiveName = snake_case(ttType);

          var startSym = $interpolate.startSymbol();
          var endSym = $interpolate.endSymbol();
          var template = '<div ' + directiveName + '-popup ' + 'uib-title="' + startSym + 'title' + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + 'content' + endSym + '" ') + 'origin-scope="origScope" ' + 'class="uib-position-measure ' + prefix + '" ' + 'tooltip-animation-class="fade"' + 'uib-tooltip-classes ' + 'ng-class="{ in: isOpen }" ' + '>' + '</div>';

          return {
            compile: function compile(tElem, tAttrs) {
              var tooltipLinker = $compile(template);

              return function link(scope, element, attrs, tooltipCtrl) {
                var tooltip;
                var tooltipLinkedScope;
                var transitionTimeout;
                var showTimeout;
                var hideTimeout;
                var positionTimeout;
                var adjustmentTimeout;
                var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                var triggers = getTriggers(undefined);
                var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
                var ttScope = scope.$new(true);
                var repositionScheduled = false;
                var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
                var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
                var observers = [];
                var lastPlacement;

                var positionTooltip = function positionTooltip() {
                  // check if tooltip exists and is not empty
                  if (!tooltip || !tooltip.html()) {
                    return;
                  }

                  if (!positionTimeout) {
                    positionTimeout = $timeout(function () {
                      var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                      var initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                      var elementPos = appendToBody ? $position.offset(element) : $position.position(element);
                      tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });
                      var placementClasses = ttPosition.placement.split('-');

                      if (!tooltip.hasClass(placementClasses[0])) {
                        tooltip.removeClass(lastPlacement.split('-')[0]);
                        tooltip.addClass(placementClasses[0]);
                      }

                      if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
                        tooltip.removeClass(options.placementClassPrefix + lastPlacement);
                        tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
                      }

                      adjustmentTimeout = $timeout(function () {
                        var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                        var adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
                        if (adjustment) {
                          tooltip.css(adjustment);
                        }
                        adjustmentTimeout = null;
                      }, 0, false);

                      // first time through tt element will have the
                      // uib-position-measure class or if the placement
                      // has changed we need to position the arrow.
                      if (tooltip.hasClass('uib-position-measure')) {
                        $position.positionArrow(tooltip, ttPosition.placement);
                        tooltip.removeClass('uib-position-measure');
                      } else if (lastPlacement !== ttPosition.placement) {
                        $position.positionArrow(tooltip, ttPosition.placement);
                      }
                      lastPlacement = ttPosition.placement;

                      positionTimeout = null;
                    }, 0, false);
                  }
                };

                // Set up the correct scope to allow transclusion later
                ttScope.origScope = scope;

                // By default, the tooltip is not open.
                // TODO add ability to start tooltip opened
                ttScope.isOpen = false;

                function toggleTooltipBind() {
                  if (!ttScope.isOpen) {
                    showTooltipBind();
                  } else {
                    hideTooltipBind();
                  }
                }

                // Show the tooltip with delay if specified, otherwise show it immediately
                function showTooltipBind() {
                  if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                    return;
                  }

                  cancelHide();
                  prepareTooltip();

                  if (ttScope.popupDelay) {
                    // Do nothing if the tooltip was already scheduled to pop-up.
                    // This happens if show is triggered multiple times before any hide is triggered.
                    if (!showTimeout) {
                      showTimeout = $timeout(show, ttScope.popupDelay, false);
                    }
                  } else {
                    show();
                  }
                }

                function hideTooltipBind() {
                  cancelShow();

                  if (ttScope.popupCloseDelay) {
                    if (!hideTimeout) {
                      hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                    }
                  } else {
                    hide();
                  }
                }

                // Show the tooltip popup element.
                function show() {
                  cancelShow();
                  cancelHide();

                  // Don't show empty tooltips.
                  if (!ttScope.content) {
                    return angular.noop;
                  }

                  createTooltip();

                  // And show the tooltip.
                  ttScope.$evalAsync(function () {
                    ttScope.isOpen = true;
                    assignIsOpen(true);
                    positionTooltip();
                  });
                }

                function cancelShow() {
                  if (showTimeout) {
                    $timeout.cancel(showTimeout);
                    showTimeout = null;
                  }

                  if (positionTimeout) {
                    $timeout.cancel(positionTimeout);
                    positionTimeout = null;
                  }
                }

                // Hide the tooltip popup element.
                function hide() {
                  if (!ttScope) {
                    return;
                  }

                  // First things first: we don't show it anymore.
                  ttScope.$evalAsync(function () {
                    if (ttScope) {
                      ttScope.isOpen = false;
                      assignIsOpen(false);
                      // And now we remove it from the DOM. However, if we have animation, we
                      // need to wait for it to expire beforehand.
                      // FIXME: this is a placeholder for a port of the transitions library.
                      // The fade transition in TWBS is 150ms.
                      if (ttScope.animation) {
                        if (!transitionTimeout) {
                          transitionTimeout = $timeout(removeTooltip, 150, false);
                        }
                      } else {
                        removeTooltip();
                      }
                    }
                  });
                }

                function cancelHide() {
                  if (hideTimeout) {
                    $timeout.cancel(hideTimeout);
                    hideTimeout = null;
                  }

                  if (transitionTimeout) {
                    $timeout.cancel(transitionTimeout);
                    transitionTimeout = null;
                  }
                }

                function createTooltip() {
                  // There can only be one tooltip element per directive shown at once.
                  if (tooltip) {
                    return;
                  }

                  tooltipLinkedScope = ttScope.$new();
                  tooltip = tooltipLinker(tooltipLinkedScope, function (tooltip) {
                    if (appendToBody) {
                      $document.find('body').append(tooltip);
                    } else {
                      element.after(tooltip);
                    }
                  });

                  openedTooltips.add(ttScope, {
                    close: hide
                  });

                  prepObservers();
                }

                function removeTooltip() {
                  cancelShow();
                  cancelHide();
                  unregisterObservers();

                  if (tooltip) {
                    tooltip.remove();

                    tooltip = null;
                    if (adjustmentTimeout) {
                      $timeout.cancel(adjustmentTimeout);
                    }
                  }

                  openedTooltips.remove(ttScope);

                  if (tooltipLinkedScope) {
                    tooltipLinkedScope.$destroy();
                    tooltipLinkedScope = null;
                  }
                }

                /**
                 * Set the initial scope values. Once
                 * the tooltip is created, the observers
                 * will be added to keep things in sync.
                 */
                function prepareTooltip() {
                  ttScope.title = attrs[prefix + 'Title'];
                  if (contentParse) {
                    ttScope.content = contentParse(scope);
                  } else {
                    ttScope.content = attrs[ttType];
                  }

                  ttScope.popupClass = attrs[prefix + 'Class'];
                  ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
                  var placement = $position.parsePlacement(ttScope.placement);
                  lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];

                  var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
                  var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
                  ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                  ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
                }

                function assignIsOpen(isOpen) {
                  if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                    isOpenParse.assign(scope, isOpen);
                  }
                }

                ttScope.contentExp = function () {
                  return ttScope.content;
                };

                /**
                 * Observe the relevant attributes.
                 */
                attrs.$observe('disabled', function (val) {
                  if (val) {
                    cancelShow();
                  }

                  if (val && ttScope.isOpen) {
                    hide();
                  }
                });

                if (isOpenParse) {
                  scope.$watch(isOpenParse, function (val) {
                    if (ttScope && !val === ttScope.isOpen) {
                      toggleTooltipBind();
                    }
                  });
                }

                function prepObservers() {
                  observers.length = 0;

                  if (contentParse) {
                    observers.push(scope.$watch(contentParse, function (val) {
                      ttScope.content = val;
                      if (!val && ttScope.isOpen) {
                        hide();
                      }
                    }));

                    observers.push(tooltipLinkedScope.$watch(function () {
                      if (!repositionScheduled) {
                        repositionScheduled = true;
                        tooltipLinkedScope.$$postDigest(function () {
                          repositionScheduled = false;
                          if (ttScope && ttScope.isOpen) {
                            positionTooltip();
                          }
                        });
                      }
                    }));
                  } else {
                    observers.push(attrs.$observe(ttType, function (val) {
                      ttScope.content = val;
                      if (!val && ttScope.isOpen) {
                        hide();
                      } else {
                        positionTooltip();
                      }
                    }));
                  }

                  observers.push(attrs.$observe(prefix + 'Title', function (val) {
                    ttScope.title = val;
                    if (ttScope.isOpen) {
                      positionTooltip();
                    }
                  }));

                  observers.push(attrs.$observe(prefix + 'Placement', function (val) {
                    ttScope.placement = val ? val : options.placement;
                    if (ttScope.isOpen) {
                      positionTooltip();
                    }
                  }));
                }

                function unregisterObservers() {
                  if (observers.length) {
                    angular.forEach(observers, function (observer) {
                      observer();
                    });
                    observers.length = 0;
                  }
                }

                // hide tooltips/popovers for outsideClick trigger
                function bodyHideTooltipBind(e) {
                  if (!ttScope || !ttScope.isOpen || !tooltip) {
                    return;
                  }
                  // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked
                  if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                    hideTooltipBind();
                  }
                }

                var unregisterTriggers = function unregisterTriggers() {
                  triggers.show.forEach(function (trigger) {
                    if (trigger === 'outsideClick') {
                      element.off('click', toggleTooltipBind);
                    } else {
                      element.off(trigger, showTooltipBind);
                      element.off(trigger, toggleTooltipBind);
                    }
                  });
                  triggers.hide.forEach(function (trigger) {
                    if (trigger === 'outsideClick') {
                      $document.off('click', bodyHideTooltipBind);
                    } else {
                      element.off(trigger, hideTooltipBind);
                    }
                  });
                };

                function prepTriggers() {
                  var showTriggers = [],
                      hideTriggers = [];
                  var val = scope.$eval(attrs[prefix + 'Trigger']);
                  unregisterTriggers();

                  if (angular.isObject(val)) {
                    Object.keys(val).forEach(function (key) {
                      showTriggers.push(key);
                      hideTriggers.push(val[key]);
                    });
                    triggers = {
                      show: showTriggers,
                      hide: hideTriggers
                    };
                  } else {
                    triggers = getTriggers(val);
                  }

                  if (triggers.show !== 'none') {
                    triggers.show.forEach(function (trigger, idx) {
                      if (trigger === 'outsideClick') {
                        element.on('click', toggleTooltipBind);
                        $document.on('click', bodyHideTooltipBind);
                      } else if (trigger === triggers.hide[idx]) {
                        element.on(trigger, toggleTooltipBind);
                      } else if (trigger) {
                        element.on(trigger, showTooltipBind);
                        element.on(triggers.hide[idx], hideTooltipBind);
                      }

                      element.on('keypress', function (e) {
                        if (e.which === 27) {
                          hideTooltipBind();
                        }
                      });
                    });
                  }
                }

                prepTriggers();

                var animation = scope.$eval(attrs[prefix + 'Animation']);
                ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

                var appendToBodyVal;
                var appendKey = prefix + 'AppendToBody';
                if (appendKey in attrs && attrs[appendKey] === undefined) {
                  appendToBodyVal = true;
                } else {
                  appendToBodyVal = scope.$eval(attrs[appendKey]);
                }

                appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

                // Make sure tooltip is destroyed and removed.
                scope.$on('$destroy', function onDestroyTooltip() {
                  unregisterTriggers();
                  removeTooltip();
                  ttScope = null;
                });
              };
            }
          };
        };
      }];
    })

    // This is mostly ngInclude code but with a custom scope
    .directive('uibTooltipTemplateTransclude', ['$animate', '$sce', '$compile', '$templateRequest', function ($animate, $sce, $compile, $templateRequest) {
      return {
        link: function link(scope, elem, attrs) {
          var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

          var changeCounter = 0,
              currentScope,
              previousElement,
              currentElement;

          var cleanupLastIncludeContent = function cleanupLastIncludeContent() {
            if (previousElement) {
              previousElement.remove();
              previousElement = null;
            }

            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }

            if (currentElement) {
              $animate.leave(currentElement).then(function () {
                previousElement = null;
              });
              previousElement = currentElement;
              currentElement = null;
            }
          };

          scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function (src) {
            var thisChangeId = ++changeCounter;

            if (src) {
              //set the 2nd param to true to ignore the template request error so that the inner
              //contents and scope can be cleaned up.
              $templateRequest(src, true).then(function (response) {
                if (thisChangeId !== changeCounter) {
                  return;
                }
                var newScope = origScope.$new();
                var template = response;

                var clone = $compile(template)(newScope, function (clone) {
                  cleanupLastIncludeContent();
                  $animate.enter(clone, elem);
                });

                currentScope = newScope;
                currentElement = clone;

                currentScope.$emit('$includeContentLoaded', src);
              }, function () {
                if (thisChangeId === changeCounter) {
                  cleanupLastIncludeContent();
                  scope.$emit('$includeContentError', src);
                }
              });
              scope.$emit('$includeContentRequested', src);
            } else {
              cleanupLastIncludeContent();
            }
          });

          scope.$on('$destroy', cleanupLastIncludeContent);
        }
      };
    }])

    /**
     * Note that it's intentional that these classes are *not* applied through $animate.
     * They must not be animated as they're expected to be present on the tooltip on
     * initialization.
     */
    .directive('uibTooltipClasses', ['$uibPosition', function ($uibPosition) {
      return {
        restrict: 'A',
        link: function link(scope, element, attrs) {
          // need to set the primary position so the
          // arrow has space during position measure.
          // tooltip.positionTooltip()
          if (scope.placement) {
            // // There are no top-left etc... classes
            // // in TWBS, so we need the primary position.
            var position = $uibPosition.parsePlacement(scope.placement);
            element.addClass(position[0]);
          }

          if (scope.popupClass) {
            element.addClass(scope.popupClass);
          }

          if (scope.animation) {
            element.addClass(attrs.tooltipAnimationClass);
          }
        }
      };
    }]).directive('uibTooltipPopup', function () {
      return {
        restrict: 'A',
        scope: { content: '@' },
        templateUrl: 'uib/template/tooltip/tooltip-popup.html'
      };
    }).directive('uibTooltip', ['$uibTooltip', function ($uibTooltip) {
      return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
    }]).directive('uibTooltipTemplatePopup', function () {
      return {
        restrict: 'A',
        scope: { contentExp: '&', originScope: '&' },
        templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
      };
    }).directive('uibTooltipTemplate', ['$uibTooltip', function ($uibTooltip) {
      return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
        useContentExp: true
      });
    }]).directive('uibTooltipHtmlPopup', function () {
      return {
        restrict: 'A',
        scope: { contentExp: '&' },
        templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
      };
    }).directive('uibTooltipHtml', ['$uibTooltip', function ($uibTooltip) {
      return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
        useContentExp: true
      });
    }]);

    /**
     * The following features are still outstanding: popup delay, animation as a
     * function, placement as a function, inside, support for more triggers than
     * just mouse enter/leave, and selector delegatation.
     */
    angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('uibPopoverTemplatePopup', function () {
      return {
        restrict: 'A',
        scope: { uibTitle: '@', contentExp: '&', originScope: '&' },
        templateUrl: 'uib/template/popover/popover-template.html'
      };
    }).directive('uibPopoverTemplate', ['$uibTooltip', function ($uibTooltip) {
      return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
        useContentExp: true
      });
    }]).directive('uibPopoverHtmlPopup', function () {
      return {
        restrict: 'A',
        scope: { contentExp: '&', uibTitle: '@' },
        templateUrl: 'uib/template/popover/popover-html.html'
      };
    }).directive('uibPopoverHtml', ['$uibTooltip', function ($uibTooltip) {
      return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
        useContentExp: true
      });
    }]).directive('uibPopoverPopup', function () {
      return {
        restrict: 'A',
        scope: { uibTitle: '@', content: '@' },
        templateUrl: 'uib/template/popover/popover.html'
      };
    }).directive('uibPopover', ['$uibTooltip', function ($uibTooltip) {
      return $uibTooltip('uibPopover', 'popover', 'click');
    }]);

    angular.module('ui.bootstrap.progressbar', []).constant('uibProgressConfig', {
      animate: true,
      max: 100
    }).controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function ($scope, $attrs, progressConfig) {
      var self = this,
          animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

      this.bars = [];
      $scope.max = getMaxOrDefault();

      this.addBar = function (bar, element, attrs) {
        if (!animate) {
          element.css({ 'transition': 'none' });
        }

        this.bars.push(bar);

        bar.max = getMaxOrDefault();
        bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

        bar.$watch('value', function (value) {
          bar.recalculatePercentage();
        });

        bar.recalculatePercentage = function () {
          var totalPercentage = self.bars.reduce(function (total, bar) {
            bar.percent = +(100 * bar.value / bar.max).toFixed(2);
            return total + bar.percent;
          }, 0);

          if (totalPercentage > 100) {
            bar.percent -= totalPercentage - 100;
          }
        };

        bar.$on('$destroy', function () {
          element = null;
          self.removeBar(bar);
        });
      };

      this.removeBar = function (bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
        this.bars.forEach(function (bar) {
          bar.recalculatePercentage();
        });
      };

      //$attrs.$observe('maxParam', function(maxParam) {
      $scope.$watch('maxParam', function (maxParam) {
        self.bars.forEach(function (bar) {
          bar.max = getMaxOrDefault();
          bar.recalculatePercentage();
        });
      });

      function getMaxOrDefault() {
        return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
      }
    }]).directive('uibProgress', function () {
      return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        require: 'uibProgress',
        scope: {
          maxParam: '=?max'
        },
        templateUrl: 'uib/template/progressbar/progress.html'
      };
    }).directive('uibBar', function () {
      return {
        replace: true,
        transclude: true,
        require: '^uibProgress',
        scope: {
          value: '=',
          type: '@'
        },
        templateUrl: 'uib/template/progressbar/bar.html',
        link: function link(scope, element, attrs, progressCtrl) {
          progressCtrl.addBar(scope, element, attrs);
        }
      };
    }).directive('uibProgressbar', function () {
      return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        scope: {
          value: '=',
          maxParam: '=?max',
          type: '@'
        },
        templateUrl: 'uib/template/progressbar/progressbar.html',
        link: function link(scope, element, attrs, progressCtrl) {
          progressCtrl.addBar(scope, angular.element(element.children()[0]), { title: attrs.title });
        }
      };
    });

    angular.module('ui.bootstrap.rating', []).constant('uibRatingConfig', {
      max: 5,
      stateOn: null,
      stateOff: null,
      enableReset: true,
      titles: ['one', 'two', 'three', 'four', 'five']
    }).controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function ($scope, $attrs, ratingConfig) {
      var ngModelCtrl = { $setViewValue: angular.noop },
          self = this;

      this.init = function (ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;

        ngModelCtrl.$formatters.push(function (value) {
          if (angular.isNumber(value) && value << 0 !== value) {
            value = Math.round(value);
          }

          return value;
        });

        this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
        this.enableReset = angular.isDefined($attrs.enableReset) ? $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
        var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
        this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ? tmpTitles : ratingConfig.titles;

        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
      };

      this.buildTemplateObjects = function (states) {
        for (var i = 0, n = states.length; i < n; i++) {
          states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
        }
        return states;
      };

      this.getTitle = function (index) {
        if (index >= this.titles.length) {
          return index + 1;
        }

        return this.titles[index];
      };

      $scope.rate = function (value) {
        if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
          var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
          ngModelCtrl.$setViewValue(newViewValue);
          ngModelCtrl.$render();
        }
      };

      $scope.enter = function (value) {
        if (!$scope.readonly) {
          $scope.value = value;
        }
        $scope.onHover({ value: value });
      };

      $scope.reset = function () {
        $scope.value = ngModelCtrl.$viewValue;
        $scope.onLeave();
      };

      $scope.onKeydown = function (evt) {
        if (/(37|38|39|40)/.test(evt.which)) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
        }
      };

      this.render = function () {
        $scope.value = ngModelCtrl.$viewValue;
        $scope.title = self.getTitle($scope.value - 1);
      };
    }]).directive('uibRating', function () {
      return {
        require: ['uibRating', 'ngModel'],
        restrict: 'A',
        scope: {
          readonly: '=?readOnly',
          onHover: '&',
          onLeave: '&'
        },
        controller: 'UibRatingController',
        templateUrl: 'uib/template/rating/rating.html',
        link: function link(scope, element, attrs, ctrls) {
          var ratingCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          ratingCtrl.init(ngModelCtrl);
        }
      };
    });

    angular.module('ui.bootstrap.tabs', []).controller('UibTabsetController', ['$scope', function ($scope) {
      var ctrl = this,
          oldIndex;
      ctrl.tabs = [];

      ctrl.select = function (index, evt) {
        if (!destroyed) {
          var previousIndex = findTabIndex(oldIndex);
          var previousSelected = ctrl.tabs[previousIndex];
          if (previousSelected) {
            previousSelected.tab.onDeselect({
              $event: evt,
              $selectedIndex: index
            });
            if (evt && evt.isDefaultPrevented()) {
              return;
            }
            previousSelected.tab.active = false;
          }

          var selected = ctrl.tabs[index];
          if (selected) {
            selected.tab.onSelect({
              $event: evt
            });
            selected.tab.active = true;
            ctrl.active = selected.index;
            oldIndex = selected.index;
          } else if (!selected && angular.isDefined(oldIndex)) {
            ctrl.active = null;
            oldIndex = null;
          }
        }
      };

      ctrl.addTab = function addTab(tab) {
        ctrl.tabs.push({
          tab: tab,
          index: tab.index
        });
        ctrl.tabs.sort(function (t1, t2) {
          if (t1.index > t2.index) {
            return 1;
          }

          if (t1.index < t2.index) {
            return -1;
          }

          return 0;
        });

        if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {
          var newActiveIndex = findTabIndex(tab.index);
          ctrl.select(newActiveIndex);
        }
      };

      ctrl.removeTab = function removeTab(tab) {
        var index;
        for (var i = 0; i < ctrl.tabs.length; i++) {
          if (ctrl.tabs[i].tab === tab) {
            index = i;
            break;
          }
        }

        if (ctrl.tabs[index].index === ctrl.active) {
          var newActiveTabIndex = index === ctrl.tabs.length - 1 ? index - 1 : index + 1 % ctrl.tabs.length;
          ctrl.select(newActiveTabIndex);
        }

        ctrl.tabs.splice(index, 1);
      };

      $scope.$watch('tabset.active', function (val) {
        if (angular.isDefined(val) && val !== oldIndex) {
          ctrl.select(findTabIndex(val));
        }
      });

      var destroyed;
      $scope.$on('$destroy', function () {
        destroyed = true;
      });

      function findTabIndex(index) {
        for (var i = 0; i < ctrl.tabs.length; i++) {
          if (ctrl.tabs[i].index === index) {
            return i;
          }
        }
      }
    }]).directive('uibTabset', function () {
      return {
        transclude: true,
        replace: true,
        scope: {},
        bindToController: {
          active: '=?',
          type: '@'
        },
        controller: 'UibTabsetController',
        controllerAs: 'tabset',
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/tabs/tabset.html';
        },
        link: function link(scope, element, attrs) {
          scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
          scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
        }
      };
    }).directive('uibTab', ['$parse', function ($parse) {
      return {
        require: '^uibTabset',
        replace: true,
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || 'uib/template/tabs/tab.html';
        },
        transclude: true,
        scope: {
          heading: '@',
          index: '=?',
          classes: '@?',
          onSelect: '&select', //This callback is called in contentHeadingTransclude
          //once it inserts the tab's content into the dom
          onDeselect: '&deselect'
        },
        controller: function controller() {
          //Empty controller so other directives can require being 'under' a tab
        },
        controllerAs: 'tab',
        link: function link(scope, elm, attrs, tabsetCtrl, transclude) {
          scope.disabled = false;
          if (attrs.disable) {
            scope.$parent.$watch($parse(attrs.disable), function (value) {
              scope.disabled = !!value;
            });
          }

          if (angular.isUndefined(attrs.index)) {
            if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
              scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function (t) {
                return t.index;
              })) + 1;
            } else {
              scope.index = 0;
            }
          }

          if (angular.isUndefined(attrs.classes)) {
            scope.classes = '';
          }

          scope.select = function (evt) {
            if (!scope.disabled) {
              var index;
              for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
                if (tabsetCtrl.tabs[i].tab === scope) {
                  index = i;
                  break;
                }
              }

              tabsetCtrl.select(index, evt);
            }
          };

          tabsetCtrl.addTab(scope);
          scope.$on('$destroy', function () {
            tabsetCtrl.removeTab(scope);
          });

          //We need to transclude later, once the content container is ready.
          //when this link happens, we're inside a tab heading.
          scope.$transcludeFn = transclude;
        }
      };
    }]).directive('uibTabHeadingTransclude', function () {
      return {
        restrict: 'A',
        require: '^uibTab',
        link: function link(scope, elm) {
          scope.$watch('headingElement', function updateHeadingElement(heading) {
            if (heading) {
              elm.html('');
              elm.append(heading);
            }
          });
        }
      };
    }).directive('uibTabContentTransclude', function () {
      return {
        restrict: 'A',
        require: '^uibTabset',
        link: function link(scope, elm, attrs) {
          var tab = scope.$eval(attrs.uibTabContentTransclude).tab;

          //Now our tab is ready to be transcluded: both the tab heading area
          //and the tab content area are loaded.  Transclude 'em both.
          tab.$transcludeFn(tab.$parent, function (contents) {
            angular.forEach(contents, function (node) {
              if (isTabHeading(node)) {
                //Let tabHeadingTransclude know.
                tab.headingElement = node;
              } else {
                elm.append(node);
              }
            });
          });
        }
      };

      function isTabHeading(node) {
        return node.tagName && (node.hasAttribute('uib-tab-heading') || node.hasAttribute('data-uib-tab-heading') || node.hasAttribute('x-uib-tab-heading') || node.tagName.toLowerCase() === 'uib-tab-heading' || node.tagName.toLowerCase() === 'data-uib-tab-heading' || node.tagName.toLowerCase() === 'x-uib-tab-heading' || node.tagName.toLowerCase() === 'uib:tab-heading');
      }
    });

    angular.module('ui.bootstrap.timepicker', []).constant('uibTimepickerConfig', {
      hourStep: 1,
      minuteStep: 1,
      secondStep: 1,
      showMeridian: true,
      showSeconds: false,
      meridians: null,
      readonlyInput: false,
      mousewheel: true,
      arrowkeys: true,
      showSpinners: true,
      templateUrl: 'uib/template/timepicker/timepicker.html'
    }).controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function ($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
      var hoursModelCtrl, minutesModelCtrl, secondsModelCtrl;
      var selected = new Date(),
          watchers = [],
          ngModelCtrl = { $setViewValue: angular.noop },
          // nullModelCtrl
      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
          padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;

      $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
      $element.removeAttr('tabindex');

      this.init = function (ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;

        ngModelCtrl.$formatters.unshift(function (modelValue) {
          return modelValue ? new Date(modelValue) : null;
        });

        var hoursInputEl = inputs.eq(0),
            minutesInputEl = inputs.eq(1),
            secondsInputEl = inputs.eq(2);

        hoursModelCtrl = hoursInputEl.controller('ngModel');
        minutesModelCtrl = minutesInputEl.controller('ngModel');
        secondsModelCtrl = secondsInputEl.controller('ngModel');

        var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;

        if (mousewheel) {
          this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        }

        var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
        if (arrowkeys) {
          this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        }

        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
        this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
      };

      var hourStep = timepickerConfig.hourStep;
      if ($attrs.hourStep) {
        watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function (value) {
          hourStep = +value;
        }));
      }

      var minuteStep = timepickerConfig.minuteStep;
      if ($attrs.minuteStep) {
        watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function (value) {
          minuteStep = +value;
        }));
      }

      var min;
      watchers.push($scope.$parent.$watch($parse($attrs.min), function (value) {
        var dt = new Date(value);
        min = isNaN(dt) ? undefined : dt;
      }));

      var max;
      watchers.push($scope.$parent.$watch($parse($attrs.max), function (value) {
        var dt = new Date(value);
        max = isNaN(dt) ? undefined : dt;
      }));

      var disabled = false;
      if ($attrs.ngDisabled) {
        watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function (value) {
          disabled = value;
        }));
      }

      $scope.noIncrementHours = function () {
        var incrementedSelected = addMinutes(selected, hourStep * 60);
        return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
      };

      $scope.noDecrementHours = function () {
        var decrementedSelected = addMinutes(selected, -hourStep * 60);
        return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
      };

      $scope.noIncrementMinutes = function () {
        var incrementedSelected = addMinutes(selected, minuteStep);
        return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
      };

      $scope.noDecrementMinutes = function () {
        var decrementedSelected = addMinutes(selected, -minuteStep);
        return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
      };

      $scope.noIncrementSeconds = function () {
        var incrementedSelected = addSeconds(selected, secondStep);
        return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
      };

      $scope.noDecrementSeconds = function () {
        var decrementedSelected = addSeconds(selected, -secondStep);
        return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
      };

      $scope.noToggleMeridian = function () {
        if (selected.getHours() < 12) {
          return disabled || addMinutes(selected, 12 * 60) > max;
        }

        return disabled || addMinutes(selected, -12 * 60) < min;
      };

      var secondStep = timepickerConfig.secondStep;
      if ($attrs.secondStep) {
        watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function (value) {
          secondStep = +value;
        }));
      }

      $scope.showSeconds = timepickerConfig.showSeconds;
      if ($attrs.showSeconds) {
        watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function (value) {
          $scope.showSeconds = !!value;
        }));
      }

      // 12H / 24H mode
      $scope.showMeridian = timepickerConfig.showMeridian;
      if ($attrs.showMeridian) {
        watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function (value) {
          $scope.showMeridian = !!value;

          if (ngModelCtrl.$error.time) {
            // Evaluate from template
            var hours = getHoursFromTemplate(),
                minutes = getMinutesFromTemplate();
            if (angular.isDefined(hours) && angular.isDefined(minutes)) {
              selected.setHours(hours);
              refresh();
            }
          } else {
            updateTemplate();
          }
        }));
      }

      // Get $scope.hours in 24H mode if valid
      function getHoursFromTemplate() {
        var hours = +$scope.hours;
        var valid = $scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24;
        if (!valid || $scope.hours === '') {
          return undefined;
        }

        if ($scope.showMeridian) {
          if (hours === 12) {
            hours = 0;
          }
          if ($scope.meridian === meridians[1]) {
            hours = hours + 12;
          }
        }
        return hours;
      }

      function getMinutesFromTemplate() {
        var minutes = +$scope.minutes;
        var valid = minutes >= 0 && minutes < 60;
        if (!valid || $scope.minutes === '') {
          return undefined;
        }
        return minutes;
      }

      function getSecondsFromTemplate() {
        var seconds = +$scope.seconds;
        return seconds >= 0 && seconds < 60 ? seconds : undefined;
      }

      function pad(value, noPad) {
        if (value === null) {
          return '';
        }

        return angular.isDefined(value) && value.toString().length < 2 && !noPad ? '0' + value : value.toString();
      }

      // Respond on mousewheel spin
      this.setupMousewheelEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
        var isScrollingUp = function isScrollingUp(e) {
          if (e.originalEvent) {
            e = e.originalEvent;
          }
          //pick correct delta variable depending on event
          var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
          return e.detail || delta > 0;
        };

        hoursInputEl.bind('mousewheel wheel', function (e) {
          if (!disabled) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
          }
          e.preventDefault();
        });

        minutesInputEl.bind('mousewheel wheel', function (e) {
          if (!disabled) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
          }
          e.preventDefault();
        });

        secondsInputEl.bind('mousewheel wheel', function (e) {
          if (!disabled) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
          }
          e.preventDefault();
        });
      };

      // Respond on up/down arrowkeys
      this.setupArrowkeyEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
        hoursInputEl.bind('keydown', function (e) {
          if (!disabled) {
            if (e.which === 38) {
              // up
              e.preventDefault();
              $scope.incrementHours();
              $scope.$apply();
            } else if (e.which === 40) {
              // down
              e.preventDefault();
              $scope.decrementHours();
              $scope.$apply();
            }
          }
        });

        minutesInputEl.bind('keydown', function (e) {
          if (!disabled) {
            if (e.which === 38) {
              // up
              e.preventDefault();
              $scope.incrementMinutes();
              $scope.$apply();
            } else if (e.which === 40) {
              // down
              e.preventDefault();
              $scope.decrementMinutes();
              $scope.$apply();
            }
          }
        });

        secondsInputEl.bind('keydown', function (e) {
          if (!disabled) {
            if (e.which === 38) {
              // up
              e.preventDefault();
              $scope.incrementSeconds();
              $scope.$apply();
            } else if (e.which === 40) {
              // down
              e.preventDefault();
              $scope.decrementSeconds();
              $scope.$apply();
            }
          }
        });
      };

      this.setupInputEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
        if ($scope.readonlyInput) {
          $scope.updateHours = angular.noop;
          $scope.updateMinutes = angular.noop;
          $scope.updateSeconds = angular.noop;
          return;
        }

        var invalidate = function invalidate(invalidHours, invalidMinutes, invalidSeconds) {
          ngModelCtrl.$setViewValue(null);
          ngModelCtrl.$setValidity('time', false);
          if (angular.isDefined(invalidHours)) {
            $scope.invalidHours = invalidHours;
            if (hoursModelCtrl) {
              hoursModelCtrl.$setValidity('hours', false);
            }
          }

          if (angular.isDefined(invalidMinutes)) {
            $scope.invalidMinutes = invalidMinutes;
            if (minutesModelCtrl) {
              minutesModelCtrl.$setValidity('minutes', false);
            }
          }

          if (angular.isDefined(invalidSeconds)) {
            $scope.invalidSeconds = invalidSeconds;
            if (secondsModelCtrl) {
              secondsModelCtrl.$setValidity('seconds', false);
            }
          }
        };

        $scope.updateHours = function () {
          var hours = getHoursFromTemplate(),
              minutes = getMinutesFromTemplate();

          ngModelCtrl.$setDirty();

          if (angular.isDefined(hours) && angular.isDefined(minutes)) {
            selected.setHours(hours);
            selected.setMinutes(minutes);
            if (selected < min || selected > max) {
              invalidate(true);
            } else {
              refresh('h');
            }
          } else {
            invalidate(true);
          }
        };

        hoursInputEl.bind('blur', function (e) {
          ngModelCtrl.$setTouched();
          if (modelIsEmpty()) {
            makeValid();
          } else if ($scope.hours === null || $scope.hours === '') {
            invalidate(true);
          } else if (!$scope.invalidHours && $scope.hours < 10) {
            $scope.$apply(function () {
              $scope.hours = pad($scope.hours, !padHours);
            });
          }
        });

        $scope.updateMinutes = function () {
          var minutes = getMinutesFromTemplate(),
              hours = getHoursFromTemplate();

          ngModelCtrl.$setDirty();

          if (angular.isDefined(minutes) && angular.isDefined(hours)) {
            selected.setHours(hours);
            selected.setMinutes(minutes);
            if (selected < min || selected > max) {
              invalidate(undefined, true);
            } else {
              refresh('m');
            }
          } else {
            invalidate(undefined, true);
          }
        };

        minutesInputEl.bind('blur', function (e) {
          ngModelCtrl.$setTouched();
          if (modelIsEmpty()) {
            makeValid();
          } else if ($scope.minutes === null) {
            invalidate(undefined, true);
          } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
            $scope.$apply(function () {
              $scope.minutes = pad($scope.minutes);
            });
          }
        });

        $scope.updateSeconds = function () {
          var seconds = getSecondsFromTemplate();

          ngModelCtrl.$setDirty();

          if (angular.isDefined(seconds)) {
            selected.setSeconds(seconds);
            refresh('s');
          } else {
            invalidate(undefined, undefined, true);
          }
        };

        secondsInputEl.bind('blur', function (e) {
          if (modelIsEmpty()) {
            makeValid();
          } else if (!$scope.invalidSeconds && $scope.seconds < 10) {
            $scope.$apply(function () {
              $scope.seconds = pad($scope.seconds);
            });
          }
        });
      };

      this.render = function () {
        var date = ngModelCtrl.$viewValue;

        if (isNaN(date)) {
          ngModelCtrl.$setValidity('time', false);
          $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
        } else {
          if (date) {
            selected = date;
          }

          if (selected < min || selected > max) {
            ngModelCtrl.$setValidity('time', false);
            $scope.invalidHours = true;
            $scope.invalidMinutes = true;
          } else {
            makeValid();
          }
          updateTemplate();
        }
      };

      // Call internally when we know that model is valid.
      function refresh(keyboardChange) {
        makeValid();
        ngModelCtrl.$setViewValue(new Date(selected));
        updateTemplate(keyboardChange);
      }

      function makeValid() {
        if (hoursModelCtrl) {
          hoursModelCtrl.$setValidity('hours', true);
        }

        if (minutesModelCtrl) {
          minutesModelCtrl.$setValidity('minutes', true);
        }

        if (secondsModelCtrl) {
          secondsModelCtrl.$setValidity('seconds', true);
        }

        ngModelCtrl.$setValidity('time', true);
        $scope.invalidHours = false;
        $scope.invalidMinutes = false;
        $scope.invalidSeconds = false;
      }

      function updateTemplate(keyboardChange) {
        if (!ngModelCtrl.$modelValue) {
          $scope.hours = null;
          $scope.minutes = null;
          $scope.seconds = null;
          $scope.meridian = meridians[0];
        } else {
          var hours = selected.getHours(),
              minutes = selected.getMinutes(),
              seconds = selected.getSeconds();

          if ($scope.showMeridian) {
            hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system
          }

          $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
          if (keyboardChange !== 'm') {
            $scope.minutes = pad(minutes);
          }
          $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];

          if (keyboardChange !== 's') {
            $scope.seconds = pad(seconds);
          }
          $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
        }
      }

      function addSecondsToSelected(seconds) {
        selected = addSeconds(selected, seconds);
        refresh();
      }

      function addMinutes(selected, minutes) {
        return addSeconds(selected, minutes * 60);
      }

      function addSeconds(date, seconds) {
        var dt = new Date(date.getTime() + seconds * 1000);
        var newDate = new Date(date);
        newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
        return newDate;
      }

      function modelIsEmpty() {
        return ($scope.hours === null || $scope.hours === '') && ($scope.minutes === null || $scope.minutes === '') && (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
      }

      $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

      $scope.incrementHours = function () {
        if (!$scope.noIncrementHours()) {
          addSecondsToSelected(hourStep * 60 * 60);
        }
      };

      $scope.decrementHours = function () {
        if (!$scope.noDecrementHours()) {
          addSecondsToSelected(-hourStep * 60 * 60);
        }
      };

      $scope.incrementMinutes = function () {
        if (!$scope.noIncrementMinutes()) {
          addSecondsToSelected(minuteStep * 60);
        }
      };

      $scope.decrementMinutes = function () {
        if (!$scope.noDecrementMinutes()) {
          addSecondsToSelected(-minuteStep * 60);
        }
      };

      $scope.incrementSeconds = function () {
        if (!$scope.noIncrementSeconds()) {
          addSecondsToSelected(secondStep);
        }
      };

      $scope.decrementSeconds = function () {
        if (!$scope.noDecrementSeconds()) {
          addSecondsToSelected(-secondStep);
        }
      };

      $scope.toggleMeridian = function () {
        var minutes = getMinutesFromTemplate(),
            hours = getHoursFromTemplate();

        if (!$scope.noToggleMeridian()) {
          if (angular.isDefined(minutes) && angular.isDefined(hours)) {
            addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
          } else {
            $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
          }
        }
      };

      $scope.blur = function () {
        ngModelCtrl.$setTouched();
      };

      $scope.$on('$destroy', function () {
        while (watchers.length) {
          watchers.shift()();
        }
      });
    }]).directive('uibTimepicker', ['uibTimepickerConfig', function (uibTimepickerConfig) {
      return {
        require: ['uibTimepicker', '?^ngModel'],
        restrict: 'A',
        controller: 'UibTimepickerController',
        controllerAs: 'timepicker',
        scope: {},
        templateUrl: function templateUrl(element, attrs) {
          return attrs.templateUrl || uibTimepickerConfig.templateUrl;
        },
        link: function link(scope, element, attrs, ctrls) {
          var timepickerCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];

          if (ngModelCtrl) {
            timepickerCtrl.init(ngModelCtrl, element.find('input'));
          }
        }
      };
    }]);

    angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])

    /**
     * A helper service that can parse typeahead's syntax (string provided by users)
     * Extracted to a separate service for ease of unit testing
     */
    .factory('uibTypeaheadParser', ['$parse', function ($parse) {
      //                      000001111111100000000000002222222200000000000000003333333333333330000000000044444444000
      var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
      return {
        parse: function parse(input) {
          var match = input.match(TYPEAHEAD_REGEXP);
          if (!match) {
            throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' + ' but got "' + input + '".');
          }

          return {
            itemName: match[3],
            source: $parse(match[4]),
            viewMapper: $parse(match[2] || match[1]),
            modelMapper: $parse(match[1])
          };
        }
      };
    }]).controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser', function (originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
      var HOT_KEYS = [9, 13, 27, 38, 40];
      var eventDebounceTime = 200;
      var modelCtrl, ngModelOptions;
      //SUPPORTED ATTRIBUTES (OPTIONS)

      //minimal no of characters that needs to be entered before typeahead kicks-in
      var minLength = originalScope.$eval(attrs.typeaheadMinLength);
      if (!minLength && minLength !== 0) {
        minLength = 1;
      }

      originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
        minLength = !newVal && newVal !== 0 ? 1 : newVal;
      });

      //minimal wait time after last character typed before typeahead kicks-in
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

      //should it restrict model values to the ones selected from the popup only?
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
      originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
        isEditable = newVal !== false;
      });

      //binding to a variable that indicates if matches are being retrieved asynchronously
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

      //a function to determine if an event should cause selection
      var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function (scope, vals) {
        var evt = vals.$event;
        return evt.which === 13 || evt.which === 9;
      };

      //a callback executed when a match is selected
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);

      //should it select highlighted popup value when losing focus?
      var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

      //binding to a variable that indicates if there were no results after the query is completed
      var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

      var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

      var appendTo = attrs.typeaheadAppendTo ? originalScope.$eval(attrs.typeaheadAppendTo) : null;

      var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

      //If input matches an item of the list exactly, select it automatically
      var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

      //binding to a variable that indicates if dropdown is open
      var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;

      var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;

      //INTERNAL VARIABLES

      //model setter executed upon match selection
      var parsedModel = $parse(attrs.ngModel);
      var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
      var $setModelValue = function $setModelValue(scope, newValue) {
        if (angular.isFunction(parsedModel(originalScope)) && ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
          return invokeModelSetter(scope, { $$$p: newValue });
        }

        return parsedModel.assign(scope, newValue);
      };

      //expressions used by typeahead
      var parserResult = typeaheadParser.parse(attrs.uibTypeahead);

      var hasFocus;

      //Used to avoid bug in iOS webview where iOS keyboard does not fire
      //mousedown & mouseup events
      //Issue #3699
      var selected;

      //create a child scope for the typeahead directive so we are not polluting original scope
      //with typeahead-specific data (matches, query etc.)
      var scope = originalScope.$new();
      var offDestroy = originalScope.$on('$destroy', function () {
        scope.$destroy();
      });
      scope.$on('$destroy', offDestroy);

      // WAI-ARIA
      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      element.attr({
        'aria-autocomplete': 'list',
        'aria-expanded': false,
        'aria-owns': popupId
      });

      var inputsContainer, hintInputElem;
      //add read-only input to show hint
      if (showHint) {
        inputsContainer = angular.element('<div></div>');
        inputsContainer.css('position', 'relative');
        element.after(inputsContainer);
        hintInputElem = element.clone();
        hintInputElem.attr('placeholder', '');
        hintInputElem.attr('tabindex', '-1');
        hintInputElem.val('');
        hintInputElem.css({
          'position': 'absolute',
          'top': '0px',
          'left': '0px',
          'border-color': 'transparent',
          'box-shadow': 'none',
          'opacity': 1,
          'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
          'color': '#999'
        });
        element.css({
          'position': 'relative',
          'vertical-align': 'top',
          'background-color': 'transparent'
        });

        if (hintInputElem.attr('id')) {
          hintInputElem.removeAttr('id'); // remove duplicate id if present.
        }
        inputsContainer.append(hintInputElem);
        hintInputElem.after(element);
      }

      //pop-up element used to display matches
      var popUpEl = angular.element('<div uib-typeahead-popup></div>');
      popUpEl.attr({
        id: popupId,
        matches: 'matches',
        active: 'activeIdx',
        select: 'select(activeIdx, evt)',
        'move-in-progress': 'moveInProgress',
        query: 'query',
        position: 'position',
        'assign-is-open': 'assignIsOpen(isOpen)',
        debounce: 'debounceUpdate'
      });
      //custom item template
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
      }

      if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
        popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
      }

      var resetHint = function resetHint() {
        if (showHint) {
          hintInputElem.val('');
        }
      };

      var resetMatches = function resetMatches() {
        scope.matches = [];
        scope.activeIdx = -1;
        element.attr('aria-expanded', false);
        resetHint();
      };

      var getMatchId = function getMatchId(index) {
        return popupId + '-option-' + index;
      };

      // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
      // This attribute is added or removed automatically when the `activeIdx` changes.
      scope.$watch('activeIdx', function (index) {
        if (index < 0) {
          element.removeAttr('aria-activedescendant');
        } else {
          element.attr('aria-activedescendant', getMatchId(index));
        }
      });

      var inputIsExactMatch = function inputIsExactMatch(inputValue, index) {
        if (scope.matches.length > index && inputValue) {
          return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
        }

        return false;
      };

      var getMatchesAsync = function getMatchesAsync(inputValue, evt) {
        var locals = { $viewValue: inputValue };
        isLoadingSetter(originalScope, true);
        isNoResultsSetter(originalScope, false);
        $q.when(parserResult.source(originalScope, locals)).then(function (matches) {
          //it might happen that several async queries were in progress if a user were typing fast
          //but we are interested only in responses that correspond to the current view value
          var onCurrentRequest = inputValue === modelCtrl.$viewValue;
          if (onCurrentRequest && hasFocus) {
            if (matches && matches.length > 0) {
              scope.activeIdx = focusFirst ? 0 : -1;
              isNoResultsSetter(originalScope, false);
              scope.matches.length = 0;

              //transform labels
              for (var i = 0; i < matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  id: getMatchId(i),
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }

              scope.query = inputValue;
              //position pop-up with matches - we need to re-calculate its position each time we are opening a window
              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
              //due to other elements being rendered
              recalculatePosition();

              element.attr('aria-expanded', true);

              //Select the single remaining option if user input matches
              if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                  $$debounce(function () {
                    scope.select(0, evt);
                  }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                } else {
                  scope.select(0, evt);
                }
              }

              if (showHint) {
                var firstLabel = scope.matches[0].label;
                if (angular.isString(inputValue) && inputValue.length > 0 && firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                  hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
                } else {
                  hintInputElem.val('');
                }
              }
            } else {
              resetMatches();
              isNoResultsSetter(originalScope, true);
            }
          }
          if (onCurrentRequest) {
            isLoadingSetter(originalScope, false);
          }
        }, function () {
          resetMatches();
          isLoadingSetter(originalScope, false);
          isNoResultsSetter(originalScope, true);
        });
      };

      // bind events only if appendToBody params exist - performance feature
      if (appendToBody) {
        angular.element($window).on('resize', fireRecalculating);
        $document.find('body').on('scroll', fireRecalculating);
      }

      // Declare the debounced function outside recalculating for
      // proper debouncing
      var debouncedRecalculate = $$debounce(function () {
        // if popup is visible
        if (scope.matches.length) {
          recalculatePosition();
        }

        scope.moveInProgress = false;
      }, eventDebounceTime);

      // Default progress type
      scope.moveInProgress = false;

      function fireRecalculating() {
        if (!scope.moveInProgress) {
          scope.moveInProgress = true;
          scope.$digest();
        }

        debouncedRecalculate();
      }

      // recalculate actual position and set new values to scope
      // after digest loop is popup in right position
      function recalculatePosition() {
        scope.position = appendToBody ? $position.offset(element) : $position.position(element);
        scope.position.top += element.prop('offsetHeight');
      }

      //we need to propagate user's query so we can higlight matches
      scope.query = undefined;

      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
      var timeoutPromise;

      var scheduleSearchWithTimeout = function scheduleSearchWithTimeout(inputValue) {
        timeoutPromise = $timeout(function () {
          getMatchesAsync(inputValue);
        }, waitTime);
      };

      var cancelPreviousTimeout = function cancelPreviousTimeout() {
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
      };

      resetMatches();

      scope.assignIsOpen = function (isOpen) {
        isOpenSetter(originalScope, isOpen);
      };

      scope.select = function (activeIdx, evt) {
        //called from within the $digest() cycle
        var locals = {};
        var model, item;

        selected = true;
        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity('editable', true);
        modelCtrl.$setValidity('parse', true);

        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals),
          $event: evt
        });

        resetMatches();

        //return focus to the input element if a match was selected via a mouse click event
        // use timeout to avoid $rootScope:inprog error
        if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
          $timeout(function () {
            element[0].focus();
          }, 0, false);
        }
      };

      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
      element.on('keydown', function (evt) {
        //typeahead is open and an "interesting" key was pressed
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }

        var shouldSelect = isSelectEvent(originalScope, { $event: evt });

        /**
         * if there's nothing selected (i.e. focusFirst) and enter or tab is hit
         * or
         * shift + tab is pressed to bring focus to the previous element
         * then clear the results
         */
        if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {
          resetMatches();
          scope.$digest();
          return;
        }

        evt.preventDefault();
        var target;
        switch (evt.which) {
          case 27:
            // escape
            evt.stopPropagation();

            resetMatches();
            originalScope.$digest();
            break;
          case 38:
            // up arrow
            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
            scope.$digest();
            target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
            target.parentNode.scrollTop = target.offsetTop;
            break;
          case 40:
            // down arrow
            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
            scope.$digest();
            target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
            target.parentNode.scrollTop = target.offsetTop;
            break;
          default:
            if (shouldSelect) {
              scope.$apply(function () {
                if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                  $$debounce(function () {
                    scope.select(scope.activeIdx, evt);
                  }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                } else {
                  scope.select(scope.activeIdx, evt);
                }
              });
            }
        }
      });

      element.bind('focus', function (evt) {
        hasFocus = true;
        if (minLength === 0 && !modelCtrl.$viewValue) {
          $timeout(function () {
            getMatchesAsync(modelCtrl.$viewValue, evt);
          }, 0);
        }
      });

      element.bind('blur', function (evt) {
        if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
          selected = true;
          scope.$apply(function () {
            if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
              $$debounce(function () {
                scope.select(scope.activeIdx, evt);
              }, scope.debounceUpdate.blur);
            } else {
              scope.select(scope.activeIdx, evt);
            }
          });
        }
        if (!isEditable && modelCtrl.$error.editable) {
          modelCtrl.$setViewValue();
          scope.$apply(function () {
            // Reset validity as we are clearing
            modelCtrl.$setValidity('editable', true);
            modelCtrl.$setValidity('parse', true);
          });
          element.val('');
        }
        hasFocus = false;
        selected = false;
      });

      // Keep reference to click handler to unbind it.
      var dismissClickHandler = function dismissClickHandler(evt) {
        // Issue #3973
        // Firefox treats right click as a click on document
        if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
          resetMatches();
          if (!$rootScope.$$phase) {
            originalScope.$digest();
          }
        }
      };

      $document.on('click', dismissClickHandler);

      originalScope.$on('$destroy', function () {
        $document.off('click', dismissClickHandler);
        if (appendToBody || appendTo) {
          $popup.remove();
        }

        if (appendToBody) {
          angular.element($window).off('resize', fireRecalculating);
          $document.find('body').off('scroll', fireRecalculating);
        }
        // Prevent jQuery cache memory leak
        popUpEl.remove();

        if (showHint) {
          inputsContainer.remove();
        }
      });

      var $popup = $compile(popUpEl)(scope);

      if (appendToBody) {
        $document.find('body').append($popup);
      } else if (appendTo) {
        angular.element(appendTo).eq(0).append($popup);
      } else {
        element.after($popup);
      }

      this.init = function (_modelCtrl, _ngModelOptions) {
        modelCtrl = _modelCtrl;
        ngModelOptions = _ngModelOptions;

        scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);

        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
        modelCtrl.$parsers.unshift(function (inputValue) {
          hasFocus = true;

          if (minLength === 0 || inputValue && inputValue.length >= minLength) {
            if (waitTime > 0) {
              cancelPreviousTimeout();
              scheduleSearchWithTimeout(inputValue);
            } else {
              getMatchesAsync(inputValue);
            }
          } else {
            isLoadingSetter(originalScope, false);
            cancelPreviousTimeout();
            resetMatches();
          }

          if (isEditable) {
            return inputValue;
          }

          if (!inputValue) {
            // Reset in case user had typed something previously.
            modelCtrl.$setValidity('editable', true);
            return null;
          }

          modelCtrl.$setValidity('editable', false);
          return undefined;
        });

        modelCtrl.$formatters.push(function (modelValue) {
          var candidateViewValue, emptyViewValue;
          var locals = {};

          // The validity may be set to false via $parsers (see above) if
          // the model is restricted to selected values. If the model
          // is set manually it is considered to be valid.
          if (!isEditable) {
            modelCtrl.$setValidity('editable', true);
          }

          if (inputFormatter) {
            locals.$model = modelValue;
            return inputFormatter(originalScope, locals);
          }

          //it might happen that we don't have enough info to properly render input value
          //we need to check for this situation and simply return model value if we can't apply custom formatting
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);

          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
        });
      };
    }]).directive('uibTypeahead', function () {
      return {
        controller: 'UibTypeaheadController',
        require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
        link: function link(originalScope, element, attrs, ctrls) {
          ctrls[2].init(ctrls[0], ctrls[1]);
        }
      };
    }).directive('uibTypeaheadPopup', ['$$debounce', function ($$debounce) {
      return {
        scope: {
          matches: '=',
          query: '=',
          active: '=',
          position: '&',
          moveInProgress: '=',
          select: '&',
          assignIsOpen: '&',
          debounce: '&'
        },
        replace: true,
        templateUrl: function templateUrl(element, attrs) {
          return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
        },
        link: function link(scope, element, attrs) {
          scope.templateUrl = attrs.templateUrl;

          scope.isOpen = function () {
            var isDropdownOpen = scope.matches.length > 0;
            scope.assignIsOpen({ isOpen: isDropdownOpen });
            return isDropdownOpen;
          };

          scope.isActive = function (matchIdx) {
            return scope.active === matchIdx;
          };

          scope.selectActive = function (matchIdx) {
            scope.active = matchIdx;
          };

          scope.selectMatch = function (activeIdx, evt) {
            var debounce = scope.debounce();
            if (angular.isNumber(debounce) || angular.isObject(debounce)) {
              $$debounce(function () {
                scope.select({ activeIdx: activeIdx, evt: evt });
              }, angular.isNumber(debounce) ? debounce : debounce['default']);
            } else {
              scope.select({ activeIdx: activeIdx, evt: evt });
            }
          };
        }
      };
    }]).directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function ($templateRequest, $compile, $parse) {
      return {
        scope: {
          index: '=',
          match: '=',
          query: '='
        },
        link: function link(scope, element, attrs) {
          var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
          $templateRequest(tplUrl).then(function (tplContent) {
            var tplEl = angular.element(tplContent.trim());
            element.replaceWith(tplEl);
            $compile(tplEl)(scope);
          });
        }
      };
    }]).filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function ($sce, $injector, $log) {
      var isSanitizePresent;
      isSanitizePresent = $injector.has('$sanitize');

      function escapeRegexp(queryToEscape) {
        // Regex: capture the whole query string and replace it with the string that will be used to match
        // the results, for example if the capture is "a" the result will be \a
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      }

      function containsHtml(matchItem) {
        return (/<.*>/g.test(matchItem)
        );
      }

      return function (matchItem, query) {
        if (!isSanitizePresent && containsHtml(matchItem)) {
          $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
        }
        matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
        if (!isSanitizePresent) {
          matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
        }
        return matchItem;
      };
    }]);

    angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/accordion/accordion-group.html", "<div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" + "  <h4 class=\"panel-title\">\n" + "    <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\" ng-disabled=\"isDisabled\" uib-tabindex-toggle><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" + "  </h4>\n" + "</div>\n" + "<div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" + "  <div class=\"panel-body\" ng-transclude></div>\n" + "</div>\n" + "");
    }]);

    angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/accordion/accordion.html", "<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
    }]);

    angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/alert/alert.html", "<button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" + "  <span aria-hidden=\"true\">&times;</span>\n" + "  <span class=\"sr-only\">Close</span>\n" + "</button>\n" + "<div ng-transclude></div>\n" + "");
    }]);

    angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/carousel/carousel.html", "<div class=\"carousel-inner\" ng-transclude></div>\n" + "<a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\n" + "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" + "  <span class=\"sr-only\">previous</span>\n" + "</a>\n" + "<a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\n" + "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" + "  <span class=\"sr-only\">next</span>\n" + "</a>\n" + "<ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" + "  <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" + "    <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" + "  </li>\n" + "</ol>\n" + "");
    }]);

    angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/carousel/slide.html", "<div class=\"text-center\" ng-transclude></div>\n" + "");
    }]);

    angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/datepicker/datepicker.html", "<div ng-switch=\"datepickerMode\">\n" + "  <div uib-daypicker ng-switch-when=\"day\" tabindex=\"0\" class=\"uib-daypicker\"></div>\n" + "  <div uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\" class=\"uib-monthpicker\"></div>\n" + "  <div uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\" class=\"uib-yearpicker\"></div>\n" + "</div>\n" + "");
    }]);

    angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/datepicker/day.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" + "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\n" + "    </tr>\n" + "    <tr>\n" + "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" + "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" + "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);

    angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/datepicker/month.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" + "      <th colspan=\"{{::yearHeaderColspan}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></i></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);

    angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/datepicker/year.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" + "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);

    angular.module("uib/template/datepickerPopup/popup.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/datepickerPopup/popup.html", "<ul role=\"presentation\" class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" + "  <li ng-transclude></li>\n" + "  <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" + "    <span class=\"btn-group pull-left\">\n" + "      <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" + "      <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" + "    </span>\n" + "    <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" + "  </li>\n" + "</ul>\n" + "");
    }]);

    angular.module("uib/template/modal/window.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/modal/window.html", "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" + "");
    }]);

    angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/pager/pager.html", "<li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" + "<li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" + "");
    }]);

    angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/pagination/pagination.html", "<li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('first')}}</a></li>\n" + "<li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" + "<li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\" ng-disabled=\"ngDisabled&&!page.active\" uib-tabindex-toggle>{{page.text}}</a></li>\n" + "<li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" + "<li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('last')}}</a></li>\n" + "");
    }]);

    angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/tooltip/tooltip-html-popup.html", "<div class=\"tooltip-arrow\"></div>\n" + "<div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" + "");
    }]);

    angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/tooltip/tooltip-popup.html", "<div class=\"tooltip-arrow\"></div>\n" + "<div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" + "");
    }]);

    angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/tooltip/tooltip-template-popup.html", "<div class=\"tooltip-arrow\"></div>\n" + "<div class=\"tooltip-inner\"\n" + "  uib-tooltip-template-transclude=\"contentExp()\"\n" + "  tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "");
    }]);

    angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/popover/popover-html.html", "<div class=\"arrow\"></div>\n" + "\n" + "<div class=\"popover-inner\">\n" + "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "    <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" + "</div>\n" + "");
    }]);

    angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/popover/popover-template.html", "<div class=\"arrow\"></div>\n" + "\n" + "<div class=\"popover-inner\">\n" + "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "    <div class=\"popover-content\"\n" + "      uib-tooltip-template-transclude=\"contentExp()\"\n" + "      tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "</div>\n" + "");
    }]);

    angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/popover/popover.html", "<div class=\"arrow\"></div>\n" + "\n" + "<div class=\"popover-inner\">\n" + "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "    <div class=\"popover-content\" ng-bind=\"content\"></div>\n" + "</div>\n" + "");
    }]);

    angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/progressbar/bar.html", "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" + "");
    }]);

    angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/progressbar/progress.html", "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
    }]);

    angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/progressbar/progressbar.html", "<div class=\"progress\">\n" + "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" + "</div>\n" + "");
    }]);

    angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/rating/rating.html", "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" + "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" + "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\"></i>\n" + "</span>\n" + "");
    }]);

    angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/tabs/tab.html", "<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\n" + "  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\n" + "</li>\n" + "");
    }]);

    angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/tabs/tabset.html", "<div>\n" + "  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" + "  <div class=\"tab-content\">\n" + "    <div class=\"tab-pane\"\n" + "         ng-repeat=\"tab in tabset.tabs\"\n" + "         ng-class=\"{active: tabset.active === tab.index}\"\n" + "         uib-tab-content-transclude=\"tab\">\n" + "    </div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);

    angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/timepicker/timepicker.html", "<table class=\"uib-timepicker\">\n" + "  <tbody>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "    <tr>\n" + "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" + "        <input type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td class=\"uib-separator\">:</td>\n" + "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" + "        <input type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" + "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" + "        <input type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" + "    </tr>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);

    angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/typeahead/typeahead-match.html", "<a href\n" + "   tabindex=\"-1\"\n" + "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" + "   ng-attr-title=\"{{match.label}}\"></a>\n" + "");
    }]);

    angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function ($templateCache) {
      $templateCache.put("uib/template/typeahead/typeahead-popup.html", "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" + "    <li class=\"uib-typeahead-match\" ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" + "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" + "    </li>\n" + "</ul>\n" + "");
    }]);
    angular.module('ui.bootstrap.carousel').run(function () {
      !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');angular.$$uibCarouselCss = true;
    });
    angular.module('ui.bootstrap.datepicker').run(function () {
      !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>');angular.$$uibDatepickerCss = true;
    });
    angular.module('ui.bootstrap.position').run(function () {
      !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>');angular.$$uibPositionCss = true;
    });
    angular.module('ui.bootstrap.datepickerPopup').run(function () {
      !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>');angular.$$uibDatepickerpopupCss = true;
    });
    angular.module('ui.bootstrap.tooltip').run(function () {
      !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>');angular.$$uibTooltipCss = true;
    });
    angular.module('ui.bootstrap.timepicker').run(function () {
      !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>');angular.$$uibTimepickerCss = true;
    });
    angular.module('ui.bootstrap.typeahead').run(function () {
      !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>');angular.$$uibTypeaheadCss = true;
    });
  }, {}], 7: [function (require, module, exports) {
    require('./dist/ui-bootstrap-tpls');

    module.exports = 'ui.bootstrap';
  }, { "./dist/ui-bootstrap-tpls": 6 }], 8: [function (require, module, exports) {
    /*
     * angular-elastic v2.5.1
     * (c) 2014 Monospaced http://monospaced.com
     * License: MIT
     */

    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {
      module.exports = 'monospaced.elastic';
    }

    angular.module('monospaced.elastic', []).constant('msdElasticConfig', {
      append: ''
    }).directive('msdElastic', ['$timeout', '$window', 'msdElasticConfig', function ($timeout, $window, config) {
      'use strict';

      return {
        require: 'ngModel',
        restrict: 'A, C',
        link: function link(scope, element, attrs, ngModel) {

          // cache a reference to the DOM element
          var ta = element[0],
              $ta = element;

          // ensure the element is a textarea, and browser is capable
          if (ta.nodeName !== 'TEXTAREA' || !$window.getComputedStyle) {
            return;
          }

          // set these properties before measuring dimensions
          $ta.css({
            'overflow': 'hidden',
            'overflow-y': 'hidden',
            'word-wrap': 'break-word'
          });

          // force text reflow
          var text = ta.value;
          ta.value = '';
          ta.value = text;

          var append = attrs.msdElastic ? attrs.msdElastic.replace(/\\n/g, '\n') : config.append,
              $win = angular.element($window),
              mirrorInitStyle = 'position: absolute; top: -999px; right: auto; bottom: auto;' + 'left: 0; overflow: hidden; -webkit-box-sizing: content-box;' + '-moz-box-sizing: content-box; box-sizing: content-box;' + 'min-height: 0 !important; height: 0 !important; padding: 0;' + 'word-wrap: break-word; border: 0;',
              $mirror = angular.element('<textarea aria-hidden="true" tabindex="-1" ' + 'style="' + mirrorInitStyle + '"/>').data('elastic', true),
              mirror = $mirror[0],
              taStyle = getComputedStyle(ta),
              resize = taStyle.getPropertyValue('resize'),
              borderBox = taStyle.getPropertyValue('box-sizing') === 'border-box' || taStyle.getPropertyValue('-moz-box-sizing') === 'border-box' || taStyle.getPropertyValue('-webkit-box-sizing') === 'border-box',
              boxOuter = !borderBox ? { width: 0, height: 0 } : {
            width: parseInt(taStyle.getPropertyValue('border-right-width'), 10) + parseInt(taStyle.getPropertyValue('padding-right'), 10) + parseInt(taStyle.getPropertyValue('padding-left'), 10) + parseInt(taStyle.getPropertyValue('border-left-width'), 10),
            height: parseInt(taStyle.getPropertyValue('border-top-width'), 10) + parseInt(taStyle.getPropertyValue('padding-top'), 10) + parseInt(taStyle.getPropertyValue('padding-bottom'), 10) + parseInt(taStyle.getPropertyValue('border-bottom-width'), 10)
          },
              minHeightValue = parseInt(taStyle.getPropertyValue('min-height'), 10),
              heightValue = parseInt(taStyle.getPropertyValue('height'), 10),
              minHeight = Math.max(minHeightValue, heightValue) - boxOuter.height,
              maxHeight = parseInt(taStyle.getPropertyValue('max-height'), 10),
              mirrored,
              active,
              copyStyle = ['font-family', 'font-size', 'font-weight', 'font-style', 'letter-spacing', 'line-height', 'text-transform', 'word-spacing', 'text-indent'];

          // exit if elastic already applied (or is the mirror element)
          if ($ta.data('elastic')) {
            return;
          }

          // Opera returns max-height of -1 if not set
          maxHeight = maxHeight && maxHeight > 0 ? maxHeight : 9e4;

          // append mirror to the DOM
          if (mirror.parentNode !== document.body) {
            angular.element(document.body).append(mirror);
          }

          // set resize and apply elastic
          $ta.css({
            'resize': resize === 'none' || resize === 'vertical' ? 'none' : 'horizontal'
          }).data('elastic', true);

          /*
           * methods
           */

          function initMirror() {
            var mirrorStyle = mirrorInitStyle;

            mirrored = ta;
            // copy the essential styles from the textarea to the mirror
            taStyle = getComputedStyle(ta);
            angular.forEach(copyStyle, function (val) {
              mirrorStyle += val + ':' + taStyle.getPropertyValue(val) + ';';
            });
            mirror.setAttribute('style', mirrorStyle);
          }

          function adjust() {
            var taHeight, taComputedStyleWidth, mirrorHeight, width, overflow;

            if (mirrored !== ta) {
              initMirror();
            }

            // active flag prevents actions in function from calling adjust again
            if (!active) {
              active = true;

              mirror.value = ta.value + append; // optional whitespace to improve animation
              mirror.style.overflowY = ta.style.overflowY;

              taHeight = ta.style.height === '' ? 'auto' : parseInt(ta.style.height, 10);

              taComputedStyleWidth = getComputedStyle(ta).getPropertyValue('width');

              // ensure getComputedStyle has returned a readable 'used value' pixel width
              if (taComputedStyleWidth.substr(taComputedStyleWidth.length - 2, 2) === 'px') {
                // update mirror width in case the textarea width has changed
                width = parseInt(taComputedStyleWidth, 10) - boxOuter.width;
                mirror.style.width = width + 'px';
              }

              mirrorHeight = mirror.scrollHeight;

              if (mirrorHeight > maxHeight) {
                mirrorHeight = maxHeight;
                overflow = 'scroll';
              } else if (mirrorHeight < minHeight) {
                mirrorHeight = minHeight;
              }
              mirrorHeight += boxOuter.height;
              ta.style.overflowY = overflow || 'hidden';

              if (taHeight !== mirrorHeight) {
                scope.$emit('elastic:resize', $ta, taHeight, mirrorHeight);
                ta.style.height = mirrorHeight + 'px';
              }

              // small delay to prevent an infinite loop
              $timeout(function () {
                active = false;
              }, 1, false);
            }
          }

          function forceAdjust() {
            active = false;
            adjust();
          }

          /*
           * initialise
           */

          // listen
          if ('onpropertychange' in ta && 'oninput' in ta) {
            // IE9
            ta['oninput'] = ta.onkeyup = adjust;
          } else {
            ta['oninput'] = adjust;
          }

          $win.bind('resize', forceAdjust);

          scope.$watch(function () {
            return ngModel.$modelValue;
          }, function (newValue) {
            forceAdjust();
          });

          scope.$on('elastic:adjust', function () {
            initMirror();
            forceAdjust();
          });

          $timeout(adjust, 0, false);

          /*
           * destroy
           */

          scope.$on('$destroy', function () {
            $mirror.remove();
            $win.unbind('resize', forceAdjust);
          });
        }
      };
    }]);
  }, {}], 9: [function (require, module, exports) {
    'use strict';

    function RavenConfigError(message) {
      this.name = 'RavenConfigError';
      this.message = message;
    }
    RavenConfigError.prototype = new Error();
    RavenConfigError.prototype.constructor = RavenConfigError;

    module.exports = RavenConfigError;
  }, {}], 10: [function (require, module, exports) {
    'use strict';

    var wrapMethod = function wrapMethod(console, level, callback) {
      var originalConsoleLevel = console[level];
      var originalConsole = console;

      if (!(level in console)) {
        return;
      }

      var sentryLevel = level === 'warn' ? 'warning' : level;

      console[level] = function () {
        var args = [].slice.call(arguments);

        var msg = '' + args.join(' ');
        var data = { level: sentryLevel, logger: 'console', extra: { 'arguments': args } };
        callback && callback(msg, data);

        // this fails for some browsers. :(
        if (originalConsoleLevel) {
          // IE9 doesn't allow calling apply on console functions directly
          // See: https://stackoverflow.com/questions/5472938/does-ie9-support-console-log-and-is-it-a-real-function#answer-5473193
          Function.prototype.apply.call(originalConsoleLevel, originalConsole, args);
        }
      };
    };

    module.exports = {
      wrapMethod: wrapMethod
    };
  }, {}], 11: [function (require, module, exports) {
    /*global XDomainRequest:false*/
    'use strict';

    var TraceKit = require('../vendor/TraceKit/tracekit');
    var RavenConfigError = require('./configError');
    var utils = require('./utils');
    var stringify = require('json-stringify-safe');

    var isFunction = utils.isFunction;
    var isUndefined = utils.isUndefined;
    var isError = utils.isError;
    var isEmptyObject = utils.isEmptyObject;
    var hasKey = utils.hasKey;
    var joinRegExp = utils.joinRegExp;
    var each = utils.each;
    var objectMerge = utils.objectMerge;
    var truncate = utils.truncate;
    var urlencode = utils.urlencode;
    var uuid4 = utils.uuid4;
    var htmlTreeAsString = utils.htmlTreeAsString;
    var parseUrl = utils.parseUrl;
    var isString = utils.isString;
    var fill = utils.fill;

    var wrapConsoleMethod = require('./console').wrapMethod;

    var dsnKeys = 'source protocol user pass host port path'.split(' '),
        dsnPattern = /^(?:(\w+):)?\/\/(?:(\w+)(:\w+)?@)?([\w\.-]+)(?::(\d+))?(\/.*)/;

    function now() {
      return +new Date();
    }

    // First, check for JSON support
    // If there is no JSON, we no-op the core features of Raven
    // since JSON is required to encode the payload
    function Raven() {
      this._hasJSON = !!((typeof JSON === "undefined" ? "undefined" : _typeof(JSON)) === 'object' && JSON.stringify);
      // Raven can run in contexts where there's no document (react-native)
      this._hasDocument = typeof document !== 'undefined';
      this._lastCapturedException = null;
      this._lastEventId = null;
      this._globalServer = null;
      this._globalKey = null;
      this._globalProject = null;
      this._globalContext = {};
      this._globalOptions = {
        logger: 'javascript',
        ignoreErrors: [],
        ignoreUrls: [],
        whitelistUrls: [],
        includePaths: [],
        crossOrigin: 'anonymous',
        collectWindowErrors: true,
        maxMessageLength: 0,
        stackTraceLimit: 50,
        autoBreadcrumbs: true
      };
      this._ignoreOnError = 0;
      this._isRavenInstalled = false;
      this._originalErrorStackTraceLimit = Error.stackTraceLimit;
      // capture references to window.console *and* all its methods first
      // before the console plugin has a chance to monkey patch
      this._originalConsole = window.console || {};
      this._originalConsoleMethods = {};
      this._plugins = [];
      this._startTime = now();
      this._wrappedBuiltIns = [];
      this._breadcrumbs = [];
      this._lastCapturedEvent = null;
      this._keypressTimeout;
      this._location = window.location;
      this._lastHref = this._location && this._location.href;

      for (var method in this._originalConsole) {
        // eslint-disable-line guard-for-in
        this._originalConsoleMethods[method] = this._originalConsole[method];
      }
    }

    /*
     * The core Raven singleton
     *
     * @this {Raven}
     */

    Raven.prototype = {
      // Hardcode version string so that raven source can be loaded directly via
      // webpack (using a build step causes webpack #1617). Grunt verifies that
      // this value matches package.json during build.
      //   See: https://github.com/getsentry/raven-js/issues/465
      VERSION: '3.7.0',

      debug: false,

      TraceKit: TraceKit, // alias to TraceKit

      /*
       * Configure Raven with a DSN and extra options
       *
       * @param {string} dsn The public Sentry DSN
       * @param {object} options Optional set of of global options [optional]
       * @return {Raven}
       */
      config: function config(dsn, options) {
        var self = this;

        if (this._globalServer) {
          this._logDebug('error', 'Error: Raven has already been configured');
          return this;
        }
        if (!dsn) return this;

        // merge in options
        if (options) {
          each(options, function (key, value) {
            // tags and extra are special and need to be put into context
            if (key === 'tags' || key === 'extra') {
              self._globalContext[key] = value;
            } else {
              self._globalOptions[key] = value;
            }
          });
        }

        this.setDSN(dsn);

        // "Script error." is hard coded into browsers for errors that it can't read.
        // this is the result of a script being pulled in from an external domain and CORS.
        this._globalOptions.ignoreErrors.push(/^Script error\.?$/);
        this._globalOptions.ignoreErrors.push(/^Javascript error: Script error\.? on line 0$/);

        // join regexp rules into one big rule
        this._globalOptions.ignoreErrors = joinRegExp(this._globalOptions.ignoreErrors);
        this._globalOptions.ignoreUrls = this._globalOptions.ignoreUrls.length ? joinRegExp(this._globalOptions.ignoreUrls) : false;
        this._globalOptions.whitelistUrls = this._globalOptions.whitelistUrls.length ? joinRegExp(this._globalOptions.whitelistUrls) : false;
        this._globalOptions.includePaths = joinRegExp(this._globalOptions.includePaths);
        this._globalOptions.maxBreadcrumbs = Math.max(0, Math.min(this._globalOptions.maxBreadcrumbs || 100, 100)); // default and hard limit is 100

        var autoBreadcrumbDefaults = {
          xhr: true,
          console: true,
          dom: true,
          location: true
        };

        var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;
        if ({}.toString.call(autoBreadcrumbs) === '[object Object]') {
          autoBreadcrumbs = objectMerge(autoBreadcrumbDefaults, autoBreadcrumbs);
        } else if (autoBreadcrumbs !== false) {
          autoBreadcrumbs = autoBreadcrumbDefaults;
        }
        this._globalOptions.autoBreadcrumbs = autoBreadcrumbs;

        TraceKit.collectWindowErrors = !!this._globalOptions.collectWindowErrors;

        // return for chaining
        return this;
      },

      /*
       * Installs a global window.onerror error handler
       * to capture and report uncaught exceptions.
       * At this point, install() is required to be called due
       * to the way TraceKit is set up.
       *
       * @return {Raven}
       */
      install: function install() {
        var self = this;
        if (this.isSetup() && !this._isRavenInstalled) {
          TraceKit.report.subscribe(function () {
            self._handleOnErrorStackInfo.apply(self, arguments);
          });
          this._instrumentTryCatch();
          if (self._globalOptions.autoBreadcrumbs) this._instrumentBreadcrumbs();

          // Install all of the plugins
          this._drainPlugins();

          this._isRavenInstalled = true;
        }

        Error.stackTraceLimit = this._globalOptions.stackTraceLimit;
        return this;
      },

      /*
       * Set the DSN (can be called multiple time unlike config)
       *
       * @param {string} dsn The public Sentry DSN
       */
      setDSN: function setDSN(dsn) {
        var uri = this._parseDSN(dsn),
            lastSlash = uri.path.lastIndexOf('/'),
            path = uri.path.substr(1, lastSlash);

        this._dsn = dsn;
        this._globalKey = uri.user;
        this._globalSecret = uri.pass && uri.pass.substr(1);
        this._globalProject = uri.path.substr(lastSlash + 1);

        this._globalServer = this._getGlobalServer(uri);

        this._globalEndpoint = this._globalServer + '/' + path + 'api/' + this._globalProject + '/store/';
      },

      /*
       * Wrap code within a context so Raven can capture errors
       * reliably across domains that is executed immediately.
       *
       * @param {object} options A specific set of options for this context [optional]
       * @param {function} func The callback to be immediately executed within the context
       * @param {array} args An array of arguments to be called with the callback [optional]
       */
      context: function context(options, func, args) {
        if (isFunction(options)) {
          args = func || [];
          func = options;
          options = undefined;
        }

        return this.wrap(options, func).apply(this, args);
      },

      /*
       * Wrap code within a context and returns back a new function to be executed
       *
       * @param {object} options A specific set of options for this context [optional]
       * @param {function} func The function to be wrapped in a new context
       * @param {function} func A function to call before the try/catch wrapper [optional, private]
       * @return {function} The newly wrapped functions with a context
       */
      wrap: function wrap(options, func, _before) {
        var self = this;
        // 1 argument has been passed, and it's not a function
        // so just return it
        if (isUndefined(func) && !isFunction(options)) {
          return options;
        }

        // options is optional
        if (isFunction(options)) {
          func = options;
          options = undefined;
        }

        // At this point, we've passed along 2 arguments, and the second one
        // is not a function either, so we'll just return the second argument.
        if (!isFunction(func)) {
          return func;
        }

        // We don't wanna wrap it twice!
        try {
          if (func.__raven__) {
            return func;
          }

          // If this has already been wrapped in the past, return that
          if (func.__raven_wrapper__) {
            return func.__raven_wrapper__;
          }
        } catch (e) {
          // Just accessing custom props in some Selenium environments
          // can cause a "Permission denied" exception (see raven-js#495).
          // Bail on wrapping and return the function as-is (defers to window.onerror).
          return func;
        }

        function wrapped() {
          var args = [],
              i = arguments.length,
              deep = !options || options && options.deep !== false;

          if (_before && isFunction(_before)) {
            _before.apply(this, arguments);
          }

          // Recursively wrap all of a function's arguments that are
          // functions themselves.
          while (i--) {
            args[i] = deep ? self.wrap(options, arguments[i]) : arguments[i];
          }try {
            return func.apply(this, args);
          } catch (e) {
            self._ignoreNextOnError();
            self.captureException(e, options);
            throw e;
          }
        }

        // copy over properties of the old function
        for (var property in func) {
          if (hasKey(func, property)) {
            wrapped[property] = func[property];
          }
        }
        wrapped.prototype = func.prototype;

        func.__raven_wrapper__ = wrapped;
        // Signal that this function has been wrapped already
        // for both debugging and to prevent it to being wrapped twice
        wrapped.__raven__ = true;
        wrapped.__inner__ = func;

        return wrapped;
      },

      /*
       * Uninstalls the global error handler.
       *
       * @return {Raven}
       */
      uninstall: function uninstall() {
        TraceKit.report.uninstall();

        this._restoreBuiltIns();

        Error.stackTraceLimit = this._originalErrorStackTraceLimit;
        this._isRavenInstalled = false;

        return this;
      },

      /*
       * Manually capture an exception and send it over to Sentry
       *
       * @param {error} ex An exception to be logged
       * @param {object} options A specific set of options for this error [optional]
       * @return {Raven}
       */
      captureException: function captureException(ex, options) {
        // If not an Error is passed through, recall as a message instead
        if (!isError(ex)) {
          return this.captureMessage(ex, objectMerge({
            trimHeadFrames: 1,
            stacktrace: true // if we fall back to captureMessage, default to attempting a new trace
          }, options));
        }

        // Store the raw exception object for potential debugging and introspection
        this._lastCapturedException = ex;

        // TraceKit.report will re-raise any exception passed to it,
        // which means you have to wrap it in try/catch. Instead, we
        // can wrap it here and only re-raise if TraceKit.report
        // raises an exception different from the one we asked to
        // report on.
        try {
          var stack = TraceKit.computeStackTrace(ex);
          this._handleStackInfo(stack, options);
        } catch (ex1) {
          if (ex !== ex1) {
            throw ex1;
          }
        }

        return this;
      },

      /*
       * Manually send a message to Sentry
       *
       * @param {string} msg A plain message to be captured in Sentry
       * @param {object} options A specific set of options for this message [optional]
       * @return {Raven}
       */
      captureMessage: function captureMessage(msg, options) {
        // config() automagically converts ignoreErrors from a list to a RegExp so we need to test for an
        // early call; we'll error on the side of logging anything called before configuration since it's
        // probably something you should see:
        if (!!this._globalOptions.ignoreErrors.test && this._globalOptions.ignoreErrors.test(msg)) {
          return;
        }

        var data = objectMerge({
          message: msg + '' // Make sure it's actually a string
        }, options);

        if (options && options.stacktrace) {
          var ex;
          // create a stack trace from this point; just trim
          // off extra frames so they don't include this function call (or
          // earlier Raven.js library fn calls)
          try {
            throw new Error(msg);
          } catch (ex1) {
            ex = ex1;
          }

          // null exception name so `Error` isn't prefixed to msg
          ex.name = null;

          options = objectMerge({
            // fingerprint on msg, not stack trace (legacy behavior, could be
            // revisited)
            fingerprint: msg,
            trimHeadFrames: (options.trimHeadFrames || 0) + 1
          }, options);

          var stack = TraceKit.computeStackTrace(ex);
          var frames = this._prepareFrames(stack, options);
          data.stacktrace = {
            // Sentry expects frames oldest to newest
            frames: frames.reverse()
          };
        }

        // Fire away!
        this._send(data);

        return this;
      },

      captureBreadcrumb: function captureBreadcrumb(obj) {
        var crumb = objectMerge({
          timestamp: now() / 1000
        }, obj);

        this._breadcrumbs.push(crumb);
        if (this._breadcrumbs.length > this._globalOptions.maxBreadcrumbs) {
          this._breadcrumbs.shift();
        }
        return this;
      },

      addPlugin: function addPlugin(plugin /*arg1, arg2, ... argN*/) {
        var pluginArgs = Array.prototype.slice.call(arguments, 1);

        this._plugins.push([plugin, pluginArgs]);
        if (this._isRavenInstalled) {
          this._drainPlugins();
        }

        return this;
      },

      /*
       * Set/clear a user to be sent along with the payload.
       *
       * @param {object} user An object representing user data [optional]
       * @return {Raven}
       */
      setUserContext: function setUserContext(user) {
        // Intentionally do not merge here since that's an unexpected behavior.
        this._globalContext.user = user;

        return this;
      },

      /*
       * Merge extra attributes to be sent along with the payload.
       *
       * @param {object} extra An object representing extra data [optional]
       * @return {Raven}
       */
      setExtraContext: function setExtraContext(extra) {
        this._mergeContext('extra', extra);

        return this;
      },

      /*
       * Merge tags to be sent along with the payload.
       *
       * @param {object} tags An object representing tags [optional]
       * @return {Raven}
       */
      setTagsContext: function setTagsContext(tags) {
        this._mergeContext('tags', tags);

        return this;
      },

      /*
       * Clear all of the context.
       *
       * @return {Raven}
       */
      clearContext: function clearContext() {
        this._globalContext = {};

        return this;
      },

      /*
       * Get a copy of the current context. This cannot be mutated.
       *
       * @return {object} copy of context
       */
      getContext: function getContext() {
        // lol javascript
        return JSON.parse(stringify(this._globalContext));
      },

      /*
       * Set environment of application
       *
       * @param {string} environment Typically something like 'production'.
       * @return {Raven}
       */
      setEnvironment: function setEnvironment(environment) {
        this._globalOptions.environment = environment;

        return this;
      },

      /*
       * Set release version of application
       *
       * @param {string} release Typically something like a git SHA to identify version
       * @return {Raven}
       */
      setRelease: function setRelease(release) {
        this._globalOptions.release = release;

        return this;
      },

      /*
       * Set the dataCallback option
       *
       * @param {function} callback The callback to run which allows the
       *                            data blob to be mutated before sending
       * @return {Raven}
       */
      setDataCallback: function setDataCallback(callback) {
        var original = this._globalOptions.dataCallback;
        this._globalOptions.dataCallback = isFunction(callback) ? function (data) {
          return callback(data, original);
        } : callback;

        return this;
      },

      /*
       * Set the shouldSendCallback option
       *
       * @param {function} callback The callback to run which allows
       *                            introspecting the blob before sending
       * @return {Raven}
       */
      setShouldSendCallback: function setShouldSendCallback(callback) {
        var original = this._globalOptions.shouldSendCallback;
        this._globalOptions.shouldSendCallback = isFunction(callback) ? function (data) {
          return callback(data, original);
        } : callback;

        return this;
      },

      /**
       * Override the default HTTP transport mechanism that transmits data
       * to the Sentry server.
       *
       * @param {function} transport Function invoked instead of the default
       *                             `makeRequest` handler.
       *
       * @return {Raven}
       */
      setTransport: function setTransport(transport) {
        this._globalOptions.transport = transport;

        return this;
      },

      /*
       * Get the latest raw exception that was captured by Raven.
       *
       * @return {error}
       */
      lastException: function lastException() {
        return this._lastCapturedException;
      },

      /*
       * Get the last event id
       *
       * @return {string}
       */
      lastEventId: function lastEventId() {
        return this._lastEventId;
      },

      /*
       * Determine if Raven is setup and ready to go.
       *
       * @return {boolean}
       */
      isSetup: function isSetup() {
        if (!this._hasJSON) return false; // needs JSON support
        if (!this._globalServer) {
          if (!this.ravenNotConfiguredError) {
            this.ravenNotConfiguredError = true;
            this._logDebug('error', 'Error: Raven has not been configured.');
          }
          return false;
        }
        return true;
      },

      afterLoad: function afterLoad() {
        // TODO: remove window dependence?

        // Attempt to initialize Raven on load
        var RavenConfig = window.RavenConfig;
        if (RavenConfig) {
          this.config(RavenConfig.dsn, RavenConfig.config).install();
        }
      },

      showReportDialog: function showReportDialog(options) {
        if (!window.document) // doesn't work without a document (React native)
          return;

        options = options || {};

        var lastEventId = options.eventId || this.lastEventId();
        if (!lastEventId) {
          throw new RavenConfigError('Missing eventId');
        }

        var dsn = options.dsn || this._dsn;
        if (!dsn) {
          throw new RavenConfigError('Missing DSN');
        }

        var encode = encodeURIComponent;
        var qs = '';
        qs += '?eventId=' + encode(lastEventId);
        qs += '&dsn=' + encode(dsn);

        var user = options.user || this._globalContext.user;
        if (user) {
          if (user.name) qs += '&name=' + encode(user.name);
          if (user.email) qs += '&email=' + encode(user.email);
        }

        var globalServer = this._getGlobalServer(this._parseDSN(dsn));

        var script = document.createElement('script');
        script.async = true;
        script.src = globalServer + '/api/embed/error-page/' + qs;
        (document.head || document.body).appendChild(script);
      },

      /**** Private functions ****/
      _ignoreNextOnError: function _ignoreNextOnError() {
        var self = this;
        this._ignoreOnError += 1;
        setTimeout(function () {
          // onerror should trigger before setTimeout
          self._ignoreOnError -= 1;
        });
      },

      _triggerEvent: function _triggerEvent(eventType, options) {
        // NOTE: `event` is a native browser thing, so let's avoid conflicting wiht it
        var evt, key;

        if (!this._hasDocument) return;

        options = options || {};

        eventType = 'raven' + eventType.substr(0, 1).toUpperCase() + eventType.substr(1);

        if (document.createEvent) {
          evt = document.createEvent('HTMLEvents');
          evt.initEvent(eventType, true, true);
        } else {
          evt = document.createEventObject();
          evt.eventType = eventType;
        }

        for (key in options) {
          if (hasKey(options, key)) {
            evt[key] = options[key];
          }
        }if (document.createEvent) {
          // IE9 if standards
          document.dispatchEvent(evt);
        } else {
          // IE8 regardless of Quirks or Standards
          // IE9 if quirks
          try {
            document.fireEvent('on' + evt.eventType.toLowerCase(), evt);
          } catch (e) {
            // Do nothing
          }
        }
      },

      /**
       * Wraps addEventListener to capture UI breadcrumbs
       * @param evtName the event name (e.g. "click")
       * @returns {Function}
       * @private
       */
      _breadcrumbEventHandler: function _breadcrumbEventHandler(evtName) {
        var self = this;
        return function (evt) {
          // reset keypress timeout; e.g. triggering a 'click' after
          // a 'keypress' will reset the keypress debounce so that a new
          // set of keypresses can be recorded
          self._keypressTimeout = null;

          // It's possible this handler might trigger multiple times for the same
          // event (e.g. event propagation through node ancestors). Ignore if we've
          // already captured the event.
          if (self._lastCapturedEvent === evt) return;

          self._lastCapturedEvent = evt;
          var elem = evt.target;

          var target;

          // try/catch htmlTreeAsString because it's particularly complicated, and
          // just accessing the DOM incorrectly can throw an exception in some circumstances.
          try {
            target = htmlTreeAsString(elem);
          } catch (e) {
            target = '<unknown>';
          }

          self.captureBreadcrumb({
            category: 'ui.' + evtName, // e.g. ui.click, ui.input
            message: target
          });
        };
      },

      /**
       * Wraps addEventListener to capture keypress UI events
       * @returns {Function}
       * @private
       */
      _keypressEventHandler: function _keypressEventHandler() {
        var self = this,
            debounceDuration = 1000; // milliseconds

        // TODO: if somehow user switches keypress target before
        //       debounce timeout is triggered, we will only capture
        //       a single breadcrumb from the FIRST target (acceptable?)

        return function (evt) {
          var target = evt.target,
              tagName = target && target.tagName;

          // only consider keypress events on actual input elements
          // this will disregard keypresses targeting body (e.g. tabbing
          // through elements, hotkeys, etc)
          if (!tagName || tagName !== 'INPUT' && tagName !== 'TEXTAREA') return;

          // record first keypress in a series, but ignore subsequent
          // keypresses until debounce clears
          var timeout = self._keypressTimeout;
          if (!timeout) {
            self._breadcrumbEventHandler('input')(evt);
          }
          clearTimeout(timeout);
          self._keypressTimeout = setTimeout(function () {
            self._keypressTimeout = null;
          }, debounceDuration);
        };
      },

      /**
       * Captures a breadcrumb of type "navigation", normalizing input URLs
       * @param to the originating URL
       * @param from the target URL
       * @private
       */
      _captureUrlChange: function _captureUrlChange(from, to) {
        var parsedLoc = parseUrl(this._location.href);
        var parsedTo = parseUrl(to);
        var parsedFrom = parseUrl(from);

        // because onpopstate only tells you the "new" (to) value of location.href, and
        // not the previous (from) value, we need to track the value of the current URL
        // state ourselves
        this._lastHref = to;

        // Use only the path component of the URL if the URL matches the current
        // document (almost all the time when using pushState)
        if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) to = parsedTo.relative;
        if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) from = parsedFrom.relative;

        this.captureBreadcrumb({
          category: 'navigation',
          data: {
            to: to,
            from: from
          }
        });
      },

      /**
       * Install any queued plugins
       */
      _instrumentTryCatch: function _instrumentTryCatch() {
        var self = this;

        var wrappedBuiltIns = self._wrappedBuiltIns;

        function wrapTimeFn(orig) {
          return function (fn, t) {
            // preserve arity
            // Make a copy of the arguments to prevent deoptimization
            // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; ++i) {
              args[i] = arguments[i];
            }
            var originalCallback = args[0];
            if (isFunction(originalCallback)) {
              args[0] = self.wrap(originalCallback);
            }

            // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it
            // also supports only two arguments and doesn't care what this is, so we
            // can just call the original function directly.
            if (orig.apply) {
              return orig.apply(this, args);
            } else {
              return orig(args[0], args[1]);
            }
          };
        }

        var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

        function wrapEventTarget(global) {
          var proto = window[global] && window[global].prototype;
          if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {
            fill(proto, 'addEventListener', function (orig) {
              return function (evtName, fn, capture, secure) {
                // preserve arity
                try {
                  if (fn && fn.handleEvent) {
                    fn.handleEvent = self.wrap(fn.handleEvent);
                  }
                } catch (err) {}
                // can sometimes get 'Permission denied to access property "handle Event'


                // More breadcrumb DOM capture ... done here and not in `_instrumentBreadcrumbs`
                // so that we don't have more than one wrapper function
                var before;
                if (autoBreadcrumbs && autoBreadcrumbs.dom && (global === 'EventTarget' || global === 'Node')) {
                  if (evtName === 'click') {
                    before = self._breadcrumbEventHandler(evtName);
                  } else if (evtName === 'keypress') {
                    before = self._keypressEventHandler();
                  }
                }
                return orig.call(this, evtName, self.wrap(fn, undefined, before), capture, secure);
              };
            }, wrappedBuiltIns);
            fill(proto, 'removeEventListener', function (orig) {
              return function (evt, fn, capture, secure) {
                try {
                  fn = fn && (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);
                } catch (e) {
                  // ignore, accessing __raven_wrapper__ will throw in some Selenium environments
                }
                return orig.call(this, evt, fn, capture, secure);
              };
            }, wrappedBuiltIns);
          }
        }

        fill(window, 'setTimeout', wrapTimeFn, wrappedBuiltIns);
        fill(window, 'setInterval', wrapTimeFn, wrappedBuiltIns);
        if (window.requestAnimationFrame) {
          fill(window, 'requestAnimationFrame', function (orig) {
            return function (cb) {
              return orig(self.wrap(cb));
            };
          }, wrappedBuiltIns);
        }

        // event targets borrowed from bugsnag-js:
        // https://github.com/bugsnag/bugsnag-js/blob/master/src/bugsnag.js#L666
        var eventTargets = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];
        for (var i = 0; i < eventTargets.length; i++) {
          wrapEventTarget(eventTargets[i]);
        }

        var $ = window.jQuery || window.$;
        if ($ && $.fn && $.fn.ready) {
          fill($.fn, 'ready', function (orig) {
            return function (fn) {
              return orig.call(this, self.wrap(fn));
            };
          }, wrappedBuiltIns);
        }
      },

      /**
       * Instrument browser built-ins w/ breadcrumb capturing
       *  - XMLHttpRequests
       *  - DOM interactions (click/typing)
       *  - window.location changes
       *  - console
       *
       * Can be disabled or individually configured via the `autoBreadcrumbs` config option
       */
      _instrumentBreadcrumbs: function _instrumentBreadcrumbs() {
        var self = this;
        var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

        var wrappedBuiltIns = self._wrappedBuiltIns;

        function wrapProp(prop, xhr) {
          if (prop in xhr && isFunction(xhr[prop])) {
            fill(xhr, prop, function (orig) {
              return self.wrap(orig);
            }); // intentionally don't track filled methods on XHR instances
          }
        }

        if (autoBreadcrumbs.xhr && 'XMLHttpRequest' in window) {
          var xhrproto = XMLHttpRequest.prototype;
          fill(xhrproto, 'open', function (origOpen) {
            return function (method, url) {
              // preserve arity

              // if Sentry key appears in URL, don't capture
              if (isString(url) && url.indexOf(self._globalKey) === -1) {
                this.__raven_xhr = {
                  method: method,
                  url: url,
                  status_code: null
                };
              }

              return origOpen.apply(this, arguments);
            };
          }, wrappedBuiltIns);

          fill(xhrproto, 'send', function (origSend) {
            return function (data) {
              // preserve arity
              var xhr = this;

              function onreadystatechangeHandler() {
                if (xhr.__raven_xhr && (xhr.readyState === 1 || xhr.readyState === 4)) {
                  try {
                    // touching statusCode in some platforms throws
                    // an exception
                    xhr.__raven_xhr.status_code = xhr.status;
                  } catch (e) {/* do nothing */}
                  self.captureBreadcrumb({
                    type: 'http',
                    category: 'xhr',
                    data: xhr.__raven_xhr
                  });
                }
              }

              var props = ['onload', 'onerror', 'onprogress'];
              for (var j = 0; j < props.length; j++) {
                wrapProp(props[j], xhr);
              }

              if ('onreadystatechange' in xhr && isFunction(xhr.onreadystatechange)) {
                fill(xhr, 'onreadystatechange', function (orig) {
                  return self.wrap(orig, undefined, onreadystatechangeHandler);
                } /* intentionally don't track this instrumentation */);
              } else {
                // if onreadystatechange wasn't actually set by the page on this xhr, we
                // are free to set our own and capture the breadcrumb
                xhr.onreadystatechange = onreadystatechangeHandler;
              }

              return origSend.apply(this, arguments);
            };
          }, wrappedBuiltIns);
        }

        // Capture breadcrumbs from any click that is unhandled / bubbled up all the way
        // to the document. Do this before we instrument addEventListener.
        if (autoBreadcrumbs.dom && this._hasDocument) {
          if (document.addEventListener) {
            document.addEventListener('click', self._breadcrumbEventHandler('click'), false);
            document.addEventListener('keypress', self._keypressEventHandler(), false);
          } else {
            // IE8 Compatibility
            document.attachEvent('onclick', self._breadcrumbEventHandler('click'));
            document.attachEvent('onkeypress', self._keypressEventHandler());
          }
        }

        // record navigation (URL) changes
        // NOTE: in Chrome App environment, touching history.pushState, *even inside
        //       a try/catch block*, will cause Chrome to output an error to console.error
        // borrowed from: https://github.com/angular/angular.js/pull/13945/files
        var chrome = window.chrome;
        var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
        var hasPushState = !isChromePackagedApp && window.history && history.pushState;
        if (autoBreadcrumbs.location && hasPushState) {
          // TODO: remove onpopstate handler on uninstall()
          var oldOnPopState = window.onpopstate;
          window.onpopstate = function () {
            var currentHref = self._location.href;
            self._captureUrlChange(self._lastHref, currentHref);

            if (oldOnPopState) {
              return oldOnPopState.apply(this, arguments);
            }
          };

          fill(history, 'pushState', function (origPushState) {
            // note history.pushState.length is 0; intentionally not declaring
            // params to preserve 0 arity
            return function () /* state, title, url */{
              var url = arguments.length > 2 ? arguments[2] : undefined;

              // url argument is optional
              if (url) {
                // coerce to string (this is what pushState does)
                self._captureUrlChange(self._lastHref, url + '');
              }

              return origPushState.apply(this, arguments);
            };
          }, wrappedBuiltIns);
        }

        if (autoBreadcrumbs.console && 'console' in window && console.log) {
          // console
          var consoleMethodCallback = function consoleMethodCallback(msg, data) {
            self.captureBreadcrumb({
              message: msg,
              level: data.level,
              category: 'console'
            });
          };

          each(['debug', 'info', 'warn', 'error', 'log'], function (_, level) {
            wrapConsoleMethod(console, level, consoleMethodCallback);
          });
        }
      },

      _restoreBuiltIns: function _restoreBuiltIns() {
        // restore any wrapped builtins
        var builtin;
        while (this._wrappedBuiltIns.length) {
          builtin = this._wrappedBuiltIns.shift();

          var obj = builtin[0],
              name = builtin[1],
              orig = builtin[2];

          obj[name] = orig;
        }
      },

      _drainPlugins: function _drainPlugins() {
        var self = this;

        // FIX ME TODO
        each(this._plugins, function (_, plugin) {
          var installer = plugin[0];
          var args = plugin[1];
          installer.apply(self, [self].concat(args));
        });
      },

      _parseDSN: function _parseDSN(str) {
        var m = dsnPattern.exec(str),
            dsn = {},
            i = 7;

        try {
          while (i--) {
            dsn[dsnKeys[i]] = m[i] || '';
          }
        } catch (e) {
          throw new RavenConfigError('Invalid DSN: ' + str);
        }

        if (dsn.pass && !this._globalOptions.allowSecretKey) {
          throw new RavenConfigError('Do not specify your secret key in the DSN. See: http://bit.ly/raven-secret-key');
        }

        return dsn;
      },

      _getGlobalServer: function _getGlobalServer(uri) {
        // assemble the endpoint from the uri pieces
        var globalServer = '//' + uri.host + (uri.port ? ':' + uri.port : '');

        if (uri.protocol) {
          globalServer = uri.protocol + ':' + globalServer;
        }
        return globalServer;
      },

      _handleOnErrorStackInfo: function _handleOnErrorStackInfo() {
        // if we are intentionally ignoring errors via onerror, bail out
        if (!this._ignoreOnError) {
          this._handleStackInfo.apply(this, arguments);
        }
      },

      _handleStackInfo: function _handleStackInfo(stackInfo, options) {
        var frames = this._prepareFrames(stackInfo, options);

        this._triggerEvent('handle', {
          stackInfo: stackInfo,
          options: options
        });

        this._processException(stackInfo.name, stackInfo.message, stackInfo.url, stackInfo.lineno, frames, options);
      },

      _prepareFrames: function _prepareFrames(stackInfo, options) {
        var self = this;
        var frames = [];
        if (stackInfo.stack && stackInfo.stack.length) {
          each(stackInfo.stack, function (i, stack) {
            var frame = self._normalizeFrame(stack);
            if (frame) {
              frames.push(frame);
            }
          });

          // e.g. frames captured via captureMessage throw
          if (options && options.trimHeadFrames) {
            for (var j = 0; j < options.trimHeadFrames && j < frames.length; j++) {
              frames[j].in_app = false;
            }
          }
        }
        frames = frames.slice(0, this._globalOptions.stackTraceLimit);
        return frames;
      },

      _normalizeFrame: function _normalizeFrame(frame) {
        if (!frame.url) return;

        // normalize the frames data
        var normalized = {
          filename: frame.url,
          lineno: frame.line,
          colno: frame.column,
          'function': frame.func || '?'
        };

        normalized.in_app = !( // determine if an exception came from outside of our app
        // first we check the global includePaths list.
        !!this._globalOptions.includePaths.test && !this._globalOptions.includePaths.test(normalized.filename) ||
        // Now we check for fun, if the function name is Raven or TraceKit
        /(Raven|TraceKit)\./.test(normalized['function']) ||
        // finally, we do a last ditch effort and check for raven.min.js
        /raven\.(min\.)?js$/.test(normalized.filename));

        return normalized;
      },

      _processException: function _processException(type, message, fileurl, lineno, frames, options) {
        var stacktrace;
        if (!!this._globalOptions.ignoreErrors.test && this._globalOptions.ignoreErrors.test(message)) return;

        message += '';

        if (frames && frames.length) {
          fileurl = frames[0].filename || fileurl;
          // Sentry expects frames oldest to newest
          // and JS sends them as newest to oldest
          frames.reverse();
          stacktrace = { frames: frames };
        } else if (fileurl) {
          stacktrace = {
            frames: [{
              filename: fileurl,
              lineno: lineno,
              in_app: true
            }]
          };
        }

        if (!!this._globalOptions.ignoreUrls.test && this._globalOptions.ignoreUrls.test(fileurl)) return;
        if (!!this._globalOptions.whitelistUrls.test && !this._globalOptions.whitelistUrls.test(fileurl)) return;

        var data = objectMerge({
          // sentry.interfaces.Exception
          exception: {
            values: [{
              type: type,
              value: message,
              stacktrace: stacktrace
            }]
          },
          culprit: fileurl
        }, options);

        // Fire away!
        this._send(data);
      },

      _trimPacket: function _trimPacket(data) {
        // For now, we only want to truncate the two different messages
        // but this could/should be expanded to just trim everything
        var max = this._globalOptions.maxMessageLength;
        if (data.message) {
          data.message = truncate(data.message, max);
        }
        if (data.exception) {
          var exception = data.exception.values[0];
          exception.value = truncate(exception.value, max);
        }

        return data;
      },

      _getHttpData: function _getHttpData() {
        if (!this._hasDocument || !document.location || !document.location.href) {
          return;
        }

        var httpData = {
          headers: {
            'User-Agent': navigator.userAgent
          }
        };

        httpData.url = document.location.href;

        if (document.referrer) {
          httpData.headers.Referer = document.referrer;
        }

        return httpData;
      },

      _send: function _send(data) {
        var globalOptions = this._globalOptions;

        var baseData = {
          project: this._globalProject,
          logger: globalOptions.logger,
          platform: 'javascript'
        },
            httpData = this._getHttpData();

        if (httpData) {
          baseData.request = httpData;
        }

        // HACK: delete `trimHeadFrames` to prevent from appearing in outbound payload
        if (data.trimHeadFrames) delete data.trimHeadFrames;

        data = objectMerge(baseData, data);

        // Merge in the tags and extra separately since objectMerge doesn't handle a deep merge
        data.tags = objectMerge(objectMerge({}, this._globalContext.tags), data.tags);
        data.extra = objectMerge(objectMerge({}, this._globalContext.extra), data.extra);

        // Send along our own collected metadata with extra
        data.extra['session:duration'] = now() - this._startTime;

        if (this._breadcrumbs && this._breadcrumbs.length > 0) {
          // intentionally make shallow copy so that additions
          // to breadcrumbs aren't accidentally sent in this request
          data.breadcrumbs = {
            values: [].slice.call(this._breadcrumbs, 0)
          };
        }

        // If there are no tags/extra, strip the key from the payload alltogther.
        if (isEmptyObject(data.tags)) delete data.tags;

        if (this._globalContext.user) {
          // sentry.interfaces.User
          data.user = this._globalContext.user;
        }

        // Include the environment if it's defined in globalOptions
        if (globalOptions.environment) data.environment = globalOptions.environment;

        // Include the release if it's defined in globalOptions
        if (globalOptions.release) data.release = globalOptions.release;

        // Include server_name if it's defined in globalOptions
        if (globalOptions.serverName) data.server_name = globalOptions.serverName;

        if (isFunction(globalOptions.dataCallback)) {
          data = globalOptions.dataCallback(data) || data;
        }

        // Why??????????
        if (!data || isEmptyObject(data)) {
          return;
        }

        // Check if the request should be filtered or not
        if (isFunction(globalOptions.shouldSendCallback) && !globalOptions.shouldSendCallback(data)) {
          return;
        }

        this._sendProcessedPayload(data);
      },

      _sendProcessedPayload: function _sendProcessedPayload(data, callback) {
        var self = this;
        var globalOptions = this._globalOptions;

        // Send along an event_id if not explicitly passed.
        // This event_id can be used to reference the error within Sentry itself.
        // Set lastEventId after we know the error should actually be sent
        this._lastEventId = data.event_id || (data.event_id = uuid4());

        // Try and clean up the packet before sending by truncating long values
        data = this._trimPacket(data);

        this._logDebug('debug', 'Raven about to send:', data);

        if (!this.isSetup()) return;

        var auth = {
          sentry_version: '7',
          sentry_client: 'raven-js/' + this.VERSION,
          sentry_key: this._globalKey
        };
        if (this._globalSecret) {
          auth.sentry_secret = this._globalSecret;
        }

        var exception = data.exception && data.exception.values[0];
        this.captureBreadcrumb({
          category: 'sentry',
          message: exception ? (exception.type ? exception.type + ': ' : '') + exception.value : data.message,
          event_id: data.event_id,
          level: data.level || 'error' // presume error unless specified
        });

        var url = this._globalEndpoint;
        (globalOptions.transport || this._makeRequest).call(this, {
          url: url,
          auth: auth,
          data: data,
          options: globalOptions,
          onSuccess: function success() {
            self._triggerEvent('success', {
              data: data,
              src: url
            });
            callback && callback();
          },
          onError: function failure(error) {
            self._triggerEvent('failure', {
              data: data,
              src: url
            });
            error = error || new Error('Raven send failed (no additional details provided)');
            callback && callback(error);
          }
        });
      },

      _makeRequest: function _makeRequest(opts) {
        var request = new XMLHttpRequest();

        // if browser doesn't support CORS (e.g. IE7), we are out of luck
        var hasCORS = 'withCredentials' in request || typeof XDomainRequest !== 'undefined';

        if (!hasCORS) return;

        var url = opts.url;
        function handler() {
          if (request.status === 200) {
            if (opts.onSuccess) {
              opts.onSuccess();
            }
          } else if (opts.onError) {
            opts.onError(new Error('Sentry error code: ' + request.status));
          }
        }

        if ('withCredentials' in request) {
          request.onreadystatechange = function () {
            if (request.readyState !== 4) {
              return;
            }
            handler();
          };
        } else {
          request = new XDomainRequest();
          // xdomainrequest cannot go http -> https (or vice versa),
          // so always use protocol relative
          url = url.replace(/^https?:/, '');

          // onreadystatechange not supported by XDomainRequest
          request.onload = handler;
        }

        // NOTE: auth is intentionally sent as part of query string (NOT as custom
        //       HTTP header) so as to avoid preflight CORS requests
        request.open('POST', url + '?' + urlencode(opts.auth));
        request.send(stringify(opts.data));
      },

      _logDebug: function _logDebug(level) {
        if (this._originalConsoleMethods[level] && this.debug) {
          // In IE<10 console methods do not have their own 'apply' method
          Function.prototype.apply.call(this._originalConsoleMethods[level], this._originalConsole, [].slice.call(arguments, 1));
        }
      },

      _mergeContext: function _mergeContext(key, context) {
        if (isUndefined(context)) {
          delete this._globalContext[key];
        } else {
          this._globalContext[key] = objectMerge(this._globalContext[key] || {}, context);
        }
      }
    };

    // Deprecations
    Raven.prototype.setUser = Raven.prototype.setUserContext;
    Raven.prototype.setReleaseContext = Raven.prototype.setRelease;

    module.exports = Raven;
  }, { "../vendor/TraceKit/tracekit": 14, "./configError": 9, "./console": 10, "./utils": 13, "json-stringify-safe": 16 }], 12: [function (require, module, exports) {
    /**
     * Enforces a single instance of the Raven client, and the
     * main entry point for Raven. If you are a consumer of the
     * Raven library, you SHOULD load this file (vs raven.js).
     **/

    'use strict';

    var RavenConstructor = require('./raven');

    var _Raven = window.Raven;

    var Raven = new RavenConstructor();

    /*
     * Allow multiple versions of Raven to be installed.
     * Strip Raven from the global context and returns the instance.
     *
     * @return {Raven}
     */
    Raven.noConflict = function () {
      window.Raven = _Raven;
      return Raven;
    };

    Raven.afterLoad();

    module.exports = Raven;
  }, { "./raven": 11 }], 13: [function (require, module, exports) {
    /*eslint no-extra-parens:0*/
    'use strict';

    var objectPrototype = Object.prototype;

    function isUndefined(what) {
      return what === void 0;
    }

    function isFunction(what) {
      return typeof what === 'function';
    }

    function isString(what) {
      return objectPrototype.toString.call(what) === '[object String]';
    }

    function isObject(what) {
      return (typeof what === "undefined" ? "undefined" : _typeof(what)) === 'object' && what !== null;
    }

    function isEmptyObject(what) {
      for (var _ in what) {
        return false;
      } // eslint-disable-line guard-for-in, no-unused-vars
      return true;
    }

    // Sorta yanked from https://github.com/joyent/node/blob/aa3b4b4/lib/util.js#L560
    // with some tiny modifications
    function isError(what) {
      var toString = objectPrototype.toString.call(what);
      return isObject(what) && toString === '[object Error]' || toString === '[object Exception]' || // Firefox NS_ERROR_FAILURE Exceptions
      what instanceof Error;
    }

    function each(obj, callback) {
      var i, j;

      if (isUndefined(obj.length)) {
        for (i in obj) {
          if (hasKey(obj, i)) {
            callback.call(null, i, obj[i]);
          }
        }
      } else {
        j = obj.length;
        if (j) {
          for (i = 0; i < j; i++) {
            callback.call(null, i, obj[i]);
          }
        }
      }
    }

    function objectMerge(obj1, obj2) {
      if (!obj2) {
        return obj1;
      }
      each(obj2, function (key, value) {
        obj1[key] = value;
      });
      return obj1;
    }

    function truncate(str, max) {
      return !max || str.length <= max ? str : str.substr(0, max) + "\u2026";
    }

    /**
     * hasKey, a better form of hasOwnProperty
     * Example: hasKey(MainHostObject, property) === true/false
     *
     * @param {Object} host object to check property
     * @param {string} key to check
     */
    function hasKey(object, key) {
      return objectPrototype.hasOwnProperty.call(object, key);
    }

    function joinRegExp(patterns) {
      // Combine an array of regular expressions and strings into one large regexp
      // Be mad.
      var sources = [],
          i = 0,
          len = patterns.length,
          pattern;

      for (; i < len; i++) {
        pattern = patterns[i];
        if (isString(pattern)) {
          // If it's a string, we need to escape it
          // Taken from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
          sources.push(pattern.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1'));
        } else if (pattern && pattern.source) {
          // If it's a regexp already, we want to extract the source
          sources.push(pattern.source);
        }
        // Intentionally skip other cases
      }
      return new RegExp(sources.join('|'), 'i');
    }

    function urlencode(o) {
      var pairs = [];
      each(o, function (key, value) {
        pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
      });
      return pairs.join('&');
    }

    // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
    // intentionally using regex and not <a/> href parsing trick because React Native and other
    // environments where DOM might not be available
    function parseUrl(url) {
      var match = url.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
      if (!match) return {};

      // coerce to undefined values to empty string so we don't get 'undefined'
      var query = match[6] || '';
      var fragment = match[8] || '';
      return {
        protocol: match[2],
        host: match[4],
        path: match[5],
        relative: match[5] + query + fragment // everything minus origin
      };
    }
    function uuid4() {
      var crypto = window.crypto || window.msCrypto;

      if (!isUndefined(crypto) && crypto.getRandomValues) {
        // Use window.crypto API if available
        var arr = new Uint16Array(8);
        crypto.getRandomValues(arr);

        // set 4 in byte 7
        arr[3] = arr[3] & 0xFFF | 0x4000;
        // set 2 most significant bits of byte 9 to '10'
        arr[4] = arr[4] & 0x3FFF | 0x8000;

        var pad = function pad(num) {
          var v = num.toString(16);
          while (v.length < 4) {
            v = '0' + v;
          }
          return v;
        };

        return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
      } else {
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
        return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
          var r = Math.random() * 16 | 0,
              v = c === 'x' ? r : r & 0x3 | 0x8;
          return v.toString(16);
        });
      }
    }

    /**
     * Given a child DOM element, returns a query-selector statement describing that
     * and its ancestors
     * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
     * @param elem
     * @returns {string}
     */
    function htmlTreeAsString(elem) {
      var MAX_TRAVERSE_HEIGHT = 5,
          MAX_OUTPUT_LEN = 80,
          out = [],
          height = 0,
          len = 0,
          separator = ' > ',
          sepLength = separator.length,
          nextStr;

      while (elem && height++ < MAX_TRAVERSE_HEIGHT) {

        nextStr = htmlElementAsString(elem);
        // bail out if
        // - nextStr is the 'html' element
        // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
        //   (ignore this limit if we are on the first iteration)
        if (nextStr === 'html' || height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN) {
          break;
        }

        out.push(nextStr);

        len += nextStr.length;
        elem = elem.parentNode;
      }

      return out.reverse().join(separator);
    }

    /**
     * Returns a simple, query-selector representation of a DOM element
     * e.g. [HTMLElement] => input#foo.btn[name=baz]
     * @param HTMLElement
     * @returns {string}
     */
    function htmlElementAsString(elem) {
      var out = [],
          className,
          classes,
          key,
          attr,
          i;

      if (!elem || !elem.tagName) {
        return '';
      }

      out.push(elem.tagName.toLowerCase());
      if (elem.id) {
        out.push('#' + elem.id);
      }

      className = elem.className;
      if (className && isString(className)) {
        classes = className.split(' ');
        for (i = 0; i < classes.length; i++) {
          out.push('.' + classes[i]);
        }
      }
      var attrWhitelist = ['type', 'name', 'title', 'alt'];
      for (i = 0; i < attrWhitelist.length; i++) {
        key = attrWhitelist[i];
        attr = elem.getAttribute(key);
        if (attr) {
          out.push('[' + key + '="' + attr + '"]');
        }
      }
      return out.join('');
    }

    /**
     * Polyfill a method
     * @param obj object e.g. `document`
     * @param name method name present on object e.g. `addEventListener`
     * @param replacement replacement function
     * @param track {optional} record instrumentation to an array
     */
    function fill(obj, name, replacement, track) {
      var orig = obj[name];
      obj[name] = replacement(orig);
      if (track) {
        track.push([obj, name, orig]);
      }
    }

    module.exports = {
      isUndefined: isUndefined,
      isFunction: isFunction,
      isString: isString,
      isObject: isObject,
      isEmptyObject: isEmptyObject,
      isError: isError,
      each: each,
      objectMerge: objectMerge,
      truncate: truncate,
      hasKey: hasKey,
      joinRegExp: joinRegExp,
      urlencode: urlencode,
      uuid4: uuid4,
      htmlTreeAsString: htmlTreeAsString,
      htmlElementAsString: htmlElementAsString,
      parseUrl: parseUrl,
      fill: fill
    };
  }, {}], 14: [function (require, module, exports) {
    'use strict';

    var utils = require('../../src/utils');

    var hasKey = utils.hasKey;
    var isString = utils.isString;
    var isUndefined = utils.isUndefined;

    /*
     TraceKit - Cross brower stack traces - github.com/occ/TraceKit
     MIT license
    */

    var TraceKit = {
      collectWindowErrors: true,
      debug: false
    };

    // global reference to slice
    var _slice = [].slice;
    var UNKNOWN_FUNCTION = '?';

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
    var ERROR_TYPES_RE = /^(?:Uncaught (?:exception: )?)?((?:Eval|Internal|Range|Reference|Syntax|Type|URI)Error): ?(.*)$/;

    function getLocationHref() {
      if (typeof document === 'undefined') return '';

      return document.location.href;
    }

    /**
     * TraceKit.report: cross-browser processing of unhandled exceptions
     *
     * Syntax:
     *   TraceKit.report.subscribe(function(stackInfo) { ... })
     *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
     *   TraceKit.report(exception)
     *   try { ...code... } catch(ex) { TraceKit.report(ex); }
     *
     * Supports:
     *   - Firefox: full stack trace with line numbers, plus column number
     *              on top frame; column number is not guaranteed
     *   - Opera:   full stack trace with line and column numbers
     *   - Chrome:  full stack trace with line and column numbers
     *   - Safari:  line and column number for the top frame only; some frames
     *              may be missing, and column number is not guaranteed
     *   - IE:      line and column number for the top frame only; some frames
     *              may be missing, and column number is not guaranteed
     *
     * In theory, TraceKit should work on all of the following versions:
     *   - IE5.5+ (only 8.0 tested)
     *   - Firefox 0.9+ (only 3.5+ tested)
     *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
     *     Exceptions Have Stacktrace to be enabled in opera:config)
     *   - Safari 3+ (only 4+ tested)
     *   - Chrome 1+ (only 5+ tested)
     *   - Konqueror 3.5+ (untested)
     *
     * Requires TraceKit.computeStackTrace.
     *
     * Tries to catch all unhandled exceptions and report them to the
     * subscribed handlers. Please note that TraceKit.report will rethrow the
     * exception. This is REQUIRED in order to get a useful stack trace in IE.
     * If the exception does not reach the top of the browser, you will only
     * get a stack trace from the point where TraceKit.report was called.
     *
     * Handlers receive a stackInfo object as described in the
     * TraceKit.computeStackTrace docs.
     */
    TraceKit.report = function reportModuleWrapper() {
      var handlers = [],
          lastArgs = null,
          lastException = null,
          lastExceptionStack = null;

      /**
       * Add a crash handler.
       * @param {Function} handler
       */
      function subscribe(handler) {
        installGlobalHandler();
        handlers.push(handler);
      }

      /**
       * Remove a crash handler.
       * @param {Function} handler
       */
      function unsubscribe(handler) {
        for (var i = handlers.length - 1; i >= 0; --i) {
          if (handlers[i] === handler) {
            handlers.splice(i, 1);
          }
        }
      }

      /**
       * Remove all crash handlers.
       */
      function unsubscribeAll() {
        uninstallGlobalHandler();
        handlers = [];
      }

      /**
       * Dispatch stack information to all handlers.
       * @param {Object.<string, *>} stack
       */
      function notifyHandlers(stack, isWindowError) {
        var exception = null;
        if (isWindowError && !TraceKit.collectWindowErrors) {
          return;
        }
        for (var i in handlers) {
          if (hasKey(handlers, i)) {
            try {
              handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));
            } catch (inner) {
              exception = inner;
            }
          }
        }

        if (exception) {
          throw exception;
        }
      }

      var _oldOnerrorHandler, _onErrorHandlerInstalled;

      /**
       * Ensures all global unhandled exceptions are recorded.
       * Supported by Gecko and IE.
       * @param {string} message Error message.
       * @param {string} url URL of script that generated the exception.
       * @param {(number|string)} lineNo The line number at which the error
       * occurred.
       * @param {?(number|string)} colNo The column number at which the error
       * occurred.
       * @param {?Error} ex The actual Error object.
       */
      function traceKitWindowOnError(message, url, lineNo, colNo, ex) {
        var stack = null;

        if (lastExceptionStack) {
          TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);
          processLastException();
        } else if (ex) {
          // New chrome and blink send along a real error object
          // Let's just report that like a normal error.
          // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
          stack = TraceKit.computeStackTrace(ex);
          notifyHandlers(stack, true);
        } else {
          var location = {
            'url': url,
            'line': lineNo,
            'column': colNo
          };

          var name = undefined;
          var msg = message; // must be new var or will modify original `arguments`
          var groups;
          if (isString(message)) {
            var groups = message.match(ERROR_TYPES_RE);
            if (groups) {
              name = groups[1];
              msg = groups[2];
            }
          }

          location.func = UNKNOWN_FUNCTION;

          stack = {
            'name': name,
            'message': msg,
            'url': getLocationHref(),
            'stack': [location]
          };
          notifyHandlers(stack, true);
        }

        if (_oldOnerrorHandler) {
          return _oldOnerrorHandler.apply(this, arguments);
        }

        return false;
      }

      function installGlobalHandler() {
        if (_onErrorHandlerInstalled) {
          return;
        }
        _oldOnerrorHandler = window.onerror;
        window.onerror = traceKitWindowOnError;
        _onErrorHandlerInstalled = true;
      }

      function uninstallGlobalHandler() {
        if (!_onErrorHandlerInstalled) {
          return;
        }
        window.onerror = _oldOnerrorHandler;
        _onErrorHandlerInstalled = false;
        _oldOnerrorHandler = undefined;
      }

      function processLastException() {
        var _lastExceptionStack = lastExceptionStack,
            _lastArgs = lastArgs;
        lastArgs = null;
        lastExceptionStack = null;
        lastException = null;
        notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));
      }

      /**
       * Reports an unhandled Error to TraceKit.
       * @param {Error} ex
       * @param {?boolean} rethrow If false, do not re-throw the exception.
       * Only used for window.onerror to not cause an infinite loop of
       * rethrowing.
       */
      function report(ex, rethrow) {
        var args = _slice.call(arguments, 1);
        if (lastExceptionStack) {
          if (lastException === ex) {
            return; // already caught by an inner catch block, ignore
          } else {
            processLastException();
          }
        }

        var stack = TraceKit.computeStackTrace(ex);
        lastExceptionStack = stack;
        lastException = ex;
        lastArgs = args;

        // If the stack trace is incomplete, wait for 2 seconds for
        // slow slow IE to see if onerror occurs or not before reporting
        // this exception; otherwise, we will end up with an incomplete
        // stack trace
        window.setTimeout(function () {
          if (lastException === ex) {
            processLastException();
          }
        }, stack.incomplete ? 2000 : 0);

        if (rethrow !== false) {
          throw ex; // re-throw to propagate to the top level (and cause window.onerror)
        }
      }

      report.subscribe = subscribe;
      report.unsubscribe = unsubscribe;
      report.uninstall = unsubscribeAll;
      return report;
    }();

    /**
     * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript
     *
     * Syntax:
     *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
     * Returns:
     *   s.name              - exception name
     *   s.message           - exception message
     *   s.stack[i].url      - JavaScript or HTML file URL
     *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)
     *   s.stack[i].args     - arguments passed to the function, if known
     *   s.stack[i].line     - line number, if known
     *   s.stack[i].column   - column number, if known
     *
     * Supports:
     *   - Firefox:  full stack trace with line numbers and unreliable column
     *               number on top frame
     *   - Opera 10: full stack trace with line and column numbers
     *   - Opera 9-: full stack trace with line numbers
     *   - Chrome:   full stack trace with line and column numbers
     *   - Safari:   line and column number for the topmost stacktrace element
     *               only
     *   - IE:       no line numbers whatsoever
     *
     * Tries to guess names of anonymous functions by looking for assignments
     * in the source code. In IE and Safari, we have to guess source file names
     * by searching for function bodies inside all page scripts. This will not
     * work for scripts that are loaded cross-domain.
     * Here be dragons: some function names may be guessed incorrectly, and
     * duplicate functions may be mismatched.
     *
     * TraceKit.computeStackTrace should only be used for tracing purposes.
     * Logging of unhandled exceptions should be done with TraceKit.report,
     * which builds on top of TraceKit.computeStackTrace and provides better
     * IE support by utilizing the window.onerror event to retrieve information
     * about the top of the stack.
     *
     * Note: In IE and Safari, no stack trace is recorded on the Error object,
     * so computeStackTrace instead walks its *own* chain of callers.
     * This means that:
     *  * in Safari, some methods may be missing from the stack trace;
     *  * in IE, the topmost function in the stack trace will always be the
     *    caller of computeStackTrace.
     *
     * This is okay for tracing (because you are likely to be calling
     * computeStackTrace from the function you want to be the topmost element
     * of the stack trace anyway), but not okay for logging unhandled
     * exceptions (because your catch block will likely be far away from the
     * inner function that actually caused the exception).
     *
     */
    TraceKit.computeStackTrace = function computeStackTraceWrapper() {
      /**
       * Escapes special characters, except for whitespace, in a string to be
       * used inside a regular expression as a string literal.
       * @param {string} text The string.
       * @return {string} The escaped string literal.
       */
      function escapeRegExp(text) {
        return text.replace(/[\-\[\]{}()*+?.,\\\^$|#]/g, '\\$&');
      }

      /**
       * Escapes special characters in a string to be used inside a regular
       * expression as a string literal. Also ensures that HTML entities will
       * be matched the same as their literal friends.
       * @param {string} body The string.
       * @return {string} The escaped string.
       */
      function escapeCodeAsRegExpForMatchingInsideHTML(body) {
        return escapeRegExp(body).replace('<', '(?:<|&lt;)').replace('>', '(?:>|&gt;)').replace('&', '(?:&|&amp;)').replace('"', '(?:"|&quot;)').replace(/\s+/g, '\\s+');
      }

      // Contents of Exception in various browsers.
      //
      // SAFARI:
      // ex.message = Can't find variable: qq
      // ex.line = 59
      // ex.sourceId = 580238192
      // ex.sourceURL = http://...
      // ex.expressionBeginOffset = 96
      // ex.expressionCaretOffset = 98
      // ex.expressionEndOffset = 98
      // ex.name = ReferenceError
      //
      // FIREFOX:
      // ex.message = qq is not defined
      // ex.fileName = http://...
      // ex.lineNumber = 59
      // ex.columnNumber = 69
      // ex.stack = ...stack trace... (see the example below)
      // ex.name = ReferenceError
      //
      // CHROME:
      // ex.message = qq is not defined
      // ex.name = ReferenceError
      // ex.type = not_defined
      // ex.arguments = ['aa']
      // ex.stack = ...stack trace...
      //
      // INTERNET EXPLORER:
      // ex.message = ...
      // ex.name = ReferenceError
      //
      // OPERA:
      // ex.message = ...message... (see the example below)
      // ex.name = ReferenceError
      // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
      // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'

      /**
       * Computes stack trace information from the stack property.
       * Chrome and Gecko use this property.
       * @param {Error} ex
       * @return {?Object.<string, *>} Stack trace information.
       */
      function computeStackTraceFromStackProp(ex) {
        if (isUndefined(ex.stack) || !ex.stack) return;

        var chrome = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|<anonymous>).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
            gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|\[native).*?)(?::(\d+))?(?::(\d+))?\s*$/i,
            winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
            lines = ex.stack.split('\n'),
            stack = [],
            parts,
            element,
            reference = /^(.*) is undefined$/.exec(ex.message);

        for (var i = 0, j = lines.length; i < j; ++i) {
          if (parts = chrome.exec(lines[i])) {
            var isNative = parts[2] && parts[2].indexOf('native') !== -1;
            element = {
              'url': !isNative ? parts[2] : null,
              'func': parts[1] || UNKNOWN_FUNCTION,
              'args': isNative ? [parts[2]] : [],
              'line': parts[3] ? +parts[3] : null,
              'column': parts[4] ? +parts[4] : null
            };
          } else if (parts = winjs.exec(lines[i])) {
            element = {
              'url': parts[2],
              'func': parts[1] || UNKNOWN_FUNCTION,
              'args': [],
              'line': +parts[3],
              'column': parts[4] ? +parts[4] : null
            };
          } else if (parts = gecko.exec(lines[i])) {
            element = {
              'url': parts[3],
              'func': parts[1] || UNKNOWN_FUNCTION,
              'args': parts[2] ? parts[2].split(',') : [],
              'line': parts[4] ? +parts[4] : null,
              'column': parts[5] ? +parts[5] : null
            };
          } else {
            continue;
          }

          if (!element.func && element.line) {
            element.func = UNKNOWN_FUNCTION;
          }

          stack.push(element);
        }

        if (!stack.length) {
          return null;
        }

        if (!stack[0].column && !isUndefined(ex.columnNumber)) {
          // FireFox uses this awesome columnNumber property for its top frame
          // Also note, Firefox's column number is 0-based and everything else expects 1-based,
          // so adding 1
          stack[0].column = ex.columnNumber + 1;
        }

        return {
          'name': ex.name,
          'message': ex.message,
          'url': getLocationHref(),
          'stack': stack
        };
      }

      /**
       * Adds information about the first frame to incomplete stack traces.
       * Safari and IE require this to get complete data on the first frame.
       * @param {Object.<string, *>} stackInfo Stack trace information from
       * one of the compute* methods.
       * @param {string} url The URL of the script that caused an error.
       * @param {(number|string)} lineNo The line number of the script that
       * caused an error.
       * @param {string=} message The error generated by the browser, which
       * hopefully contains the name of the object that caused the error.
       * @return {boolean} Whether or not the stack information was
       * augmented.
       */
      function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
        var initial = {
          'url': url,
          'line': lineNo
        };

        if (initial.url && initial.line) {
          stackInfo.incomplete = false;

          if (!initial.func) {
            initial.func = UNKNOWN_FUNCTION;
          }

          if (stackInfo.stack.length > 0) {
            if (stackInfo.stack[0].url === initial.url) {
              if (stackInfo.stack[0].line === initial.line) {
                return false; // already in stack trace
              } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {
                stackInfo.stack[0].line = initial.line;
                return false;
              }
            }
          }

          stackInfo.stack.unshift(initial);
          stackInfo.partial = true;
          return true;
        } else {
          stackInfo.incomplete = true;
        }

        return false;
      }

      /**
       * Computes stack trace information by walking the arguments.caller
       * chain at the time the exception occurred. This will cause earlier
       * frames to be missed but is the only way to get any stack trace in
       * Safari and IE. The top frame is restored by
       * {@link augmentStackTraceWithInitialElement}.
       * @param {Error} ex
       * @return {?Object.<string, *>} Stack trace information.
       */
      function computeStackTraceByWalkingCallerChain(ex, depth) {
        var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
            stack = [],
            funcs = {},
            recursion = false,
            parts,
            item,
            source;

        for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {
          if (curr === computeStackTrace || curr === TraceKit.report) {
            // console.log('skipping internal function');
            continue;
          }

          item = {
            'url': null,
            'func': UNKNOWN_FUNCTION,
            'line': null,
            'column': null
          };

          if (curr.name) {
            item.func = curr.name;
          } else if (parts = functionName.exec(curr.toString())) {
            item.func = parts[1];
          }

          if (typeof item.func === 'undefined') {
            try {
              item.func = parts.input.substring(0, parts.input.indexOf('{'));
            } catch (e) {}
          }

          if (funcs['' + curr]) {
            recursion = true;
          } else {
            funcs['' + curr] = true;
          }

          stack.push(item);
        }

        if (depth) {
          // console.log('depth is ' + depth);
          // console.log('stack is ' + stack.length);
          stack.splice(0, depth);
        }

        var result = {
          'name': ex.name,
          'message': ex.message,
          'url': getLocationHref(),
          'stack': stack
        };
        augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);
        return result;
      }

      /**
       * Computes a stack trace for an exception.
       * @param {Error} ex
       * @param {(string|number)=} depth
       */
      function computeStackTrace(ex, depth) {
        var stack = null;
        depth = depth == null ? 0 : +depth;

        try {
          stack = computeStackTraceFromStackProp(ex);
          if (stack) {
            return stack;
          }
        } catch (e) {
          if (TraceKit.debug) {
            throw e;
          }
        }

        try {
          stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
          if (stack) {
            return stack;
          }
        } catch (e) {
          if (TraceKit.debug) {
            throw e;
          }
        }

        return {
          'name': ex.name,
          'message': ex.message,
          'url': getLocationHref()
        };
      }

      computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
      computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;

      return computeStackTrace;
    }();

    module.exports = TraceKit;
  }, { "../../src/utils": 13 }], 15: [function (require, module, exports) {
    /*!
     * sweetalert2 v4.1.9
     * Released under the MIT License.
     */
    (function (global, factory) {
      (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Sweetalert2 = factory();
    })(this, function () {
      'use strict';

      var swalPrefix = 'swal2-';

      var prefix = function prefix(items) {
        var result = {};
        for (var i in items) {
          result[items[i]] = swalPrefix + items[i];
        }
        return result;
      };

      var swalClasses = prefix(['container', 'modal', 'overlay', 'close', 'content', 'spacer', 'confirm', 'cancel', 'icon', 'image', 'input', 'select', 'radio', 'checkbox', 'textarea', 'validationerror']);

      var iconTypes = prefix(['success', 'warning', 'info', 'question', 'error']);

      var defaultParams = {
        title: '',
        text: '',
        html: '',
        type: null,
        customClass: '',
        animation: true,
        allowOutsideClick: true,
        allowEscapeKey: true,
        showConfirmButton: true,
        showCancelButton: false,
        preConfirm: null,
        confirmButtonText: 'OK',
        confirmButtonColor: '#3085d6',
        confirmButtonClass: null,
        cancelButtonText: 'Cancel',
        cancelButtonColor: '#aaa',
        cancelButtonClass: null,
        buttonsStyling: true,
        reverseButtons: false,
        focusCancel: false,
        showCloseButton: false,
        showLoaderOnConfirm: false,
        imageUrl: null,
        imageWidth: null,
        imageHeight: null,
        imageClass: null,
        timer: null,
        width: 500,
        padding: 20,
        background: '#fff',
        input: null, // 'text' | 'email' | 'password' | 'select' | 'radio' | 'checkbox' | 'textarea' | 'file'
        inputPlaceholder: '',
        inputValue: '',
        inputOptions: {},
        inputAutoTrim: true,
        inputClass: null,
        inputAttributes: {},
        inputValidator: null,
        onOpen: null,
        onClose: null
      };

      var sweetHTML = '<div class="' + swalClasses.overlay + '" tabIndex="-1"></div>' + '<div class="' + swalClasses.modal + '" style="display: none" tabIndex="-1">' + '<div class="' + swalClasses.icon + ' ' + iconTypes.error + '">' + '<span class="x-mark"><span class="line left"></span><span class="line right"></span></span>' + '</div>' + '<div class="' + swalClasses.icon + ' ' + iconTypes.question + '">?</div>' + '<div class="' + swalClasses.icon + ' ' + iconTypes.warning + '">!</div>' + '<div class="' + swalClasses.icon + ' ' + iconTypes.info + '">i</div>' + '<div class="' + swalClasses.icon + ' ' + iconTypes.success + '">' + '<span class="line tip"></span> <span class="line long"></span>' + '<div class="placeholder"></div> <div class="fix"></div>' + '</div>' + '<img class="' + swalClasses.image + '">' + '<h2></h2>' + '<div class="' + swalClasses.content + '"></div>' + '<input class="' + swalClasses.input + '">' + '<select class="' + swalClasses.select + '"></select>' + '<div class="' + swalClasses.radio + '"></div>' + '<label for="' + swalClasses.checkbox + '" class="' + swalClasses.checkbox + '">' + '<input type="checkbox" id="' + swalClasses.checkbox + '">' + '</label>' + '<textarea class="' + swalClasses.textarea + '"></textarea>' + '<div class="' + swalClasses.validationerror + '"></div>' + '<hr class="' + swalClasses.spacer + '">' + '<button class="' + swalClasses.confirm + '">OK</button>' + '<button class="' + swalClasses.cancel + '">Cancel</button>' + '<span class="' + swalClasses.close + '">&times;</span>' + '</div>';

      var extend = function extend(a, b) {
        for (var key in b) {
          if (b.hasOwnProperty(key)) {
            a[key] = b[key];
          }
        }

        return a;
      };

      /*
       * Set hover, active and focus-states for buttons (source: http://www.sitepoint.com/javascript-generate-lighter-darker-color)
       */
      var colorLuminance = function colorLuminance(hex, lum) {
        // Validate hex string
        hex = String(hex).replace(/[^0-9a-f]/gi, '');
        if (hex.length < 6) {
          hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        lum = lum || 0;

        // Convert to decimal and change luminosity
        var rgb = '#';
        for (var i = 0; i < 3; i++) {
          var c = parseInt(hex.substr(i * 2, 2), 16);
          c = Math.round(Math.min(Math.max(0, c + c * lum), 255)).toString(16);
          rgb += ('00' + c).substr(c.length);
        }

        return rgb;
      };

      /*
       * check if variable is function type. http://stackoverflow.com/questions/5999998/how-can-i-check-if-a-javascript-variable-is-function-type
       */
      var isFunction = function isFunction(functionToCheck) {
        return typeof functionToCheck === 'function';
      };

      var mediaqueryId = swalPrefix + 'mediaquery';

      // Remember state in cases where opening and handling a modal will fiddle with it.
      var states = {
        previousWindowKeyDown: null,
        previousActiveElement: null
      };

      /*
       * Manipulate DOM
       */
      var elementByClass = function elementByClass(className) {
        return document.querySelector('.' + className);
      };

      var getModal = function getModal() {
        return elementByClass(swalClasses.modal);
      };

      var getOverlay = function getOverlay() {
        return elementByClass(swalClasses.overlay);
      };

      var getConfirmButton = function getConfirmButton() {
        return elementByClass(swalClasses.confirm);
      };

      var getCancelButton = function getCancelButton() {
        return elementByClass(swalClasses.cancel);
      };

      var getCloseButton = function getCloseButton() {
        return elementByClass(swalClasses.close);
      };

      var getFocusableElements = function getFocusableElements(focusCancel) {
        var buttons = [getConfirmButton(), getCancelButton()];
        if (focusCancel) {
          buttons.reverse();
        }
        return buttons.concat(Array.prototype.slice.call(getModal().querySelectorAll('button:not([class^=' + swalPrefix + ']), input:not([type=hidden]), textarea, select')));
      };

      var hasClass = function hasClass(elem, className) {
        return elem.classList.contains(className);
      };

      var focusInput = function focusInput(input) {
        input.focus();

        // http://stackoverflow.com/a/2345915/1331425
        var val = input.value;
        input.value = '';
        input.value = val;
      };

      var addClass = function addClass(elem, className) {
        if (!elem || !className) {
          return;
        }
        var classes = className.split(/\s+/);
        classes.forEach(function (className) {
          elem.classList.add(className);
        });
      };

      var removeClass = function removeClass(elem, className) {
        if (!elem || !className) {
          return;
        }
        var classes = className.split(/\s+/);
        classes.forEach(function (className) {
          elem.classList.remove(className);
        });
      };

      var getChildByClass = function getChildByClass(elem, className) {
        for (var i = 0; i < elem.childNodes.length; i++) {
          if (hasClass(elem.childNodes[i], className)) {
            return elem.childNodes[i];
          }
        }
      };

      var _show = function _show(elem) {
        elem.style.opacity = '';
        elem.style.display = 'block';
      };

      var show = function show(elems) {
        if (elems && !elems.length) {
          return _show(elems);
        }
        for (var i = 0; i < elems.length; ++i) {
          _show(elems[i]);
        }
      };

      var _hide = function _hide(elem) {
        elem.style.opacity = '';
        elem.style.display = 'none';
      };

      var hide = function hide(elems) {
        if (elems && !elems.length) {
          return _hide(elems);
        }
        for (var i = 0; i < elems.length; ++i) {
          _hide(elems[i]);
        }
      };

      // borrowed from jqeury $(elem).is(':visible') implementation
      var isVisible = function isVisible(elem) {
        return elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length;
      };

      var removeStyleProperty = function removeStyleProperty(elem, property) {
        if (elem.style.removeProperty) {
          elem.style.removeProperty(property);
        } else {
          elem.style.removeAttribute(property);
        }
      };

      var getTopMargin = function getTopMargin(elem) {
        var elemDisplay = elem.style.display;
        elem.style.left = '-9999px';
        elem.style.display = 'block';

        var height = elem.clientHeight;

        elem.style.left = '';
        elem.style.display = elemDisplay;
        return '-' + parseInt(height / 2, 10) + 'px';
      };

      var fadeIn = function fadeIn(elem, interval) {
        if (+elem.style.opacity < 1) {
          interval = interval || 16;
          elem.style.opacity = 0;
          elem.style.display = 'block';
          var last = +new Date();
          var tick = function tick() {
            var newOpacity = +elem.style.opacity + (new Date() - last) / 100;
            elem.style.opacity = newOpacity > 1 ? 1 : newOpacity;
            last = +new Date();

            if (+elem.style.opacity < 1) {
              setTimeout(tick, interval);
            }
          };
          tick();
        }
      };

      var fadeOut = function fadeOut(elem, interval) {
        if (+elem.style.opacity > 0) {
          interval = interval || 16;
          var opacity = elem.style.opacity;
          var last = +new Date();
          var tick = function tick() {
            var change = new Date() - last;
            var newOpacity = +elem.style.opacity - change / (opacity * 100);
            elem.style.opacity = newOpacity;
            last = +new Date();

            if (+elem.style.opacity > 0) {
              setTimeout(tick, interval);
            } else {
              _hide(elem);
            }
          };
          tick();
        }
      };

      var fireClick = function fireClick(node) {
        // Taken from http://www.nonobtrusive.com/2011/11/29/programatically-fire-crossbrowser-click-event-with-javascript/
        // Then fixed for today's Chrome browser.
        if (typeof MouseEvent === 'function') {
          // Up-to-date approach
          var mevt = new MouseEvent('click', {
            view: window,
            bubbles: false,
            cancelable: true
          });
          node.dispatchEvent(mevt);
        } else if (document.createEvent) {
          // Fallback
          var evt = document.createEvent('MouseEvents');
          evt.initEvent('click', false, false);
          node.dispatchEvent(evt);
        } else if (document.createEventObject) {
          node.fireEvent('onclick');
        } else if (typeof node.onclick === 'function') {
          node.onclick();
        }
      };

      var stopEventPropagation = function stopEventPropagation(e) {
        // In particular, make sure the space bar doesn't scroll the main window.
        if (typeof e.stopPropagation === 'function') {
          e.stopPropagation();
          e.preventDefault();
        } else if (window.event && window.event.hasOwnProperty('cancelBubble')) {
          window.event.cancelBubble = true;
        }
      };

      var animationEndEvent = function () {
        var testEl = document.createElement('div'),
            transEndEventNames = {
          'WebkitAnimation': 'webkitAnimationEnd',
          'OAnimation': 'oAnimationEnd oanimationend',
          'msAnimation': 'MSAnimationEnd',
          'animation': 'animationend'
        };
        for (var i in transEndEventNames) {
          if (transEndEventNames.hasOwnProperty(i) && testEl.style[i] !== undefined) {
            return transEndEventNames[i];
          }
        }

        return false;
      }();

      // Reset the page to its previous state
      var resetPrevState = function resetPrevState() {
        var modal = getModal();
        window.onkeydown = states.previousWindowKeyDown;
        if (states.previousActiveElement && states.previousActiveElement.focus) {
          states.previousActiveElement.focus();
        }
        clearTimeout(modal.timeout);

        // Remove dynamically created media query
        var head = document.getElementsByTagName('head')[0];
        var mediaquery = document.getElementById(mediaqueryId);
        if (mediaquery) {
          head.removeChild(mediaquery);
        }
      };

      var modalParams = extend({}, defaultParams);

      /*
       * Set type, text and actions on modal
       */
      var setParameters = function setParameters(params) {
        var modal = getModal();

        for (var param in params) {
          if (!defaultParams.hasOwnProperty(param) && param !== 'extraParams') {
            console.warn('SweetAlert2: Unknown parameter "' + param + '"');
          }
        }

        // set modal width, padding and margin-left
        modal.style.width = params.width + 'px';
        modal.style.padding = params.padding + 'px';
        modal.style.marginLeft = -params.width / 2 + 'px';
        modal.style.background = params.background;

        // add dynamic media query css
        var head = document.getElementsByTagName('head')[0];
        var cssNode = document.createElement('style');
        cssNode.type = 'text/css';
        cssNode.id = mediaqueryId;
        var margin = 5; // %
        var mediaQueryMaxWidth = params.width + parseInt(params.width * (margin / 100) * 2, 10);
        cssNode.innerHTML = '@media screen and (max-width: ' + mediaQueryMaxWidth + 'px) {' + '.' + swalClasses.modal + ' {' + 'width: auto !important;' + 'left: ' + margin + '% !important;' + 'right: ' + margin + '% !important;' + 'margin-left: 0 !important;' + '}' + '}';
        head.appendChild(cssNode);

        var $title = modal.querySelector('h2');
        var $content = modal.querySelector('.' + swalClasses.content);
        var $confirmBtn = getConfirmButton();
        var $cancelBtn = getCancelButton();
        var $spacer = modal.querySelector('.' + swalClasses.spacer);
        var $closeButton = modal.querySelector('.' + swalClasses.close);

        // Title
        $title.innerHTML = params.title.split('\n').join('<br>');

        // Content
        if (params.text || params.html) {
          if (_typeof(params.html) === 'object') {
            $content.innerHTML = '';
            if (0 in params.html) {
              for (var i = 0; i in params.html; i++) {
                $content.appendChild(params.html[i]);
              }
            } else {
              $content.appendChild(params.html);
            }
          } else {
            $content.innerHTML = params.html || params.text.split('\n').join('<br>');
          }
          show($content);
        } else {
          hide($content);
        }

        // Close button
        if (params.showCloseButton) {
          show($closeButton);
        } else {
          hide($closeButton);
        }

        // Custom Class
        modal.className = swalClasses.modal;
        if (params.customClass) {
          addClass(modal, params.customClass);
        }

        // Icon
        hide(modal.querySelectorAll('.' + swalClasses.icon));
        if (params.type) {
          var validType = false;
          for (var iconType in iconTypes) {
            if (params.type === iconType) {
              validType = true;
              break;
            }
          }
          if (!validType) {
            console.error('SweetAlert2: Unknown alert type: ' + params.type);
            return false;
          }
          var $icon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes[params.type]);
          show($icon);

          // Animate icon
          switch (params.type) {
            case 'success':
              addClass($icon, 'animate');
              addClass($icon.querySelector('.tip'), 'animate-success-tip');
              addClass($icon.querySelector('.long'), 'animate-success-long');
              break;
            case 'error':
              addClass($icon, 'animate-error-icon');
              addClass($icon.querySelector('.x-mark'), 'animate-x-mark');
              break;
            case 'warning':
              addClass($icon, 'pulse-warning');
              break;
            default:
              break;
          }
        }

        // Custom image
        var $customImage = modal.querySelector('.' + swalClasses.image);
        if (params.imageUrl) {
          $customImage.setAttribute('src', params.imageUrl);
          show($customImage);

          if (params.imageWidth) {
            $customImage.setAttribute('width', params.imageWidth);
          } else {
            $customImage.removeAttribute('width');
          }

          if (params.imageHeight) {
            $customImage.setAttribute('height', params.imageHeight);
          } else {
            $customImage.removeAttribute('height');
          }

          $customImage.className = swalClasses.image;
          if (params.imageClass) {
            addClass($customImage, params.imageClass);
          }
        } else {
          hide($customImage);
        }

        // Cancel button
        if (params.showCancelButton) {
          $cancelBtn.style.display = 'inline-block';
        } else {
          hide($cancelBtn);
        }

        // Confirm button
        if (params.showConfirmButton) {
          removeStyleProperty($confirmBtn, 'display');
        } else {
          hide($confirmBtn);
        }

        // Buttons spacer
        if (!params.showConfirmButton && !params.showCancelButton) {
          hide($spacer);
        } else {
          show($spacer);
        }

        // Edit text on cancel and confirm buttons
        $confirmBtn.innerHTML = params.confirmButtonText;
        $cancelBtn.innerHTML = params.cancelButtonText;

        // Set buttons to selected background colors
        if (params.buttonsStyling) {
          $confirmBtn.style.backgroundColor = params.confirmButtonColor;
          $cancelBtn.style.backgroundColor = params.cancelButtonColor;
        }

        // Add buttons custom classes
        $confirmBtn.className = swalClasses.confirm;
        addClass($confirmBtn, params.confirmButtonClass);
        $cancelBtn.className = swalClasses.cancel;
        addClass($cancelBtn, params.cancelButtonClass);

        // Buttons styling
        if (params.buttonsStyling) {
          addClass($confirmBtn, 'styled');
          addClass($cancelBtn, 'styled');
        } else {
          removeClass($confirmBtn, 'styled');
          removeClass($cancelBtn, 'styled');

          $confirmBtn.style.backgroundColor = $confirmBtn.style.borderLeftColor = $confirmBtn.style.borderRightColor = '';
          $cancelBtn.style.backgroundColor = $cancelBtn.style.borderLeftColor = $cancelBtn.style.borderRightColor = '';
        }

        // CSS animation
        if (params.animation === true) {
          removeClass(modal, 'no-animation');
        } else {
          addClass(modal, 'no-animation');
        }
      };

      /*
       * Animations
       */
      var openModal = function openModal(animation, onComplete) {
        var modal = getModal();
        if (animation) {
          fadeIn(getOverlay(), 10);
          addClass(modal, 'show-swal2');
          removeClass(modal, 'hide-swal2');
        } else {
          show(getOverlay());
        }
        show(modal);
        states.previousActiveElement = document.activeElement;
        if (onComplete !== null && typeof onComplete === 'function') {
          onComplete.call(this, modal);
        }
      };

      /*
       * Set 'margin-top'-property on modal based on its computed height
       */
      var fixVerticalPosition = function fixVerticalPosition() {
        var modal = getModal();

        if (modal !== null) {
          modal.style.marginTop = getTopMargin(modal);
        }
      };

      function modalDependant() {

        if (arguments[0] === undefined) {
          console.error('SweetAlert2 expects at least 1 attribute!');
          return false;
        }

        var params = extend({}, modalParams);

        switch (_typeof(arguments[0])) {

          case 'string':
            params.title = arguments[0];
            params.text = arguments[1] || '';
            params.type = arguments[2] || '';

            break;

          case 'object':
            extend(params, arguments[0]);
            params.extraParams = arguments[0].extraParams;

            if (params.input === 'email' && params.inputValidator === null) {
              params.inputValidator = function (email) {
                return new Promise(function (resolve, reject) {
                  var emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
                  if (emailRegex.test(email)) {
                    resolve();
                  } else {
                    reject('Invalid email address');
                  }
                });
              };
            }

            break;

          default:
            console.error('SweetAlert2: Unexpected type of argument! Expected "string" or "object", got ' + _typeof(arguments[0]));
            return false;
        }

        setParameters(params);

        // Modal interactions
        var modal = getModal();

        return new Promise(function (resolve, reject) {
          // Close on timer
          if (params.timer) {
            modal.timeout = setTimeout(function () {
              sweetAlert.closeModal(params.onClose);
              reject('timer');
            }, params.timer);
          }

          var getInput = function getInput() {
            switch (params.input) {
              case 'select':
                return getChildByClass(modal, swalClasses.select);
              case 'radio':
                return modal.querySelector('.' + swalClasses.radio + ' input:checked') || modal.querySelector('.' + swalClasses.radio + ' input:first-child');
              case 'checkbox':
                return modal.querySelector('#' + swalClasses.checkbox);
              case 'textarea':
                return getChildByClass(modal, swalClasses.textarea);
              default:
                return getChildByClass(modal, swalClasses.input);
            }
          };
          var getInputValue = function getInputValue() {
            var input = getInput();
            switch (params.input) {
              case 'checkbox':
                return input.checked ? 1 : 0;
              case 'radio':
                return input.checked ? input.value : null;
              case 'file':
                return input.files.length ? input.files[0] : null;
              default:
                return params.inputAutoTrim ? input.value.trim() : input.value;
            }
          };

          if (params.input) {
            setTimeout(function () {
              var input = getInput();
              if (input) {
                focusInput(input);
              }
            }, 0);
          }

          var confirm = function confirm(value) {
            if (params.showLoaderOnConfirm) {
              sweetAlert.showLoading();
            }

            if (params.preConfirm) {
              params.preConfirm(value, params.extraParams).then(function (preConfirmValue) {
                sweetAlert.closeModal(params.onClose);
                resolve(preConfirmValue || value);
              }, function (error) {
                sweetAlert.hideLoading();
                if (error) {
                  sweetAlert.showValidationError(error);
                }
              });
            } else {
              sweetAlert.closeModal(params.onClose);
              resolve(value);
            }
          };

          // Mouse interactions
          var onButtonEvent = function onButtonEvent(event) {
            var e = event || window.event;
            var target = e.target || e.srcElement;
            var confirmBtn = getConfirmButton();
            var cancelBtn = getCancelButton();
            var targetedConfirm = confirmBtn === target || confirmBtn.contains(target);
            var targetedCancel = cancelBtn === target || cancelBtn.contains(target);

            switch (e.type) {
              case 'mouseover':
              case 'mouseup':
                if (params.buttonsStyling) {
                  if (targetedConfirm) {
                    confirmBtn.style.backgroundColor = colorLuminance(params.confirmButtonColor, -0.1);
                  } else if (targetedCancel) {
                    cancelBtn.style.backgroundColor = colorLuminance(params.cancelButtonColor, -0.1);
                  }
                }
                break;
              case 'mouseout':
                if (params.buttonsStyling) {
                  if (targetedConfirm) {
                    confirmBtn.style.backgroundColor = params.confirmButtonColor;
                  } else if (targetedCancel) {
                    cancelBtn.style.backgroundColor = params.cancelButtonColor;
                  }
                }
                break;
              case 'mousedown':
                if (params.buttonsStyling) {
                  if (targetedConfirm) {
                    confirmBtn.style.backgroundColor = colorLuminance(params.confirmButtonColor, -0.2);
                  } else if (targetedCancel) {
                    cancelBtn.style.backgroundColor = colorLuminance(params.cancelButtonColor, -0.2);
                  }
                }
                break;
              case 'click':
                // Clicked 'confirm'
                if (targetedConfirm && sweetAlert.isVisible()) {
                  if (params.input) {
                    var inputValue = getInputValue();

                    if (params.inputValidator) {
                      sweetAlert.disableInput();
                      params.inputValidator(inputValue, params.extraParams).then(function () {
                        sweetAlert.enableInput();
                        confirm(inputValue);
                      }, function (error) {
                        sweetAlert.enableInput();
                        if (error) {
                          sweetAlert.showValidationError(error);
                        }
                      });
                    } else {
                      confirm(inputValue);
                    }
                  } else {
                    confirm(true);
                  }

                  // Clicked 'cancel'
                } else if (targetedCancel && sweetAlert.isVisible()) {
                  sweetAlert.closeModal(params.onClose);
                  reject('cancel');
                }

                break;
              default:
            }
          };

          var $buttons = modal.querySelectorAll('button');
          var i;
          for (i = 0; i < $buttons.length; i++) {
            $buttons[i].onclick = onButtonEvent;
            $buttons[i].onmouseover = onButtonEvent;
            $buttons[i].onmouseout = onButtonEvent;
            $buttons[i].onmousedown = onButtonEvent;
          }

          // Closing modal by close button
          getCloseButton().onclick = function () {
            sweetAlert.closeModal(params.onClose);
            reject('close');
          };

          // Closing modal by overlay click
          getOverlay().onclick = function () {
            if (params.allowOutsideClick) {
              sweetAlert.closeModal(params.onClose);
              reject('overlay');
            }
          };

          var $confirmButton = getConfirmButton();
          var $cancelButton = getCancelButton();

          // Reverse buttons if neede d
          if (params.reverseButtons) {
            $confirmButton.parentNode.insertBefore($cancelButton, $confirmButton);
          } else {
            $confirmButton.parentNode.insertBefore($confirmButton, $cancelButton);
          }

          // Focus handling
          function setFocus(index, increment) {
            var focusableElements = getFocusableElements(params.focusCancel);
            // search for visible elements and select the next possible match
            for (var i = 0; i < focusableElements.length; i++) {
              index = index + increment;

              // rollover to first item
              if (index === focusableElements.length) {
                index = 0;

                // go to last item
              } else if (index === -1) {
                index = focusableElements.length - 1;
              }

              // determine if element is visible
              var el = focusableElements[index];
              if (isVisible(el)) {
                return el.focus();
              }
            }
          }

          function handleKeyDown(event) {
            var e = event || window.event;
            var keyCode = e.keyCode || e.which;

            if ([9, 13, 32, 27].indexOf(keyCode) === -1) {
              // Don't do work on keys we don't care about.
              return;
            }

            var $targetElement = e.target || e.srcElement;

            var focusableElements = getFocusableElements(params.focusCancel);
            var btnIndex = -1; // Find the button - note, this is a nodelist, not an array.
            for (var i = 0; i < focusableElements.length; i++) {
              if ($targetElement === focusableElements[i]) {
                btnIndex = i;
                break;
              }
            }

            // TAB
            if (keyCode === 9) {
              if (!e.shiftKey) {
                // Cycle to the next button
                setFocus(btnIndex, 1);
              } else {
                // Cycle to the prev button
                setFocus(btnIndex, -1);
              }

              stopEventPropagation(e);
            } else {
              if (keyCode === 13 || keyCode === 32) {
                if (btnIndex === -1) {
                  // ENTER/SPACE clicked outside of a button.
                  if (params.focusCancel) {
                    fireClick($cancelButton, e);
                  } else {
                    fireClick($confirmButton, e);
                  }
                }
              } else if (keyCode === 27 && params.allowEscapeKey === true) {
                sweetAlert.closeModal(params.onClose);
                reject('esc');
              }
            }
          }

          states.previousWindowKeyDown = window.onkeydown;
          window.onkeydown = handleKeyDown;

          // Loading state
          if (params.buttonsStyling) {
            $confirmButton.style.borderLeftColor = params.confirmButtonColor;
            $confirmButton.style.borderRightColor = params.confirmButtonColor;
          }

          /**
           * Show spinner instead of Confirm button and disable Cancel button
           */
          sweetAlert.showLoading = sweetAlert.enableLoading = function () {
            addClass($confirmButton, 'loading');
            addClass(modal, 'loading');
            $confirmButton.disabled = true;
            $cancelButton.disabled = true;
          };

          /**
           * Show spinner instead of Confirm button and disable Cancel button
           */
          sweetAlert.hideLoading = sweetAlert.disableLoading = function () {
            removeClass($confirmButton, 'loading');
            removeClass(modal, 'loading');
            $confirmButton.disabled = false;
            $cancelButton.disabled = false;
          };

          sweetAlert.enableButtons = function () {
            $confirmButton.disabled = false;
            $cancelButton.disabled = false;
          };

          sweetAlert.disableButtons = function () {
            $confirmButton.disabled = true;
            $cancelButton.disabled = true;
          };

          sweetAlert.enableConfirmButton = function () {
            $confirmButton.disabled = false;
          };

          sweetAlert.disableConfirmButton = function () {
            $confirmButton.disabled = true;
          };

          sweetAlert.enableInput = function () {
            var input = getInput();
            if (input.type === 'radio') {
              var radiosContainer = input.parentNode.parentNode;
              var radios = radiosContainer.querySelectorAll('input');
              for (var i = 0; i < radios.length; i++) {
                radios[i].disabled = false;
              }
            } else {
              input.disabled = false;
            }
          };

          sweetAlert.disableInput = function () {
            var input = getInput();
            if (input.type === 'radio') {
              var radiosContainer = input.parentNode.parentNode;
              var radios = radiosContainer.querySelectorAll('input');
              for (var i = 0; i < radios.length; i++) {
                radios[i].disabled = true;
              }
            } else {
              input.disabled = true;
            }
          };

          sweetAlert.showValidationError = function (error) {
            var $validationError = modal.querySelector('.' + swalClasses.validationerror);
            $validationError.innerHTML = error;
            show($validationError);

            var input = getInput();
            focusInput(input);
            addClass(input, 'error');
          };

          sweetAlert.resetValidationError = function () {
            var $validationError = modal.querySelector('.' + swalClasses.validationerror);
            hide($validationError);

            var input = getInput();
            if (input) {
              removeClass(input, 'error');
            }
          };

          sweetAlert.enableButtons();
          sweetAlert.hideLoading();
          sweetAlert.resetValidationError();

          // input, select
          var inputTypes = ['input', 'select', 'radio', 'checkbox', 'textarea'];
          var input;
          for (i = 0; i < inputTypes.length; i++) {
            var inputClass = swalClasses[inputTypes[i]];
            input = getChildByClass(modal, inputClass);

            // set attributes
            while (input.attributes.length > 0) {
              input.removeAttribute(input.attributes[0].name);
            }
            for (var attr in params.inputAttributes) {
              input.setAttribute(attr, params.inputAttributes[attr]);
            }

            // set class
            input.className = inputClass;
            if (params.inputClass) {
              addClass(input, params.inputClass);
            }

            _hide(input);
          }

          var populateInputOptions;
          switch (params.input) {
            case 'text':
            case 'email':
            case 'password':
            case 'file':
              input = getChildByClass(modal, swalClasses.input);
              input.value = params.inputValue;
              input.placeholder = params.inputPlaceholder;
              input.type = params.input;
              _show(input);
              break;
            case 'select':
              var select = getChildByClass(modal, swalClasses.select);
              select.innerHTML = '';
              if (params.inputPlaceholder) {
                var placeholder = document.createElement('option');
                placeholder.innerHTML = params.inputPlaceholder;
                placeholder.value = '';
                placeholder.disabled = true;
                placeholder.selected = true;
                select.appendChild(placeholder);
              }
              populateInputOptions = function populateInputOptions(inputOptions) {
                for (var optionValue in inputOptions) {
                  var option = document.createElement('option');
                  option.value = optionValue;
                  option.innerHTML = inputOptions[optionValue];
                  if (params.inputValue === optionValue) {
                    option.selected = true;
                  }
                  select.appendChild(option);
                }
                _show(select);
                select.focus();
              };
              break;
            case 'radio':
              var radio = getChildByClass(modal, swalClasses.radio);
              radio.innerHTML = '';
              populateInputOptions = function populateInputOptions(inputOptions) {
                for (var radioValue in inputOptions) {
                  var id = 1;
                  var radioInput = document.createElement('input');
                  var radioLabel = document.createElement('label');
                  var radioLabelSpan = document.createElement('span');
                  radioInput.type = 'radio';
                  radioInput.name = swalClasses.radio;
                  radioInput.value = radioValue;
                  radioInput.id = swalClasses.radio + '-' + id++;
                  if (params.inputValue === radioValue) {
                    radioInput.checked = true;
                  }
                  radioLabelSpan.innerHTML = inputOptions[radioValue];
                  radioLabel.appendChild(radioInput);
                  radioLabel.appendChild(radioLabelSpan);
                  radioLabel.for = radioInput.id;
                  radio.appendChild(radioLabel);
                }
                _show(radio);
                var radios = radio.querySelectorAll('input');
                if (radios.length) {
                  radios[0].focus();
                }
              };
              break;
            case 'checkbox':
              var checkbox = getChildByClass(modal, swalClasses.checkbox);
              var checkboxInput = modal.querySelector('#' + swalClasses.checkbox);
              checkboxInput.value = 1;
              checkboxInput.checked = Boolean(params.inputValue);
              var label = checkbox.getElementsByTagName('span');
              if (label.length) {
                checkbox.removeChild(label[0]);
              }
              label = document.createElement('span');
              label.innerHTML = params.inputPlaceholder;
              checkbox.appendChild(label);
              _show(checkbox);
              break;
            case 'textarea':
              var textarea = getChildByClass(modal, swalClasses.textarea);
              textarea.value = params.inputValue;
              textarea.placeholder = params.inputPlaceholder;
              _show(textarea);
              break;
            case null:
              break;
            default:
              console.error('SweetAlert2: Unexpected type of input! Expected "text" or "email" or "password", "select", "checkbox", "textarea" or "file", got "' + params.input + '"');
              break;
          }

          if (params.input === 'select' || params.input === 'radio') {
            if (params.inputOptions instanceof Promise) {
              sweetAlert.showLoading();
              params.inputOptions.then(function (inputOptions) {
                sweetAlert.hideLoading();
                populateInputOptions(inputOptions);
              });
            } else if (_typeof(params.inputOptions) === 'object') {
              populateInputOptions(params.inputOptions);
            } else {
              console.error('SweetAlert2: Unexpected type of inputOptions! Expected object or Promise, got ' + _typeof(params.inputOptions));
            }
          }

          fixVerticalPosition();
          openModal(params.animation, params.onOpen);

          // Focus the first element (input or button)
          setFocus(-1, 1);
        });
      }

      // SweetAlert function
      function sweetAlert() {
        // Copy arguments to the local args variable
        var args = arguments;
        var modal = getModal();

        if (modal === null) {
          sweetAlert.init();
          modal = getModal();
        }

        if (sweetAlert.isVisible()) {
          resetPrevState();
        }

        return modalDependant.apply(this, args);
      }

      /*
       * Global function to determine if swal2 modal is visible
       */
      sweetAlert.isVisible = function () {
        var modal = getModal();
        return isVisible(modal);
      };

      /*
       * Global function for chaining sweetAlert modals
       */
      sweetAlert.queue = function (steps) {
        return new Promise(function (resolve, reject) {
          (function step(i, callback) {
            var nextStep = null;
            if (isFunction(steps)) {
              nextStep = steps(i);
            } else if (i < steps.length) {
              nextStep = steps[i];
            }
            if (nextStep) {
              sweetAlert(nextStep).then(function () {
                step(i + 1, callback);
              }, function (dismiss) {
                reject(dismiss);
              });
            } else {
              resolve();
            }
          })(0);
        });
      };

      /*
       * Global function to close sweetAlert
       */
      sweetAlert.close = sweetAlert.closeModal = function (onComplete) {
        var modal = getModal();
        removeClass(modal, 'show-swal2');
        addClass(modal, 'hide-swal2');

        // Reset icon animations
        var $successIcon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes.success);
        removeClass($successIcon, 'animate');
        removeClass($successIcon.querySelector('.tip'), 'animate-success-tip');
        removeClass($successIcon.querySelector('.long'), 'animate-success-long');

        var $errorIcon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes.error);
        removeClass($errorIcon, 'animate-error-icon');
        removeClass($errorIcon.querySelector('.x-mark'), 'animate-x-mark');

        var $warningIcon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes.warning);
        removeClass($warningIcon, 'pulse-warning');

        // If animation is supported, animate then clean
        if (animationEndEvent && !hasClass(modal, 'no-animation')) {
          modal.addEventListener(animationEndEvent, function swalCloseEventFinished() {
            modal.removeEventListener(animationEndEvent, swalCloseEventFinished);
            if (hasClass(modal, 'hide-swal2')) {
              _hide(modal);
              fadeOut(getOverlay(), 0);
            }

            resetPrevState();
          });
        } else {
          // Otherwise, clean immediately
          _hide(modal);
          _hide(getOverlay());
          resetPrevState();
        }
        if (onComplete !== null && typeof onComplete === 'function') {
          onComplete.call(this, modal);
        }
      };

      /*
       * Global function to click 'Confirm' button
       */
      sweetAlert.clickConfirm = function () {
        getConfirmButton().click();
      };

      /*
       * Global function to click 'Cancel' button
       */
      sweetAlert.clickCancel = function () {
        getCancelButton().click();
      };

      /*
       * Add modal + overlay to DOM
       */
      sweetAlert.init = function () {
        if (typeof document === 'undefined') {
          console.log('SweetAlert2 requires document to initialize');
          return;
        } else if (document.getElementsByClassName(swalClasses.container).length) {
          return;
        }

        var sweetWrap = document.createElement('div');
        sweetWrap.className = swalClasses.container;

        sweetWrap.innerHTML = sweetHTML;

        document.body.appendChild(sweetWrap);

        var modal = getModal();
        var $input = getChildByClass(modal, swalClasses.input);
        var $select = getChildByClass(modal, swalClasses.select);
        var $checkbox = modal.querySelector('#' + swalClasses.checkbox);
        var $textarea = getChildByClass(modal, swalClasses.textarea);
        var $customImg = getChildByClass(modal, swalClasses.image);

        $input.oninput = function () {
          sweetAlert.resetValidationError();
        };

        $input.onkeyup = function (event) {
          event.stopPropagation();
          if (event.keyCode === 13) {
            sweetAlert.clickConfirm();
          }
        };

        $select.onchange = function () {
          sweetAlert.resetValidationError();
        };

        $checkbox.onchange = function () {
          sweetAlert.resetValidationError();
        };

        $textarea.oninput = function () {
          sweetAlert.resetValidationError();
        };

        $customImg.onload = $customImg.onerror = fixVerticalPosition;

        window.addEventListener('resize', fixVerticalPosition, false);
      };

      /**
       * Set default params for each popup
       * @param {Object} userParams
       */
      sweetAlert.setDefaults = function (userParams) {
        if (!userParams) {
          throw new Error('userParams is required');
        }
        if ((typeof userParams === "undefined" ? "undefined" : _typeof(userParams)) !== 'object') {
          throw new Error('userParams has to be a object');
        }

        extend(modalParams, userParams);
      };

      /**
       * Reset default params for each popup
       */
      sweetAlert.resetDefaults = function () {
        modalParams = extend({}, defaultParams);
      };

      sweetAlert.version = '4.1.9';

      window.sweetAlert = window.swal = sweetAlert;

      /*
      * If library is injected after page has loaded
      */
      (function () {
        if (document.readyState === 'complete' || document.readyState === 'interactive' && document.body) {
          sweetAlert.init();
        } else {
          document.addEventListener('DOMContentLoaded', function onDomContentLoaded() {
            document.removeEventListener('DOMContentLoaded', onDomContentLoaded, false);
            sweetAlert.init();
          }, false);
        }
      })();

      if (typeof Promise === 'function') {
        Promise.prototype.done = Promise.prototype.done || function () {
          return this.catch(function () {
            // Catch promise rejections silently.
            // https://github.com/limonte/sweetalert2/issues/177
          });
        };
      } else {
        console.warn('SweetAlert2: Please inlude Promise polyfill BEFORE including sweetalert2.js if IE10+ support needed.');
      }

      return sweetAlert;
    });
  }, {}], 16: [function (require, module, exports) {
    exports = module.exports = stringify;
    exports.getSerialize = serializer;

    function stringify(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
    }

    function serializer(replacer, cycleReplacer) {
      var stack = [],
          keys = [];

      if (cycleReplacer == null) cycleReplacer = function cycleReplacer(key, value) {
        if (stack[0] === value) return "[Circular ~]";
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };

      return function (key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
          if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value);
        } else stack.push(value);

        return replacer == null ? value : replacer.call(this, key, value);
      };
    }
  }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.base').config(appConfig);

        appConfig.$inject = ['$stateProvider'];
        function appConfig($stateProvider) {
            $stateProvider.state('base', {
                controller: BaseController,
                ncyBreadcrumb: {
                    label: 'Lily'
                }
            });
        }

        angular.module('app.base').controller('BaseController', BaseController);

        BaseController.$inject = ['$scope', '$state', '$http', 'AppHash', 'Settings', 'HLShortcuts'];
        function BaseController($scope, $state, $http, AppHash, Settings, HLShortcuts) {
            // Make sure the settings are available everywhere.
            $scope.settings = Settings;

            $scope.loadNotifications = loadNotifications;

            activate();

            //////////

            function activate() {
                $scope.$on('$stateChangeStart', function () {
                    AppHash.get().$promise.then(function (response) {
                        // App hash is set, so compare with the response.
                        if (window.appHash && window.appHash !== response.app_hash) {
                            // Reload the page so we get new static files.
                            window.location.reload(true);
                        } else {
                            window.appHash = response.app_hash;
                        }
                    });

                    new window.Intercom('update', { email: currentUser.email });
                });

                $scope.$on('$stateChangeSuccess', _setPreviousState);
                $scope.$on('$viewContentLoaded', _contentLoadedActions);

                $scope.$on('$stateChangeError', _handleResolveErrors);
            }

            function loadNotifications() {
                $http.get('/api/utils/notifications/').then(function (notifications) {
                    // On success
                    angular.forEach(notifications.data, function (message) {
                        toastr[message.level](message.message);
                    });
                }, function (error) {
                    // On error
                    toastr.error(error, 'Couldn\'t load notifications');
                });
            }

            function _setPreviousState(event, toState, toParams, fromState, fromParams) {
                var previousInbox;

                $scope.previousState = $state.href(fromState, fromParams);
                Settings.page.previousState = { state: fromState, params: fromParams };

                if (fromState.name === 'base.email.list' || fromState.name === 'base.email.accountList') {
                    previousInbox = {
                        state: fromState.name,
                        params: fromParams
                    };

                    Settings.email.setPreviousInbox(previousInbox);
                }

                if (Settings.email.sidebar && fromState && fromState.name === 'base.email.detail') {
                    Settings.email.resetEmailSettings();

                    $scope.$$phase || $scope.apply();
                }

                Settings.page.toolbar.data = null;

                // For some reason we need to do two update calls to display messages
                // when they should.
                new window.Intercom('update', { email: currentUser.email });
            }

            function _contentLoadedActions() {
                Metronic.unblockUI();
                Metronic.initComponents(); // init core components
                //HLSelect2.init();
                //HLFormsets.init();
                autosize($('textarea'));

                //$scope.loadNotifications();
                $scope.toolbar = Settings.page.toolbar.data;
            }

            function _handleResolveErrors(event, toState, toParams, fromState, fromParams, error) {
                switch (error.status) {
                    case 404:
                        $state.go('base.404');
                        break;
                    default:
                        // With JS errors, error isn't an object, but still the default case gets called.
                        $state.go('base.500');
                }
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }return s;
})({ 1: [function (require, module, exports) {
    angular.module('app.base').controller('footerController', footerController);

    footerController.$inject = ['$scope'];
    function footerController($scope) {}
  }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.base').controller('headerController', headerController);

        headerController.$inject = ['$scope'];
        function headerController($scope) {
            $scope.$on('$includeContentLoaded', function () {
                Layout.initHeader(); // init header
            });
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.base').controller('sidebarController', sidebarController);

        sidebarController.$inject = ['$scope'];
        function sidebarController($scope) {
            $scope.$on('$includeContentLoaded', function () {
                Layout.initSidebar(); // init sidebar
            });
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('activateSelect', activateSelect);

        function activateSelect($timeout) {
            return {
                restrict: 'A',
                require: '?uiSelect',
                link: function link(scope, element, attrs, $select) {
                    // TODO: Once Select2 implements default select behaviour we can convert all
                    // current normal selects to Select2. After that we can uncomment this code
                    // and make it so selects automatically get opened when inline editing.
                    // Note: When building the app minified look out for the following error:
                    // vendor.js:6 Error: [$injector:unpr] Unknown provider: rProvider <- r <- activateSelectDirective
                    // This doesn't happen when building normally (and not sure if it happens on live.), but something
                    // that needs to be looked at.
                    // scope.$watch('$form.$visible', function() {
                    //     $timeout(function() {
                    // Open the select on the next digest cycle.
                    // if ($select) {
                    // $select.activate();
                    // }
                    //     });
                    // });
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('autofocusIf', autofocusIf);

        function autofocusIf() {
            return {
                restrict: 'A',
                link: function link(scope, element, attrs) {
                    scope.$watch(function () {
                        return scope.$eval(attrs.autofocusIf);
                    }, function (bool) {
                        if (bool === true) {
                            element[0].focus();
                        }
                    });
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('callerInfo', callerInfo);

        function callerInfo() {
            return {
                restrict: 'E',
                scope: true,
                templateUrl: 'base/directives/caller_info.html',
                controller: CallerInfoController,
                controllerAs: 'vm',
                transclude: true,
                bindToController: true
            };
        }

        CallerInfoController.$inject = ['$state', 'Account', 'Call'];
        function CallerInfoController($state, Account, Call) {
            var vm = this;

            vm.fetchCallerInfo = fetchCallerInfo;

            function fetchCallerInfo() {
                // Get the latest call of the current user based on the internal number.
                Call.getLatestCall().$promise.then(function (callInfo) {
                    var call = callInfo.call;

                    if (call) {
                        // There was a call for the current user, so try to find an account with the given number.
                        Account.searchByPhoneNumber({ number: call.caller_number }).$promise.then(function (response) {
                            if (response.data.accounts.length) {
                                // Account found so redirect to the account.
                                $state.go('base.accounts.detail', { id: response.data.accounts[0] }, { reload: true });
                            } else if (response.data.contacts.length) {
                                // Contact found so redirect to the contact.
                                $state.go('base.contacts.detail', { id: response.data.contacts[0] }, { reload: true });
                            } else {
                                // No account or contact found so redirect to create account form.
                                $state.go('base.accounts.create', {
                                    'name': call.caller_name,
                                    'phone_number': call.caller_number
                                }, { reload: true });
                            }
                        });
                    } else {
                        toastr.error('No calls for you right now', 'No calls');
                    }
                });
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * checkbox Directive makes a nice uniform checkbox and binds to a model
         *
         * @param model object: model to bind checkbox with
         *
         * Example:
         * <checkbox model="table.visibility.name">Name</checkbox>
         */
        angular.module('app.directives').directive('checkbox', checkbox);

        function checkbox() {
            return {
                restrict: 'E',
                replace: true,
                transclude: true,
                scope: {
                    model: '='
                },
                templateUrl: 'base/directives/checkbox.html'
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * Directive give a nice formatting on input elements.
         *
         * It makes sure that the value of the ngModel on the scope has a nice
         * formatting for the user
         */
        angular.module('app.directives').directive('dateFormatter', dateFormatter);

        dateFormatter.$inject = ['dateFilter'];
        function dateFormatter(dateFilter) {
            return {
                restrict: 'A',
                require: 'ngModel',
                link: function link(scope, element, attrs, ngModel) {
                    ngModel.$formatters.push(function (value) {
                        if (value) {
                            return dateFilter(value, attrs.dateFormatter);
                        }

                        return value;
                    });
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * Directive to show a confirmation box before deleting.
         */
        angular.module('app.directives').directive('deleteConfirmation', deleteConfirmation);
        function deleteConfirmation() {
            return {
                restrict: 'E',
                scope: {
                    model: '@',
                    object: '=',
                    displayField: '@?',
                    callback: '&?',
                    buttonClass: '@?',
                    iconClass: '@?',
                    messageObject: '=?',
                    helpText: '@?'
                },
                templateUrl: 'base/directives/delete_confirmation.html',
                controller: DeleteConfirmationController,
                controllerAs: 'vm',
                transclude: true,
                bindToController: true
            };
        }

        DeleteConfirmationController.$inject = ['$state', 'HLResource', 'Settings'];
        function DeleteConfirmationController($state, HLResource, Settings) {
            var vm = this;

            vm.openConfirmationModal = openConfirmationModal;

            activate();

            ////

            function activate() {
                if (!vm.buttonClass) {
                    vm.buttonClass = '';
                }

                if (!vm.iconClass) {
                    vm.iconClass = 'lilicon hl-trashcan-icon';
                }

                if (!vm.helpText) {
                    vm.helpText = 'Delete';
                }

                if (vm.messageObject) {
                    vm.messages = {
                        'confirmTitle': vm.messageObject.confirmTitle || messages.alerts.delete.confirmTitle,
                        'confirmText': vm.messageObject.confirmText || messages.alerts.delete.confirmText,
                        'confirmButtonText': vm.messageObject.confirmButtonText || messages.alerts.delete.confirmButtonText,
                        'errorTitle': vm.messageObject.errorTitle || messages.alerts.delete.errorTitle,
                        'errorText': vm.messageObject.errorText || messages.alerts.delete.errorText,
                        'successTitle': vm.messageObject.successTitle || messages.alerts.delete.successTitle,
                        'successText': vm.messageObject.successText || messages.alerts.delete.successText
                    };
                } else {
                    vm.messages = messages.alerts.delete;
                }
            }

            function openConfirmationModal() {
                var name = '';

                if (vm.displayField) {
                    name = vm.object[vm.displayField];
                } else if (vm.object.hasOwnProperty('name')) {
                    name = vm.object.name;
                } else if (vm.object.hasOwnProperty('full_name')) {
                    name = vm.object.full_name;
                }

                swal({
                    title: vm.messages.confirmTitle,
                    html: sprintf(vm.messages.confirmText, { name: name ? name : 'this ' + vm.model.toLowerCase() }),
                    type: 'warning',
                    showCancelButton: true,
                    confirmButtonColor: '#f3565d',
                    confirmButtonText: vm.messages.confirmButtonText,
                    preConfirm: function preConfirm() {
                        swal.enableLoading();
                        return new Promise(function (resolve) {
                            HLResource.delete(vm.model, vm.object).then(function () {
                                // Delete was successful, so continue.
                                resolve();
                            }, function (error) {
                                // Otherwise show error alert.
                                swal({
                                    title: vm.messages.errorTitle,
                                    html: vm.messages.errorText,
                                    type: 'error'
                                });
                            });
                        });
                    }
                }).then(function (isConfirm) {
                    if (isConfirm) {
                        // In certain cases we want to call a function of another controller.
                        if (vm.callback) {
                            // Call the given function.
                            vm.callback();
                        } else {
                            if (Settings.page.previousState && !Settings.page.previousState.state.name.endsWith('edit')) {
                                // Go to the previous page if it isn't the edit page of the just deleted item.
                                $state.go(Settings.page.previousState.state, Settings.page.previousState.params);
                            } else {
                                // Otherwise just go to the list view, which is the parent state.
                                $state.go($state.current.parent);
                            }
                        }
                    }
                }).done();
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('editableCheckbox', editableCheckbox);

        function editableCheckbox() {
            return {
                restrict: 'E',
                scope: {
                    viewModel: '=',
                    field: '@',
                    type: '@'
                },
                templateUrl: 'base/directives/editable_checkbox.html',
                controller: EditableCheckboxController,
                controllerAs: 'ec',
                transclude: true,
                bindToController: true
            };
        }

        EditableCheckboxController.$inject = [];
        function EditableCheckboxController() {
            var ec = this;

            ec.object = ec.viewModel[ec.type.toLowerCase()];

            ec.updateViewModel = updateViewModel;

            function updateViewModel() {
                var args = {
                    id: ec.object.id
                };

                args[ec.field] = ec.object[ec.field];

                return ec.viewModel.updateModel(args);
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('editableHandler', editableHandler);

        function editableHandler() {
            return {
                restrict: 'A',
                link: function link(scope, element, attrs) {
                    var form;
                    var isPencilClick = false;

                    if (scope.hasOwnProperty('$form')) {
                        form = scope.$form;
                    } else {
                        form = scope[attrs.eForm];
                    }

                    element.on('click', function (event) {
                        // For most inline editable elements the clickable area belongs to the element.
                        // So check if the clicked part was actually the edit icon.
                        if (event.offsetX > event.currentTarget.offsetWidth) {
                            form.$show();
                            isPencilClick = true;

                            scope.$apply();
                        }
                    });

                    element.on('click', '.hl-edit-icon', function (event) {
                        // Certain inline editable elements have a separate button,
                        // so an extra check for the clicked area isn't needed.
                        form.$show();
                        isPencilClick = true;

                        scope.$apply();
                    });

                    scope.$watch('$form.$visible', function (newValue, oldValue) {
                        if (newValue) {
                            if (isPencilClick) {
                                ga('send', 'event', 'Field', 'Edit', 'Pencil');
                            } else {
                                ga('send', 'event', 'Field', 'Edit', 'Double click');
                            }

                            // Reset the variable.
                            isPencilClick = false;
                        }
                    });
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('editableLink', editableLink);

        function editableLink() {
            return {
                restrict: 'E',
                scope: {
                    viewModel: '=',
                    type: '@',
                    field: '@',
                    object: '=?',
                    socialMediaName: '@?'
                },
                templateUrl: 'base/directives/editable_link.html',
                controller: EditableLinkController,
                controllerAs: 'el',
                transclude: true,
                bindToController: true
            };
        }

        EditableLinkController.$inject = [];
        function EditableLinkController() {
            var el = this;

            el.updateViewModel = updateViewModel;

            activate();

            /////

            function activate() {
                if (!el.object) {
                    if (!el.socialMediaName) {
                        el.object = el.viewModel[el.type.toLowerCase()];
                    }
                }
            }

            function updateViewModel($data) {
                var patchPromise;

                var args = {};

                if (el.object) {
                    args = {
                        id: el.object.id
                    };
                }

                args[el.field] = $data;

                if (el.socialMediaName) {
                    args.name = el.socialMediaName;
                    patchPromise = el.viewModel.updateModel(args, el.socialMediaName);
                } else {
                    patchPromise = el.viewModel.updateModel(args).$promise;
                }

                return patchPromise;
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('editableRelated', editableRelated);

        function editableRelated() {
            return {
                restrict: 'E',
                scope: {
                    model: '=',
                    type: '@',
                    field: '@'
                },
                templateUrl: function templateUrl(elem, attrs) {
                    return 'base/directives/editable_' + attrs.field + '.html';
                },
                controller: EditableRelatedController,
                controllerAs: 'er',
                transclude: true,
                bindToController: true,
                link: function link(scope, element, attr) {
                    // Bind click event to the current directive.
                    element.on('click', '.js-edit', function () {
                        scope.er.showForm();
                        scope.$apply();
                    });

                    element.on('click', '.js-add', function () {
                        scope.er.showForm(true);
                        scope.$apply();
                    });
                }
            };
        }

        EditableRelatedController.$inject = ['HLFields', 'HLResource', 'HLUtils'];
        function EditableRelatedController(HLFields, HLResource, HLUtils) {
            var er = this;
            er.formVisible = false;

            er.addRelatedField = addRelatedField;
            er.removeRelatedField = removeRelatedField;
            er.closeForm = closeForm;
            er.submit = submit;
            er.showForm = showForm;

            // TODO: LILY-1520: Clean up this model specific code.
            er.formatPhoneNumber = HLUtils.formatPhoneNumber;
            er.setPrimaryEmailAddress = HLUtils.setPrimaryEmailAddress;

            er.telephoneTypes = [{ key: 'work', value: 'Work' }, { key: 'mobile', value: 'Mobile' }, { key: 'home', value: 'Home' }, { key: 'fax', value: 'Fax' }, { key: 'other', value: 'Other' }];

            er.addressTypes = [{ key: 'visiting', value: 'Visiting address' }, { key: 'billing', value: 'Billing address' }, { key: 'shipping', value: 'Shipping address' }, { key: 'home', value: 'Home address' }, { key: 'other', value: 'Other' }];

            activate();

            /////

            function activate() {
                er.items = er.model[er.field];
                // Store the original items in case we cancel the editing.
                er.originalItems = angular.copy(er.items);

                er.formName = er.field + 'Form';
            }

            function addRelatedField() {
                // Default status is 'Other'.
                var status = 1;
                var isPrimary = false;

                switch (er.field) {
                    case 'email_addresses':
                        if (er.items.length === 0) {
                            // No email addresses added yet, so first one is primary.
                            status = 2;
                            isPrimary = true;
                        }

                        er.items.unshift({ is_primary: isPrimary, status: status });
                        break;
                    case 'phone_numbers':
                        er.items.unshift({ type: 'work' });
                        break;
                    case 'addresses':
                        er.items.unshift({ type: 'visiting' });
                        break;
                    case 'websites':
                        er.items.unshift({ website: '', is_primary: false });
                        break;
                    default:
                        break;
                }
            }

            function removeRelatedField(item) {
                item.is_deleted = !item.is_deleted;
            }

            function submit() {
                var element = '[name="' + er.formName + '"]';

                var args = {
                    id: er.model.id
                };

                args[er.field] = HLFields.cleanInlineRelatedFields(er.items);

                HLUtils.blockUI(element, true);

                return HLResource.patch(er.type, args).$promise.then(function (response) {
                    er.formVisible = false;
                    er.items = response[er.field];

                    HLUtils.unblockUI(element);
                }).catch(function () {
                    HLUtils.unblockUI(element);
                });
            }

            function showForm(add) {
                er.formVisible = true;

                if (!er.items.length || add) {
                    er.addRelatedField();
                }
            }

            function closeForm() {
                // Cancel the editing and restore the original values.
                angular.copy(er.originalItems, er.items);
                er.formVisible = false;
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('editableSelect', editableSelect);

        function editableSelect() {
            return {
                restrict: 'E',
                scope: {
                    viewModel: '=',
                    field: '@',
                    type: '@',
                    choiceField: '@',
                    search: '@?',
                    multiple: '@?',
                    selectType: '@?',
                    object: '=?',
                    selectOptions: '=?' },
                templateUrl: function templateUrl(elem, attrs) {
                    if (attrs.selectType) {
                        return 'base/directives/editable_' + attrs.selectType + '.html';
                    }

                    return 'base/directives/editable_select.html';
                },
                controller: EditableSelectController,
                controllerAs: 'es',
                transclude: true,
                bindToController: true
            };
        }

        EditableSelectController.$inject = ['$injector', '$scope', 'HLResource', 'HLSearch', 'HLUtils'];
        function EditableSelectController($injector, $scope, HLResource, HLSearch, HLUtils) {
            var es = this;

            es.getChoices = getChoices;
            es.refreshChoices = refreshChoices;
            es.updateViewModel = updateViewModel;

            activate();

            // Broadcast function that executes the activate() function when somebody
            // dynamically changes the inline select edit by using the 'assign to me'
            // link, instead of selecting a person with the selectbox.
            $scope.$on('activateEditableSelect', function () {
                activate();
            });

            /////

            function activate() {
                if (!es.selectOptions) {
                    // If it's undefined just set it to an empty object.
                    // Ensures we don't need extra checks in the code.
                    es.selectOptions = {};
                }

                if (!es.object) {
                    es.object = es.viewModel[es.type.toLowerCase()];
                }

                // Certain values in the given view model are objects,
                // so the default value in the select won't always work.
                // If we're not dealing with an inline editable search select check
                // if it's an object and add .id.
                if (!es.search && _typeof(es.object[es.field]) === 'object') {
                    if (es.object[es.field]) {
                        es.selectModel = es.object[es.field].id;
                    }
                } else {
                    es.selectModel = es.object[es.field];
                }

                if (es.selectOptions.hasOwnProperty('display')) {
                    es.optionDisplay = es.selectOptions.display;
                } else {
                    es.optionDisplay = 'name';
                }

                if (es.search) {
                    if (es.selectOptions.hasOwnProperty('placeholder')) {
                        es.placeholder = es.selectOptions.placeholder;
                    }
                }

                // Setup the form name so we can block the element while saving data.
                es.formName = es.field.split('_').join('') + 'Form';
            }

            function getChoices() {
                var type;
                var field;
                var resourceCall;
                var returnValue;

                if (es.selectOptions.hasOwnProperty('type')) {
                    type = es.selectOptions.type;
                } else {
                    type = es.type;
                }

                if (es.selectOptions.hasOwnProperty('field')) {
                    field = es.selectOptions.field;
                } else {
                    field = es.field;
                }

                resourceCall = HLResource.getChoicesForField(type, field);

                if (!resourceCall.hasOwnProperty('$promise')) {
                    es.choices = resourceCall;
                    returnValue = false;
                } else {
                    // Add a return here so the select gets disabled while
                    // loading the options.
                    returnValue = resourceCall.$promise.then(function (data) {
                        if (data.hasOwnProperty('results')) {
                            es.choices = data.results;
                        } else {
                            es.choices = data;
                        }
                    });
                }

                return returnValue;
            }

            function refreshChoices(query) {
                var type;
                var searchPromise;
                var sortColumn;
                var nameColumn;
                var extraFilterQuery;

                if (es.selectOptions.hasOwnProperty('type')) {
                    type = es.selectOptions.type;
                } else {
                    type = es.type;
                }

                if (es.selectOptions.hasOwnProperty('sortColumn')) {
                    sortColumn = es.selectOptions.sortColumn;
                }

                if (es.selectOptions.hasOwnProperty('nameColumn')) {
                    nameColumn = es.selectOptions.nameColumn;
                }

                extraFilterQuery = type === 'User' ? 'is_active:true' : '';

                searchPromise = HLSearch.refreshList(query, type, extraFilterQuery, sortColumn, nameColumn);

                if (searchPromise) {
                    searchPromise.$promise.then(function (data) {
                        es.choices = data.objects;
                    });
                }
            }

            function updateViewModel($data) {
                var selected;
                var i;
                var updatePromise;

                var args = {
                    id: es.object.id
                };

                var form = '[name="es.' + es.formName + '"]';

                if (!es.multiple) {
                    // $data only contains the ID, so get the name from the choices in the scope.
                    for (i = 0; i < es.choices.length; i++) {
                        if (es.choices[i].id === $data) {
                            selected = es.choices[i];
                        }
                    }
                } else {
                    HLUtils.blockUI(form, true);
                }

                if (!es.multiple) {
                    if (es.choiceField) {
                        es.object[es.field] = $data;
                        // Choice fields end with '_display', so set the proper
                        // variable so front end changes are reflected properly.
                        es.object[es.field + '_display'] = selected.name;
                    } else {
                        es.object[es.field] = selected;
                    }
                }

                if (typeof $data === 'undefined') {
                    // We're probably clearing a select field, which produces undefined.
                    args[es.field] = null;
                } else {
                    args[es.field] = $data;
                }

                if (es.viewModel.hasOwnProperty('updateModel')) {
                    updatePromise = es.viewModel.updateModel(args);
                } else {
                    // Dealing with a generic view model (list widget, history list item) so just call the updateModel directly.
                    updatePromise = $injector.get(es.type).updateModel(args, es.field, es.object);
                }

                return updatePromise.then(function () {
                    HLUtils.unblockUI(form);

                    if (es.hasOwnProperty(es.formName)) {
                        es[es.formName].$hide();
                    }

                    if (es.search || es.selectType) {
                        if (es.multiple) {
                            es.object[es.field] = $data;
                        }

                        // Inline editable select2 field doesn't properly update
                        // es.selectModel, so update it manually.
                        es.selectModel = es.object[es.field];
                    }
                }).catch(function () {
                    HLUtils.unblockUI(form);
                });
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('editableTags', editableTags);

        function editableTags() {
            return {
                restrict: 'E',
                scope: {
                    viewModel: '=',
                    type: '@'
                },
                templateUrl: 'base/directives/editable_tags.html',
                controller: EditableTagsController,
                controllerAs: 'vm',
                transclude: true,
                bindToController: true
            };
        }

        EditableTagsController.$inject = ['$timeout', 'HLSearch', 'HLUtils'];
        function EditableTagsController($timeout, HLSearch, HLUtils) {
            var vm = this;

            vm.refreshTags = refreshTags;
            vm.updateViewModel = updateViewModel;
            vm.addTagChoice = addTagChoice;

            activate();

            /////

            function activate() {
                vm.object = vm.viewModel[vm.type];
            }

            function refreshTags(query) {
                var searchPromise = HLSearch.refreshTags(query, vm.object, vm.type);

                if (searchPromise) {
                    searchPromise.$promise.then(function (data) {
                        vm.choices = data.objects;
                    });
                }
            }

            function updateViewModel($data) {
                var tagIds = [];
                var removedTags = [];

                var args = {
                    id: vm.object.id
                };

                var form = '[name="vm.tagForm"]';

                HLUtils.blockUI(form, true);

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = $data.filter(function (x) {
                        return ('id' in x);
                    })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var tag = _step.value;

                        tagIds.push(tag.id);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                removedTags = vm.object.tags.filter(function (tag) {
                    return tagIds.indexOf(tag.id) === -1;
                });

                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = removedTags[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var _tag = _step2.value;

                        _tag.is_deleted = true;
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                args.tags = $data.concat(removedTags);

                return vm.viewModel.updateModel(args).then(function (response) {
                    HLUtils.unblockUI(form);
                    vm.tagForm.$hide();

                    // Just setting the value doesn't update the values model properly.
                    // So use $timeout so it gets applied in the next digest cycle.
                    $timeout(function () {
                        vm.viewModel[vm.type].tags = response.tags;
                    });
                });
            }

            function addTagChoice(tag) {
                return {
                    name: tag
                };
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('editableText', editableText);

        function editableText() {
            return {
                restrict: 'E',
                scope: {
                    field: '@',
                    object: '=',
                    updateCallback: '&'
                },
                templateUrl: 'base/directives/editable_text.html',
                controller: EditableTextController,
                controllerAs: 'vm',
                transclude: true,
                bindToController: true
            };
        }

        EditableTextController.$inject = ['HLUtils'];
        function EditableTextController(HLUtils) {
            var vm = this;

            vm.updateViewModel = updateViewModel;

            activate();

            /////

            function activate() {
                // Setup the form name so we can block the element while saving data.
                vm.formName = vm.field.split('_').join('') + 'Form';
            }

            function updateViewModel(data) {
                return vm.updateCallback()(data, vm.field);
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('editableTextarea', editableTextarea);

        function editableTextarea() {
            return {
                restrict: 'E',
                scope: {
                    viewModel: '=',
                    field: '@',
                    object: '=',
                    extraClass: '@'
                },
                templateUrl: 'base/directives/editable_textarea.html',
                controller: EditableTextAreaController,
                controllerAs: 'vm',
                transclude: true,
                bindToController: true
            };
        }

        EditableTextAreaController.$inject = ['$injector', '$timeout', 'HLUtils'];
        function EditableTextAreaController($injector, $timeout, HLUtils) {
            var vm = this;

            vm.updateViewModel = updateViewModel;
            vm.decodeText = decodeText;

            activate();

            /////

            function activate() {
                vm.selectModel = vm.object[vm.field];
            }

            function decodeText() {
                // Convert the HTML entities to human readable characters.
                if (vm.selectModel) {
                    vm.selectModel = HLUtils.decodeHtmlEntities(vm.selectModel);
                }
            }

            function updateViewModel($data) {
                var patchPromise;
                var modelName;
                var args = {
                    id: vm.object.id
                };

                args[vm.field] = $data;

                if (vm.object.historyType) {
                    modelName = vm.object.historyType.charAt(0).toUpperCase() + vm.object.historyType.slice(1);

                    patchPromise = $injector.get(modelName).updateModel(args);
                } else {
                    patchPromise = vm.viewModel.updateModel(args);
                }

                return patchPromise.then(function (data) {
                    // Set the encoded value so it get's properly displayed in the frontend.
                    $timeout(function () {
                        // Just setting the value doesn't update the values model properly.
                        // So use $timeout so it gets applied in the next digest cycle.
                        vm.object[vm.field] = data[vm.field];
                    });
                });
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * HL specific pagination directive for generic pagination use.
         *
         * @param values {Object}: Contains table information used to set up pagination.
         *
         * Example:
         * <hl-pagination values="vm.table"></hl-pagination>
         */
        angular.module('app.directives').directive('hlPagination', hlPagination);

        function hlPagination() {
            return {
                restrict: 'E',
                scope: {
                    values: '='
                },
                templateUrl: 'base/directives/hl_pagination.html'
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * HL directive to add a scrolling indicator to widgets with a specific height.
         *
         */
        angular.module('app.directives').directive('hlScrollIndicator', hlScrollIndicator);

        hlScrollIndicator.$inject = ['$timeout', '$window'];

        function hlScrollIndicator($timeout, $window) {
            return {
                restrict: 'A',
                scope: true,
                compile: function compile(tElement) {
                    return function (scope, element) {
                        var elm = element[0];
                        var check = function check() {
                            var maxHeight = elm.offsetHeight === elm.scrollHeight;
                            // In certain cases the combined values won't be more than
                            // the scrollHeight eventhough we've reached the bottom.
                            // So for those cases we subtract 11 from the scrollHeight
                            // which is roughly equal to the height of the scroll indicator.
                            var endReached = elm.offsetHeight + elm.scrollTop >= elm.scrollHeight - 11;
                            var widgetStatus = scope.vm.widgetInfo.status;

                            // Show the scroll indicator if we've:
                            // Reached the end of the scrollable area
                            // or if our widget is expanded and already at max-height.
                            scope.vm.showFade = !endReached || maxHeight && widgetStatus === 3;
                        };

                        var appliedCheck = function appliedCheck() {
                            scope.$apply(check);
                        };

                        element.bind('scroll', appliedCheck);

                        check();

                        $timeout(check, 500);

                        angular.element($window).bind('resize', appliedCheck);
                    };
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('inputAutoSize', inputAutoSize);

        function inputAutoSize() {
            return {
                restrict: 'A',
                link: function link(scope, element, attrs) {
                    scope.$watch('$data', function (newValue) {
                        var input = angular.element('[name="' + attrs.eName + '"]');

                        // Set the size attribute of the input so it gets scaled.
                        input.attr('size', newValue.length);
                    });
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('listFilter', listFilter);

        function listFilter() {
            return {
                restrict: 'E',
                scope: {
                    filterLabel: '=',
                    filterLabelPlural: '=',
                    viewModel: '='
                },
                templateUrl: 'base/directives/list_filter.html',
                controller: ListFilterController,
                controllerAs: 'vm',
                bindToController: true
            };
        }

        ListFilterController.$inject = ['$filter', '$timeout', 'HLFilters'];
        function ListFilterController($filter, $timeout, HLFilters) {
            var vm = this;

            vm.toggleFilter = toggleFilter;
            vm.setAll = setAll;
            vm.updateFilterQuery = updateFilterQuery;

            vm.allSelected = false;
            vm.filterDisplayName = vm.filterLabel;
            vm.filterPlural = vm.filterLabelPlural;

            $timeout(activate);

            /////

            function activate() {
                var update = false;
                if (vm.viewModel.storedFilterList) {
                    vm.viewModel.filterList = vm.viewModel.storedFilterList;
                    update = true;
                }

                if (vm.viewModel.storedFilterSpecialList) {
                    vm.viewModel.filterSpecialList = vm.viewModel.storedFilterSpecialList;
                    update = true;
                }

                if (update) {
                    updateAllSelected();
                    updateFilterQuery();
                    updateFilterDisplayName();
                }
            }

            function setAll(value) {
                var newValue;

                var filterList = vm.viewModel.filterList;

                if (vm.viewModel.filterSpecialList) {
                    filterList = vm.viewModel.filterSpecialList;
                }

                if (typeof value !== 'undefined') {
                    // Set all items to the given value.
                    newValue = value;
                } else {
                    // Deselect/Select all items.
                    vm.allSelected = !vm.allSelected;
                    newValue = vm.allSelected;
                }

                angular.forEach(filterList, function (item) {
                    item.selected = newValue;
                });

                updateFilterQuery();
                updateFilterDisplayName();
            }

            function toggleFilter(filter) {
                // ngModel on a checkbox seems to load really slow, so doing the toggling this way.
                filter.selected = !filter.selected;

                updateAllSelected();
                updateFilterQuery();
                updateFilterDisplayName();
            }

            function updateAllSelected() {
                // Keep the All selected checkbox in sync whether or not all items are selected.
                var filterList = vm.viewModel.filterList;
                if (vm.viewModel.filterSpecialList) {
                    filterList = vm.viewModel.filterSpecialList;
                }

                vm.allSelected = true;

                angular.forEach(filterList, function (item) {
                    if (!item.selected) {
                        vm.allSelected = false;
                    }
                });
            }

            function updateFilterQuery() {
                HLFilters.updateFilterQuery(vm.viewModel);

                if (vm.viewModel.hasOwnProperty('updateTable')) {
                    vm.viewModel.updateTable();
                }

                vm.viewModel.storage.put('filterListSelected', vm.viewModel.filterList);
                vm.viewModel.storage.put('filterSpecialListSelected', vm.viewModel.filterSpecialList);
            }

            function updateFilterDisplayName() {
                var filterList = vm.viewModel.filterList;
                var selectedItems = [];
                var label = vm.filterLabel;

                if (vm.viewModel.filterSpecialList) {
                    filterList = vm.viewModel.filterSpecialList;
                }

                selectedItems = $filter('filter')(filterList, { selected: true });

                if (selectedItems.length) {
                    if (selectedItems.length < 3) {
                        label = selectedItems.map(function (item) {
                            return item.name;
                        }).join(' + ');
                    } else {
                        label = selectedItems.length + ' ' + vm.filterLabel + ' selected';
                    }

                    vm.displayClearButton = true;
                } else {
                    vm.displayClearButton = false;
                }

                vm.filterDisplayName = label;
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('listWidget', ListWidget);

        function ListWidget() {
            return {
                restrict: 'E',
                scope: {
                    title: '@',
                    module: '=',
                    list: '=',
                    height: '=',
                    addLink: '@',
                    collapsableItems: '=',
                    object: '='
                },
                templateUrl: function templateUrl(elem, attrs) {
                    var templateUrl = '';

                    if (attrs.module) {
                        // Template url can't be determined from the given title. So use the module name.
                        templateUrl = attrs.module + '/directives/list_widget.html';
                    } else {
                        templateUrl = attrs.title.toLowerCase() + '/directives/list_widget.html';
                    }

                    return templateUrl;
                },
                controller: ListWidgetController,
                controllerAs: 'vm',
                bindToController: true
            };
        }

        ListWidgetController.$inject = ['$filter', '$state', 'Settings'];
        function ListWidgetController($filter, $state, Settings) {
            var vm = this;

            vm.settings = Settings;

            vm.googleAnalyticsEvent = googleAnalyticsEvent;

            activate();

            /////

            function activate() {
                if (vm.collapsableItems) {
                    // Certain list widgets have collapsable cells, so set the default state to collapsed.
                    if (!vm.list.hasOwnProperty('$promise')) {
                        // Array was passed, so just pass the list.
                        _setCollapsed(vm.list);
                    } else {
                        vm.list.$promise.then(function (response) {
                            // List hasn't fully loaded, so wait and pass the response.
                            _setCollapsed(response);
                        });
                    }
                }
            }

            // Google Analytics function to set labels to differentiate in Analytics
            // which widget the user used to add a case or deal.
            function googleAnalyticsEvent() {
                if ($state.current.name === 'base.contacts.detail' && vm.title === 'Cases') {
                    ga('send', 'event', 'Case', 'Open', 'Contact Widget');
                }

                if ($state.current.name === 'base.accounts.detail' && vm.title === 'Cases') {
                    ga('send', 'event', 'Case', 'Open', 'Account Widget');
                }

                if ($state.current.name === 'base.contacts.detail' && vm.title === 'Deals') {
                    ga('send', 'event', 'Deal', 'Open', 'Contact Widget');
                }

                if ($state.current.name === 'base.accounts.detail' && vm.title === 'Deals') {
                    ga('send', 'event', 'Deal', 'Open', 'Account Widget');
                }

                if ($state.current.name === 'base.accounts.detail' && vm.title !== 'Deals' && vm.title !== 'Cases') {
                    ga('send', 'event', 'Contact', 'Open', 'Account Widget');
                }

                if ($state.current.name === 'base.contacts.detail' && vm.title !== 'Deals' && vm.title !== 'Cases') {
                    ga('send', 'event', 'Contact', 'Open', 'Contact Widget');
                }
            }

            function _setCollapsed(items) {
                var list;
                var cases;
                var deals;
                var archivedCases;
                var archivedDeals;

                if (items.hasOwnProperty('objects')) {
                    list = items.objects;
                } else {
                    list = items;
                }

                angular.forEach(list, function (item) {
                    item.collapsed = true;
                });

                // We want to apply a certain sorting for cases.
                if (vm.title === 'Cases') {
                    // Separate non-archived cases and order by priority.
                    cases = $filter('filter')(list, { is_archived: false });
                    cases = $filter('orderBy')(cases, '-priority');

                    // Separate archived cases and order by expiry date.
                    archivedCases = $filter('filter')(list, { is_archived: true });
                    archivedCases = $filter('orderBy')(archivedCases, '-expires');

                    // Add archived cases to cases array.
                    cases.push.apply(cases, archivedCases);

                    list = cases;
                }

                // We want to apply a certain sorting for deals.
                if (vm.title === 'Deals') {
                    // Separate non-archived deals.
                    deals = $filter('filter')(list, { is_archived: false });

                    // Separate archived deals.
                    archivedDeals = $filter('filter')(list, { is_archived: true });

                    // Add archived deals to deals array.
                    deals.push.apply(deals, archivedDeals);

                    list = deals;
                }

                vm.list = list;
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('markAssignedButton', markAssignedButton);

        function markAssignedButton() {
            return {
                restrict: 'A',
                scope: {
                    callback: '&'
                },
                link: function link(scope, element, attrs) {
                    element.on('click', function () {
                        // Get the closest table row.
                        element.closest('.newly-assigned').fadeOut(500, function () {
                            // Mark the item as assigned.
                            scope.callback();
                        });
                    });
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('onEnterKey', onEnterKey);

        function onEnterKey() {
            return function (scope, element, attrs) {
                element.bind('keydown keypress', function (event) {
                    if (event.which === 13) {
                        scope.$apply(function () {
                            scope.$eval(attrs.onEnterKey);
                        });

                        event.preventDefault();
                    }
                });
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('onModEnterKey', onModEnterKey);

        function onModEnterKey() {
            return function (scope, element, attrs) {
                element.bind('keydown keypress', function (event) {
                    if (navigator.userAgent.indexOf('Mac OS X') !== -1) {
                        if (event.which === 13 && event.metaKey) {
                            scope.$apply(function () {
                                scope.$eval(attrs.onModEnterKey);
                            });

                            event.preventDefault();
                        }
                    } else {
                        if (event.which === 13 && event.ctrlKey) {
                            scope.$apply(function () {
                                scope.$eval(attrs.onModEnterKey);
                            });

                            event.preventDefault();
                        }
                    }
                });
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('resizeIframe', resizeIframe);

        function resizeIframe() {
            return {
                restrict: 'A',
                link: function link($scope, element, attrs) {
                    var maxHeight = $('body').outerHeight();
                    element.on('load', function () {
                        var ifDoc;
                        var ifRef;
                        var subtractHeights;
                        var height;

                        element.removeClass('hidden');

                        // Do this after .inbox-view is visible.
                        ifDoc = this;
                        ifRef = this;

                        // set ifDoc to 'document' from frame
                        try {
                            ifDoc = ifRef.contentWindow.document.documentElement;
                        } catch (e1) {
                            try {
                                ifDoc = ifRef.contentDocument.documentElement;
                            } catch (e2) {
                                throw e2.message;
                            }
                        }

                        // calculate and set max height for frame
                        if (ifDoc) {
                            subtractHeights = [element.offset().top, $('.footer').outerHeight(), $('.inbox-attached').outerHeight()];
                            for (height in subtractHeights) {
                                maxHeight = maxHeight - height;
                            }

                            if (ifDoc.scrollHeight > maxHeight) {
                                ifRef.height = maxHeight;
                            } else {
                                ifRef.height = ifDoc.scrollHeight;
                            }
                        }
                    });
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('saveAndArchive', saveAndArchiveDirective);

        function saveAndArchiveDirective() {
            return {
                restrict: 'A',
                link: function link(scope, elem, attrs) {
                    // Setting button to right text based in archived state
                    var $button = $('#archive-button');
                    var $archiveField = $('#id_is_archived');
                    if ($archiveField.val() === 'True') {
                        $button.find('span').text('Save and Unarchive');
                    } else {
                        $button.find('span').text('Save and Archive');
                    }

                    // On button click set archived hidden field and submit form.
                    elem.on('click', function () {
                        var $form = $button.closest('form');
                        var archive = $archiveField.val() === 'True' ? 'False' : 'True';
                        $archiveField.val(archive);
                        // Native form validation passed; set the loading text on the
                        // `Save and Archive` button.
                        if ($form.get(0).checkValidity()) {
                            $button.button('loading');
                        }
                        $form.find(':submit').click();
                        event.preventDefault();
                    });
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * sortColumn directive adds sorting classes to an DOM element based on `table` object
         *
         * It makes the element clickable and sets the table sorting based on that element
         *
         * @param sortColumn string: name of the column to sort on when clicked
         * @param table object: The object to bind sort column and ordering
         *
         * Example:
         *
         * <th sort-column="last_name" table="table">Name</th>
         *
         * Possible classes:
         * - sorting: Unsorted
         * - sorting_asc: Sorted ascending
         * - sorting_desc: Sorted descending
         */
        angular.module('app.directives').directive('sortColumn', sortColumn);

        function sortColumn() {
            /**
             * _setSortableIcon() removes current sorting classes and adds new based on current
             * sorting column and direction
             *
             * @param $scope object: current scope
             * @param element object: current DOM element
             * @param column string: column from current DOM element
             */
            var _setSortableIcon = function _setSortableIcon($scope, element, column) {
                // Add classes based on current sorted column
                if ($scope.table.order.column === column) {
                    if ($scope.table.order.descending) {
                        $scope.sorted = -1;
                    } else {
                        $scope.sorted = 1;
                    }
                } else {
                    $scope.sorted = 0;
                }
            };

            return {
                restrict: 'A',
                scope: {
                    table: '='
                },
                transclude: true,
                templateUrl: 'base/directives/sort_column.html',
                link: function link($scope, element, attrs) {
                    // Watch the table ordering & sorting
                    $scope.$watchCollection('table.order', function () {
                        _setSortableIcon($scope, element, attrs.sortColumn);
                    });

                    // When element is clicked, set the table ordering & sorting based on this DOM element
                    element.on('click', function () {
                        if ($scope.table.order.column === attrs.sortColumn) {
                            // Toggle between the 3 states of a column:
                            // - ascending
                            // - descending
                            // - no sorting
                            if ($scope.table.order.descending) {
                                $scope.table.order.column = '';
                                $scope.table.order.descending = null;
                            } else {
                                $scope.table.order.descending = !$scope.table.order.descending;
                            }

                            $scope.$apply();
                        } else {
                            $scope.table.order.column = attrs.sortColumn;
                            $scope.$apply();
                        }
                    });
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.directives').directive('ngSpinnerBar', ngSpinnerBar);

        ngSpinnerBar.$inject = ['$rootScope'];
        function ngSpinnerBar($rootScope) {
            return {
                link: function link(scope, element, attrs) {
                    // By default hide the spinner bar.
                    element.addClass('hide');

                    // Display the spinner bar whenever the route changes (the content part started loading).
                    $rootScope.$on('$stateChangeStart', function () {
                        element.removeClass('hide');
                    });

                    // Hide the spinner bar on route change success (after the content loaded).
                    $rootScope.$on('$stateChangeSuccess', function () {
                        element.addClass('hide');
                        // Remove page loading indicator.
                        $('body').removeClass('page-on-load');
                    });

                    // Handle errors.
                    $rootScope.$on('$stateNotFound', function () {
                        element.addClass('hide');
                    });

                    $rootScope.$on('$stateChangeError', function () {
                        element.addClass('hide');
                    });
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        //angular.module('app.dashboard.directives').directive('widget', widget);
        angular.module('app.directives').directive('widget', widget);

        function widget() {
            return {
                restrict: 'E',
                scope: {
                    widgetName: '=',
                    widgetCloseable: '=',
                    widgetClass: '=',
                    widgetScrollable: '=',
                    widgetDynamicHeight: '='
                },
                templateUrl: 'base/directives/widget.html',
                controller: WidgetController,
                controllerAs: 'vm',
                bindToController: true,
                transclude: {
                    widgetHeader: 'widgetHeader',
                    widgetFilters: '?widgetFilters',
                    widgetBody: 'widgetBody'
                }
            };
        }

        WidgetController.$inject = ['$scope', '$state', 'LocalStorage'];
        function WidgetController($scope, $state, LocalStorage) {
            var vm = this;
            var storage = new LocalStorage($state.current.name + 'widgetInfo');
            var widgetStatus = {
                hidden: 0,
                visible: 1,
                collapsed: 2,
                expanded: 3
            };

            vm.storageName = _getWidgetStorageName();

            vm.toggleCollapse = toggleCollapse;
            vm.removeWidget = removeWidget;
            vm.expandToggle = expandToggle;

            activate();

            ////////////

            function activate() {
                // Get visibility status of the widget
                var widgetInfo = storage.getObjectValue(vm.storageName, {});

                if ((typeof widgetInfo === "undefined" ? "undefined" : _typeof(widgetInfo)) === 'object' && !Object.keys(widgetInfo).length) {
                    // No locally stored value, so set status to visible
                    widgetInfo.status = widgetStatus.visible;
                    widgetInfo.name = vm.widgetName;
                }

                vm.widgetInfo = widgetInfo;

                _updateWidgetStorage();
                _watchWidgetVisibility();
            }

            function _getWidgetStorageName() {
                // Strip all whitespace and make the name lowercase
                return vm.widgetName.replace(/\s+/g, '').toLowerCase();
            }

            function _watchWidgetVisibility() {
                // Check the status of a widget for changes and update the locally stored value
                $scope.$watch('vm.widgetInfo.status', function () {
                    _updateWidgetStorage();
                });
            }

            /**
             * Stores the widget info in local storage.
             * The widget info contains the name of the widget (used for settings)
             * and visibility status of the widget.
             */
            function _updateWidgetStorage() {
                storage.putObjectValue(vm.storageName, vm.widgetInfo);
            }

            function toggleCollapse() {
                if (vm.widgetInfo.status === widgetStatus.visible || vm.widgetInfo.status === widgetStatus.expanded) {
                    // Check if the fade is initially set to prevent it from showing up
                    // when the widget isn't scrollable.
                    if ($scope.vm.showFade) {
                        $scope.vm.showFade = false;
                    }

                    vm.widgetInfo.status = widgetStatus.collapsed;
                } else {
                    if ($scope.vm.showFade === false) {
                        $scope.vm.showFade = true;
                    }

                    vm.widgetInfo.status = widgetStatus.visible;
                }
            }

            function expandToggle() {
                if (vm.widgetInfo.status === widgetStatus.visible) {
                    vm.widgetInfo.status = widgetStatus.expanded;
                } else {
                    vm.widgetInfo.status = widgetStatus.visible;
                }
            }

            function removeWidget() {
                vm.widgetInfo.status = widgetStatus.hidden;
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * Router definition.
         */
        angular.module('app.base').config(notFoundConfig);

        notFoundConfig.$inject = ['$stateProvider'];
        function notFoundConfig($stateProvider) {
            $stateProvider.state('base.404', {
                url: '/not-found',
                views: {
                    '@': {
                        templateUrl: 'base/errors/404.html',
                        controller: NotFoundController,
                        controllerAs: 'vm'
                    }
                },
                ncyBreadcrumb: {
                    label: 'Not found'
                }
            });
        }

        angular.module('app.base').controller('NotFoundController', NotFoundController);

        NotFoundController.$inject = ['Settings'];
        function NotFoundController(Settings) {
            Settings.page.setAllTitles('custom', 'Not found');
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * Router definition.
         */
        angular.module('app.base').config(errorConfig);

        errorConfig.$inject = ['$stateProvider'];
        function errorConfig($stateProvider) {
            $stateProvider.state('base.500', {
                url: '/error',
                views: {
                    '@': {
                        templateUrl: 'base/errors/500.html',
                        controller: ErrorController,
                        controllerAs: 'vm'
                    }
                },
                ncyBreadcrumb: {
                    label: 'Error'
                }
            });
        }

        angular.module('app.base').controller('ErrorController', ErrorController);

        ErrorController.$inject = ['Settings'];
        function ErrorController(Settings) {
            Settings.page.setAllTitles('custom', 'Error');
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.filters').filter('currencySymbol', currencySymbol);

        currencySymbol.$inject = ['$filter'];
        function currencySymbol($filter) {
            var currencySymbols = {
                'EUR': '&#8364; ',
                'GBP': '&#163; ',
                'USD': '&#36; ',
                'ZAR': '&#82; ',
                'NOR': '&#107;&#114; ',
                'DKK': '&#107;&#114; ',
                'SEK': '&#107;&#114; ',
                'CHF': '&#67;&#72;&#70; '
            };

            return function (amount, currency) {
                return $filter('currency')(amount, currencySymbols[currency]);
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.filters').filter('filterItems', filterItems);

        filterItems.$inject = ['$filter'];
        function filterItems($filter) {
            return function (items, existingItems) {
                var i;
                var out = items;

                if (items && existingItems) {
                    // Filter given items based on already existing items.
                    for (i = 0; i < existingItems.length; i++) {
                        out = $filter('removeWith')(out, { id: existingItems[i].id });
                    }
                }

                return out;
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.filters').filter('hlTruncate', hlTruncate);

        /**
         * Truncate the title with a certain amount of characters based upon the window width.
         *
         * @param title {string}: String that has to be truncated
         */
        hlTruncate.$inject = ['$filter'];
        function hlTruncate($filter) {
            return function (title) {
                var filteredTitle;
                var ellipsis;
                // Values on which the container goes multiline and overflows the buttons.
                if (window.outerWidth <= 1180) {
                    filteredTitle = $filter('limitTo')(title, 30);
                    ellipsis = title.length > 30 ? '...' : '';
                } else if (window.outerWidth <= 1596 && window.outerWidth >= 1180) {
                    filteredTitle = $filter('limitTo')(title, 50);
                    ellipsis = title.length > 50 ? '...' : '';
                } else {
                    filteredTitle = $filter('limitTo')(title, 100);
                    ellipsis = title.length > 100 ? '...' : '';
                }

                return filteredTitle + ellipsis;
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * join takes the given array and joins the strings by the given delimiter (or comma if none is given).
         *
         * @param input {Array}: Array containing the strings (or objects).
         * @param field {string}: Field the string should be extracted from (if input contains objects).
         * @param delimited {string}: Character which seperates the strings.
         */
        angular.module('app.filters').filter('join', join);

        function join() {
            return function (input, field, delimiter) {
                var strings = [];
                var values = input;

                if (field) {
                    // Array with object was given, so iterate over the objects and extract the field.
                    angular.forEach(values, function (item) {
                        strings.push(item[field]);
                    });

                    values = strings;
                }

                // Join the strings array.
                return (values || []).join(delimiter || ', ');
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.filters').filter('minValue', minValue);
        function minValue() {
            return function (values) {
                values.sort(function (a, b) {
                    return a - b;
                });

                return values[0];
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function e(t, n, r) {
	function s(o, u) {
		if (!n[o]) {
			if (!t[o]) {
				var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
			}var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
				var n = t[o][1][e];return s(n ? n : e);
			}, l, l.exports, e, t, n, r);
		}return n[o].exports;
	}var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
		s(r[o]);
	}return s;
})({ 1: [function (require, module, exports) {
		var Autolinker = require('autolinker');

		/**
   * parseUrls is a template filter to call Autolinker.
   * This is a library which automatically detects links, email addresses and
   * Twitter handles and converts them to clickable links.
   *
   * @param text {string}: Text to be converted
   *
   * @returns: string: Text containing clickable links.
   */
		angular.module('app.filters').filter('parseUrls', parseUrls);

		parseUrls.$inject = [];
		function parseUrls() {
			return function (text) {
				return Autolinker.link(text, {
					replaceFn: function replaceFn(match) {
						var email;
						switch (match.getType()) {
							case 'email':
								email = match.getEmail();
								return '<a href="#/email/compose/' + email + '/">' + email + '</a>';
							default:
								return true;
						}
					}
				});
			};
		}
	}, { "autolinker": 2 }], 2: [function (require, module, exports) {
		/*!
   * Autolinker.js
   * 1.1.1
   *
   * Copyright(c) 2016 Gregory Jacobs <greg@greg-jacobs.com>
   * MIT License
   *
   * https://github.com/gregjacobs/Autolinker.js
   */
		;(function (root, factory) {
			if (typeof define === 'function' && define.amd) {
				define([], factory);
			} else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
				module.exports = factory();
			} else {
				root.Autolinker = factory();
			}
		})(this, function () {
			/**
    * @class Autolinker
    * @extends Object
    *
    * Utility class used to process a given string of text, and wrap the matches in
    * the appropriate anchor (&lt;a&gt;) tags to turn them into links.
    *
    * Any of the configuration options may be provided in an Object (map) provided
    * to the Autolinker constructor, which will configure how the {@link #link link()}
    * method will process the links.
    *
    * For example:
    *
    *     var autolinker = new Autolinker( {
    *         newWindow : false,
    *         truncate  : 30
    *     } );
    *
    *     var html = autolinker.link( "Joe went to www.yahoo.com" );
    *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
    *
    *
    * The {@link #static-link static link()} method may also be used to inline
    * options into a single call, which may be more convenient for one-off uses.
    * For example:
    *
    *     var html = Autolinker.link( "Joe went to www.yahoo.com", {
    *         newWindow : false,
    *         truncate  : 30
    *     } );
    *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
    *
    *
    * ## Custom Replacements of Links
    *
    * If the configuration options do not provide enough flexibility, a {@link #replaceFn}
    * may be provided to fully customize the output of Autolinker. This function is
    * called once for each URL/Email/Phone#/Hashtag/Mention (Twitter, Instagram)
    * match that is encountered.
    *
    * For example:
    *
    *     var input = "...";  // string with URLs, Email Addresses, Phone #s, Hashtags, and Mentions (Twitter, Instagram)
    *
    *     var linkedText = Autolinker.link( input, {
    *         replaceFn : function( match ) {
    *             console.log( "href = ", match.getAnchorHref() );
    *             console.log( "text = ", match.getAnchorText() );
    *
    *             switch( match.getType() ) {
    *                 case 'url' :
    *                     console.log( "url: ", match.getUrl() );
    *
    *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {
    *                         var tag = match.buildTag();  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes
    *                         tag.setAttr( 'rel', 'nofollow' );
    *                         tag.addClass( 'external-link' );
    *
    *                         return tag;
    *
    *                     } else {
    *                         return true;  // let Autolinker perform its normal anchor tag replacement
    *                     }
    *
    *                 case 'email' :
    *                     var email = match.getEmail();
    *                     console.log( "email: ", email );
    *
    *                     if( email === "my@own.address" ) {
    *                         return false;  // don't auto-link this particular email address; leave as-is
    *                     } else {
    *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)
    *                     }
    *
    *                 case 'phone' :
    *                     var phoneNumber = match.getPhoneNumber();
    *                     console.log( phoneNumber );
    *
    *                     return '<a href="http://newplace.to.link.phone.numbers.to/">' + phoneNumber + '</a>';
    *
    *                 case 'hashtag' :
    *                     var hashtag = match.getHashtag();
    *                     console.log( hashtag );
    *
    *                     return '<a href="http://newplace.to.link.hashtag.handles.to/">' + hashtag + '</a>';
    *
    *                 case 'mention' :
    *                     var mention = match.getMention();
    *                     console.log( mention );
    *
    *                     return '<a href="http://newplace.to.link.mention.to/">' + mention + '</a>';
    *             }
    *         }
    *     } );
    *
    *
    * The function may return the following values:
    *
    * - `true` (Boolean): Allow Autolinker to replace the match as it normally
    *   would.
    * - `false` (Boolean): Do not replace the current match at all - leave as-is.
    * - Any String: If a string is returned from the function, the string will be
    *   used directly as the replacement HTML for the match.
    * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify
    *   an HTML tag before writing out its HTML text.
    *
    * @constructor
    * @param {Object} [cfg] The configuration options for the Autolinker instance,
    *   specified in an Object (map).
    */
			var Autolinker = function Autolinker(cfg) {
				cfg = cfg || {};

				this.version = Autolinker.version;

				this.urls = this.normalizeUrlsCfg(cfg.urls);
				this.email = typeof cfg.email === 'boolean' ? cfg.email : true;
				this.phone = typeof cfg.phone === 'boolean' ? cfg.phone : true;
				this.hashtag = cfg.hashtag || false;
				this.mention = cfg.mention || false;
				this.newWindow = typeof cfg.newWindow === 'boolean' ? cfg.newWindow : true;
				this.stripPrefix = this.normalizeStripPrefixCfg(cfg.stripPrefix);
				this.stripTrailingSlash = typeof cfg.stripTrailingSlash === 'boolean' ? cfg.stripTrailingSlash : true;

				// Validate the value of the `mention` cfg
				var mention = this.mention;
				if (mention !== false && mention !== 'twitter' && mention !== 'instagram') {
					throw new Error("invalid `mention` cfg - see docs");
				}

				// Validate the value of the `hashtag` cfg
				var hashtag = this.hashtag;
				if (hashtag !== false && hashtag !== 'twitter' && hashtag !== 'facebook' && hashtag !== 'instagram') {
					throw new Error("invalid `hashtag` cfg - see docs");
				}

				this.truncate = this.normalizeTruncateCfg(cfg.truncate);
				this.className = cfg.className || '';
				this.replaceFn = cfg.replaceFn || null;
				this.context = cfg.context || this;

				this.htmlParser = null;
				this.matchers = null;
				this.tagBuilder = null;
			};

			/**
    * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles,
    * Hashtags, and Mentions found in the given chunk of HTML. Does not link URLs found
    * within HTML tags.
    *
    * For instance, if given the text: `You should go to http://www.yahoo.com`,
    * then the result will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
    *
    * Example:
    *
    *     var linkedText = Autolinker.link( "Go to google.com", { newWindow: false } );
    *     // Produces: "Go to <a href="http://google.com">google.com</a>"
    *
    * @static
    * @param {String} textOrHtml The HTML or text to find matches within (depending
    *   on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #mention},
    *   {@link #hashtag}, and {@link #mention} options are enabled).
    * @param {Object} [options] Any of the configuration options for the Autolinker
    *   class, specified in an Object (map). See the class description for an
    *   example call.
    * @return {String} The HTML text, with matches automatically linked.
    */
			Autolinker.link = function (textOrHtml, options) {
				var autolinker = new Autolinker(options);
				return autolinker.link(textOrHtml);
			};

			/**
    * @static
    * @property {String} version (readonly)
    *
    * The Autolinker version number in the form major.minor.patch
    *
    * Ex: 0.25.1
    */
			Autolinker.version = '1.1.1';

			Autolinker.prototype = {
				constructor: Autolinker, // fix constructor property

				/**
     * @cfg {Boolean/Object} [urls]
     *
     * `true` if URLs should be automatically linked, `false` if they should not
     * be. Defaults to `true`.
     *
     * Examples:
     *
     *     urls: true
     *
     *     // or
     *
     *     urls: {
     *         schemeMatches : true,
     *         wwwMatches    : true,
     *         tldMatches    : true
     *     }
     *
     * As shown above, this option also accepts an Object form with 3 properties
     * to allow for more customization of what exactly gets linked. All default
     * to `true`:
     *
     * @cfg {Boolean} [urls.schemeMatches] `true` to match URLs found prefixed
     *   with a scheme, i.e. `http://google.com`, or `other+scheme://google.com`,
     *   `false` to prevent these types of matches.
     * @cfg {Boolean} [urls.wwwMatches] `true` to match urls found prefixed with
     *   `'www.'`, i.e. `www.google.com`. `false` to prevent these types of
     *   matches. Note that if the URL had a prefixed scheme, and
     *   `schemeMatches` is true, it will still be linked.
     * @cfg {Boolean} [urls.tldMatches] `true` to match URLs with known top
     *   level domains (.com, .net, etc.) that are not prefixed with a scheme or
     *   `'www.'`. This option attempts to match anything that looks like a URL
     *   in the given text. Ex: `google.com`, `asdf.org/?page=1`, etc. `false`
     *   to prevent these types of matches.
     */

				/**
     * @cfg {Boolean} [email=true]
     *
     * `true` if email addresses should be automatically linked, `false` if they
     * should not be.
     */

				/**
     * @cfg {Boolean} [phone=true]
     *
     * `true` if Phone numbers ("(555)555-5555") should be automatically linked,
     * `false` if they should not be.
     */

				/**
     * @cfg {Boolean/String} [hashtag=false]
     *
     * A string for the service name to have hashtags (ex: "#myHashtag")
     * auto-linked to. The currently-supported values are:
     *
     * - 'twitter'
     * - 'facebook'
     * - 'instagram'
     *
     * Pass `false` to skip auto-linking of hashtags.
     */

				/**
     * @cfg {String/Boolean} [mention=false]
     *
     * A string for the service name to have mentions (ex: "@myuser")
     * auto-linked to. The currently supported values are:
     *
     * - 'twitter'
     * - 'instagram'
     *
     * Defaults to `false` to skip auto-linking of mentions.
     */

				/**
     * @cfg {Boolean} [newWindow=true]
     *
     * `true` if the links should open in a new window, `false` otherwise.
     */

				/**
     * @cfg {Boolean/Object} [stripPrefix]
     *
     * `true` if 'http://' (or 'https://') and/or the 'www.' should be stripped
     * from the beginning of URL links' text, `false` otherwise. Defaults to
     * `true`.
     *
     * Examples:
     *
     *     stripPrefix: true
     *
     *     // or
     *
     *     stripPrefix: {
     *         scheme : true,
     *         www    : true
     *     }
     *
     * As shown above, this option also accepts an Object form with 2 properties
     * to allow for more customization of what exactly is prevented from being
     * displayed. Both default to `true`:
     *
     * @cfg {Boolean} [stripPrefix.scheme] `true` to prevent the scheme part of
     *   a URL match from being displayed to the user. Example:
     *   `'http://google.com'` will be displayed as `'google.com'`. `false` to
     *   not strip the scheme. NOTE: Only an `'http://'` or `'https://'` scheme
     *   will be removed, so as not to remove a potentially dangerous scheme
     *   (such as `'file://'` or `'javascript:'`)
     * @cfg {Boolean} [stripPrefix.www] www (Boolean): `true` to prevent the
     *   `'www.'` part of a URL match from being displayed to the user. Ex:
     *   `'www.google.com'` will be displayed as `'google.com'`. `false` to not
     *   strip the `'www'`.
     */

				/**
     * @cfg {Boolean} [stripTrailingSlash=true]
     *
     * `true` to remove the trailing slash from URL matches, `false` to keep
     *  the trailing slash.
     *
     *  Example when `true`: `http://google.com/` will be displayed as
     *  `http://google.com`.
     */

				/**
     * @cfg {Number/Object} [truncate=0]
     *
     * ## Number Form
     *
     * A number for how many characters matched text should be truncated to
     * inside the text of a link. If the matched text is over this number of
     * characters, it will be truncated to this length by adding a two period
     * ellipsis ('..') to the end of the string.
     *
     * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file'
     * truncated to 25 characters might look something like this:
     * 'yahoo.com/some/long/pat..'
     *
     * Example Usage:
     *
     *     truncate: 25
     *
     *
     *  Defaults to `0` for "no truncation."
     *
     *
     * ## Object Form
     *
     * An Object may also be provided with two properties: `length` (Number) and
     * `location` (String). `location` may be one of the following: 'end'
     * (default), 'middle', or 'smart'.
     *
     * Example Usage:
     *
     *     truncate: { length: 25, location: 'middle' }
     *
     * @cfg {Number} [truncate.length=0] How many characters to allow before
     *   truncation will occur. Defaults to `0` for "no truncation."
     * @cfg {"end"/"middle"/"smart"} [truncate.location="end"]
     *
     * - 'end' (default): will truncate up to the number of characters, and then
     *   add an ellipsis at the end. Ex: 'yahoo.com/some/long/pat..'
     * - 'middle': will truncate and add the ellipsis in the middle. Ex:
     *   'yahoo.com/s..th/to/a/file'
     * - 'smart': for URLs where the algorithm attempts to strip out unnecessary
     *   parts first (such as the 'www.', then URL scheme, hash, etc.),
     *   attempting to make the URL human-readable before looking for a good
     *   point to insert the ellipsis if it is still too long. Ex:
     *   'yahoo.com/some..to/a/file'. For more details, see
     *   {@link Autolinker.truncate.TruncateSmart}.
     */

				/**
     * @cfg {String} className
     *
     * A CSS class name to add to the generated links. This class will be added
     * to all links, as well as this class plus match suffixes for styling
     * url/email/phone/hashtag/mention links differently.
     *
     * For example, if this config is provided as "myLink", then:
     *
     * - URL links will have the CSS classes: "myLink myLink-url"
     * - Email links will have the CSS classes: "myLink myLink-email", and
     * - Phone links will have the CSS classes: "myLink myLink-phone"
     * - Hashtag links will have the CSS classes: "myLink myLink-hashtag"
     * - Mention links will have the CSS classes: "myLink myLink-mention myLink-[type]"
     *   where [type] is either "instagram" or "twitter"
     */

				/**
     * @cfg {Function} replaceFn
     *
     * A function to individually process each match found in the input string.
     *
     * See the class's description for usage.
     *
     * The `replaceFn` can be called with a different context object (`this`
     * reference) using the {@link #context} cfg.
     *
     * This function is called with the following parameter:
     *
     * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which
     *   can be used to retrieve information about the match that the `replaceFn`
     *   is currently processing. See {@link Autolinker.match.Match} subclasses
     *   for details.
     */

				/**
     * @cfg {Object} context
     *
     * The context object (`this` reference) to call the `replaceFn` with.
     *
     * Defaults to this Autolinker instance.
     */

				/**
     * @property {String} version (readonly)
     *
     * The Autolinker version number in the form major.minor.patch
     *
     * Ex: 0.25.1
     */

				/**
     * @private
     * @property {Autolinker.htmlParser.HtmlParser} htmlParser
     *
     * The HtmlParser instance used to skip over HTML tags, while finding text
     * nodes to process. This is lazily instantiated in the {@link #getHtmlParser}
     * method.
     */

				/**
     * @private
     * @property {Autolinker.matcher.Matcher[]} matchers
     *
     * The {@link Autolinker.matcher.Matcher} instances for this Autolinker
     * instance.
     *
     * This is lazily created in {@link #getMatchers}.
     */

				/**
     * @private
     * @property {Autolinker.AnchorTagBuilder} tagBuilder
     *
     * The AnchorTagBuilder instance used to build match replacement anchor tags.
     * Note: this is lazily instantiated in the {@link #getTagBuilder} method.
     */

				/**
     * Normalizes the {@link #urls} config into an Object with 3 properties:
     * `schemeMatches`, `wwwMatches`, and `tldMatches`, all Booleans.
     *
     * See {@link #urls} config for details.
     *
     * @private
     * @param {Boolean/Object} urls
     * @return {Object}
     */
				normalizeUrlsCfg: function normalizeUrlsCfg(urls) {
					if (urls == null) urls = true; // default to `true`

					if (typeof urls === 'boolean') {
						return { schemeMatches: urls, wwwMatches: urls, tldMatches: urls };
					} else {
						// object form
						return {
							schemeMatches: typeof urls.schemeMatches === 'boolean' ? urls.schemeMatches : true,
							wwwMatches: typeof urls.wwwMatches === 'boolean' ? urls.wwwMatches : true,
							tldMatches: typeof urls.tldMatches === 'boolean' ? urls.tldMatches : true
						};
					}
				},

				/**
     * Normalizes the {@link #stripPrefix} config into an Object with 2
     * properties: `scheme`, and `www` - both Booleans.
     *
     * See {@link #stripPrefix} config for details.
     *
     * @private
     * @param {Boolean/Object} stripPrefix
     * @return {Object}
     */
				normalizeStripPrefixCfg: function normalizeStripPrefixCfg(stripPrefix) {
					if (stripPrefix == null) stripPrefix = true; // default to `true`

					if (typeof stripPrefix === 'boolean') {
						return { scheme: stripPrefix, www: stripPrefix };
					} else {
						// object form
						return {
							scheme: typeof stripPrefix.scheme === 'boolean' ? stripPrefix.scheme : true,
							www: typeof stripPrefix.www === 'boolean' ? stripPrefix.www : true
						};
					}
				},

				/**
     * Normalizes the {@link #truncate} config into an Object with 2 properties:
     * `length` (Number), and `location` (String).
     *
     * See {@link #truncate} config for details.
     *
     * @private
     * @param {Number/Object} truncate
     * @return {Object}
     */
				normalizeTruncateCfg: function normalizeTruncateCfg(truncate) {
					if (typeof truncate === 'number') {
						return { length: truncate, location: 'end' };
					} else {
						// object, or undefined/null
						return Autolinker.Util.defaults(truncate || {}, {
							length: Number.POSITIVE_INFINITY,
							location: 'end'
						});
					}
				},

				/**
     * Parses the input `textOrHtml` looking for URLs, email addresses, phone
     * numbers, username handles, and hashtags (depending on the configuration
     * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
     * objects describing those matches.
     *
     * This method is used by the {@link #link} method, but can also be used to
     * simply do parsing of the input in order to discover what kinds of links
     * there are and how many.
     *
     * @param {String} textOrHtml The HTML or text to find matches within
     *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},
     *   {@link #hashtag}, and {@link #mention} options are enabled).
     * @return {Autolinker.match.Match[]} The array of Matches found in the
     *   given input `textOrHtml`.
     */
				parse: function parse(textOrHtml) {
					var htmlParser = this.getHtmlParser(),
					    htmlNodes = htmlParser.parse(textOrHtml),
					    anchorTagStackCount = 0,
					    // used to only process text around anchor tags, and any inner text/html they may have;
					matches = [];

					// Find all matches within the `textOrHtml` (but not matches that are
					// already nested within <a> tags)
					for (var i = 0, len = htmlNodes.length; i < len; i++) {
						var node = htmlNodes[i],
						    nodeType = node.getType();

						if (nodeType === 'element' && node.getTagName() === 'a') {
							// Process HTML anchor element nodes in the input `textOrHtml` to find out when we're within an <a> tag
							if (!node.isClosing()) {
								// it's the start <a> tag
								anchorTagStackCount++;
							} else {
								// it's the end </a> tag
								anchorTagStackCount = Math.max(anchorTagStackCount - 1, 0); // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0
							}
						} else if (nodeType === 'text' && anchorTagStackCount === 0) {
							// Process text nodes that are not within an <a> tag
							var textNodeMatches = this.parseText(node.getText(), node.getOffset());

							matches.push.apply(matches, textNodeMatches);
						}
					}

					// After we have found all matches, remove subsequent matches that
					// overlap with a previous match. This can happen for instance with URLs,
					// where the url 'google.com/#link' would match '#link' as a hashtag.
					matches = this.compactMatches(matches);

					// And finally, remove matches for match types that have been turned
					// off. We needed to have all match types turned on initially so that
					// things like hashtags could be filtered out if they were really just
					// part of a URL match (for instance, as a named anchor).
					matches = this.removeUnwantedMatches(matches);

					return matches;
				},

				/**
     * After we have found all matches, we need to remove subsequent matches
     * that overlap with a previous match. This can happen for instance with
     * URLs, where the url 'google.com/#link' would match '#link' as a hashtag.
     *
     * @private
     * @param {Autolinker.match.Match[]} matches
     * @return {Autolinker.match.Match[]}
     */
				compactMatches: function compactMatches(matches) {
					// First, the matches need to be sorted in order of offset
					matches.sort(function (a, b) {
						return a.getOffset() - b.getOffset();
					});

					for (var i = 0; i < matches.length - 1; i++) {
						var match = matches[i],
						    endIdx = match.getOffset() + match.getMatchedText().length;

						// Remove subsequent matches that overlap with the current match
						while (i + 1 < matches.length && matches[i + 1].getOffset() <= endIdx) {
							matches.splice(i + 1, 1);
						}
					}

					return matches;
				},

				/**
     * Removes matches for matchers that were turned off in the options. For
     * example, if {@link #hashtag hashtags} were not to be matched, we'll
     * remove them from the `matches` array here.
     *
     * @private
     * @param {Autolinker.match.Match[]} matches The array of matches to remove
     *   the unwanted matches from. Note: this array is mutated for the
     *   removals.
     * @return {Autolinker.match.Match[]} The mutated input `matches` array.
     */
				removeUnwantedMatches: function removeUnwantedMatches(matches) {
					var remove = Autolinker.Util.remove;

					if (!this.hashtag) remove(matches, function (match) {
						return match.getType() === 'hashtag';
					});
					if (!this.email) remove(matches, function (match) {
						return match.getType() === 'email';
					});
					if (!this.phone) remove(matches, function (match) {
						return match.getType() === 'phone';
					});
					if (!this.mention) remove(matches, function (match) {
						return match.getType() === 'mention';
					});
					if (!this.urls.schemeMatches) {
						remove(matches, function (m) {
							return m.getType() === 'url' && m.getUrlMatchType() === 'scheme';
						});
					}
					if (!this.urls.wwwMatches) {
						remove(matches, function (m) {
							return m.getType() === 'url' && m.getUrlMatchType() === 'www';
						});
					}
					if (!this.urls.tldMatches) {
						remove(matches, function (m) {
							return m.getType() === 'url' && m.getUrlMatchType() === 'tld';
						});
					}

					return matches;
				},

				/**
     * Parses the input `text` looking for URLs, email addresses, phone
     * numbers, username handles, and hashtags (depending on the configuration
     * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
     * objects describing those matches.
     *
     * This method processes a **non-HTML string**, and is used to parse and
     * match within the text nodes of an HTML string. This method is used
     * internally by {@link #parse}.
     *
     * @private
     * @param {String} text The text to find matches within (depending on if the
     *   {@link #urls}, {@link #email}, {@link #phone},
     *   {@link #hashtag}, and {@link #mention} options are enabled). This must be a non-HTML string.
     * @param {Number} [offset=0] The offset of the text node within the
     *   original string. This is used when parsing with the {@link #parse}
     *   method to generate correct offsets within the {@link Autolinker.match.Match}
     *   instances, but may be omitted if calling this method publicly.
     * @return {Autolinker.match.Match[]} The array of Matches found in the
     *   given input `text`.
     */
				parseText: function parseText(text, offset) {
					offset = offset || 0;
					var matchers = this.getMatchers(),
					    matches = [];

					for (var i = 0, numMatchers = matchers.length; i < numMatchers; i++) {
						var textMatches = matchers[i].parseMatches(text);

						// Correct the offset of each of the matches. They are originally
						// the offset of the match within the provided text node, but we
						// need to correct them to be relative to the original HTML input
						// string (i.e. the one provided to #parse).
						for (var j = 0, numTextMatches = textMatches.length; j < numTextMatches; j++) {
							textMatches[j].setOffset(offset + textMatches[j].getOffset());
						}

						matches.push.apply(matches, textMatches);
					}
					return matches;
				},

				/**
     * Automatically links URLs, Email addresses, Phone numbers, Hashtags,
     * and Mentions (Twitter, Instagram) found in the given chunk of HTML. Does not link
     * URLs found within HTML tags.
     *
     * For instance, if given the text: `You should go to http://www.yahoo.com`,
     * then the result will be `You should go to
     * &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
     *
     * This method finds the text around any HTML elements in the input
     * `textOrHtml`, which will be the text that is processed. Any original HTML
     * elements will be left as-is, as well as the text that is already wrapped
     * in anchor (&lt;a&gt;) tags.
     *
     * @param {String} textOrHtml The HTML or text to autolink matches within
     *   (depending on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #hashtag}, and {@link #mention} options are enabled).
     * @return {String} The HTML, with matches automatically linked.
     */
				link: function link(textOrHtml) {
					if (!textOrHtml) {
						return "";
					} // handle `null` and `undefined`

					var matches = this.parse(textOrHtml),
					    newHtml = [],
					    lastIndex = 0;

					for (var i = 0, len = matches.length; i < len; i++) {
						var match = matches[i];

						newHtml.push(textOrHtml.substring(lastIndex, match.getOffset()));
						newHtml.push(this.createMatchReturnVal(match));

						lastIndex = match.getOffset() + match.getMatchedText().length;
					}
					newHtml.push(textOrHtml.substring(lastIndex)); // handle the text after the last match

					return newHtml.join('');
				},

				/**
     * Creates the return string value for a given match in the input string.
     *
     * This method handles the {@link #replaceFn}, if one was provided.
     *
     * @private
     * @param {Autolinker.match.Match} match The Match object that represents
     *   the match.
     * @return {String} The string that the `match` should be replaced with.
     *   This is usually the anchor tag string, but may be the `matchStr` itself
     *   if the match is not to be replaced.
     */
				createMatchReturnVal: function createMatchReturnVal(match) {
					// Handle a custom `replaceFn` being provided
					var replaceFnResult;
					if (this.replaceFn) {
						replaceFnResult = this.replaceFn.call(this.context, match); // Autolinker instance is the context
					}

					if (typeof replaceFnResult === 'string') {
						return replaceFnResult; // `replaceFn` returned a string, use that
					} else if (replaceFnResult === false) {
						return match.getMatchedText(); // no replacement for the match
					} else if (replaceFnResult instanceof Autolinker.HtmlTag) {
						return replaceFnResult.toAnchorString();
					} else {
						// replaceFnResult === true, or no/unknown return value from function
						// Perform Autolinker's default anchor tag generation
						var anchorTag = match.buildTag(); // returns an Autolinker.HtmlTag instance

						return anchorTag.toAnchorString();
					}
				},

				/**
     * Lazily instantiates and returns the {@link #htmlParser} instance for this
     * Autolinker instance.
     *
     * @protected
     * @return {Autolinker.htmlParser.HtmlParser}
     */
				getHtmlParser: function getHtmlParser() {
					var htmlParser = this.htmlParser;

					if (!htmlParser) {
						htmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();
					}

					return htmlParser;
				},

				/**
     * Lazily instantiates and returns the {@link Autolinker.matcher.Matcher}
     * instances for this Autolinker instance.
     *
     * @protected
     * @return {Autolinker.matcher.Matcher[]}
     */
				getMatchers: function getMatchers() {
					if (!this.matchers) {
						var matchersNs = Autolinker.matcher,
						    tagBuilder = this.getTagBuilder();

						var matchers = [new matchersNs.Hashtag({ tagBuilder: tagBuilder, serviceName: this.hashtag }), new matchersNs.Email({ tagBuilder: tagBuilder }), new matchersNs.Phone({ tagBuilder: tagBuilder }), new matchersNs.Mention({ tagBuilder: tagBuilder, serviceName: this.mention }), new matchersNs.Url({ tagBuilder: tagBuilder, stripPrefix: this.stripPrefix, stripTrailingSlash: this.stripTrailingSlash })];

						return this.matchers = matchers;
					} else {
						return this.matchers;
					}
				},

				/**
     * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it
     * if it does not yet exist.
     *
     * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that
     * Autolinker would normally generate, and then allow for modifications before returning it. For example:
     *
     *     var html = Autolinker.link( "Test google.com", {
     *         replaceFn : function( match ) {
     *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance
     *             tag.setAttr( 'rel', 'nofollow' );
     *
     *             return tag;
     *         }
     *     } );
     *
     *     // generated html:
     *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
     *
     * @return {Autolinker.AnchorTagBuilder}
     */
				getTagBuilder: function getTagBuilder() {
					var tagBuilder = this.tagBuilder;

					if (!tagBuilder) {
						tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder({
							newWindow: this.newWindow,
							truncate: this.truncate,
							className: this.className
						});
					}

					return tagBuilder;
				}

			};

			// Autolinker Namespaces

			Autolinker.match = {};
			Autolinker.matcher = {};
			Autolinker.htmlParser = {};
			Autolinker.truncate = {};

			/*global Autolinker */
			/*jshint eqnull:true, boss:true */
			/**
    * @class Autolinker.Util
    * @singleton
    *
    * A few utility methods for Autolinker.
    */
			Autolinker.Util = {

				/**
     * @property {Function} abstractMethod
     *
     * A function object which represents an abstract method.
     */
				abstractMethod: function abstractMethod() {
					throw "abstract";
				},

				/**
     * @private
     * @property {RegExp} trimRegex
     *
     * The regular expression used to trim the leading and trailing whitespace
     * from a string.
     */
				trimRegex: /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

				/**
     * Assigns (shallow copies) the properties of `src` onto `dest`.
     *
     * @param {Object} dest The destination object.
     * @param {Object} src The source object.
     * @return {Object} The destination object (`dest`)
     */
				assign: function assign(dest, src) {
					for (var prop in src) {
						if (src.hasOwnProperty(prop)) {
							dest[prop] = src[prop];
						}
					}

					return dest;
				},

				/**
     * Assigns (shallow copies) the properties of `src` onto `dest`, if the
     * corresponding property on `dest` === `undefined`.
     *
     * @param {Object} dest The destination object.
     * @param {Object} src The source object.
     * @return {Object} The destination object (`dest`)
     */
				defaults: function defaults(dest, src) {
					for (var prop in src) {
						if (src.hasOwnProperty(prop) && dest[prop] === undefined) {
							dest[prop] = src[prop];
						}
					}

					return dest;
				},

				/**
     * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.
     *
     * @param {Function} superclass The constructor function for the superclass.
     * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the
     *   special property `constructor`, which will be used as the new subclass's constructor function.
     * @return {Function} The new subclass function.
     */
				extend: function extend(superclass, protoProps) {
					var superclassProto = superclass.prototype;

					var F = function F() {};
					F.prototype = superclassProto;

					var subclass;
					if (protoProps.hasOwnProperty('constructor')) {
						subclass = protoProps.constructor;
					} else {
						subclass = function subclass() {
							superclassProto.constructor.apply(this, arguments);
						};
					}

					var subclassProto = subclass.prototype = new F(); // set up prototype chain
					subclassProto.constructor = subclass; // fix constructor property
					subclassProto.superclass = superclassProto;

					delete protoProps.constructor; // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there
					Autolinker.Util.assign(subclassProto, protoProps);

					return subclass;
				},

				/**
     * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the
     * end of the string (by default, two periods: '..'). If the `str` length does not exceed
     * `len`, the string will be returned unchanged.
     *
     * @param {String} str The string to truncate and add an ellipsis to.
     * @param {Number} truncateLen The length to truncate the string at.
     * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`
     *   when truncated. Defaults to '..'
     */
				ellipsis: function ellipsis(str, truncateLen, ellipsisChars) {
					if (str.length > truncateLen) {
						ellipsisChars = ellipsisChars == null ? '..' : ellipsisChars;
						str = str.substring(0, truncateLen - ellipsisChars.length) + ellipsisChars;
					}
					return str;
				},

				/**
     * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).
     *
     * @param {Array} arr The array to find an element of.
     * @param {*} element The element to find in the array, and return the index of.
     * @return {Number} The index of the `element`, or -1 if it was not found.
     */
				indexOf: function indexOf(arr, element) {
					if (Array.prototype.indexOf) {
						return arr.indexOf(element);
					} else {
						for (var i = 0, len = arr.length; i < len; i++) {
							if (arr[i] === element) return i;
						}
						return -1;
					}
				},

				/**
     * Removes array elements based on a filtering function. Mutates the input
     * array.
     *
     * Using this instead of the ES5 Array.prototype.filter() function, to allow
     * Autolinker compatibility with IE8, and also to prevent creating many new
     * arrays in memory for filtering.
     *
     * @param {Array} arr The array to remove elements from. This array is
     *   mutated.
     * @param {Function} fn A function which should return `true` to
     *   remove an element.
     * @return {Array} The mutated input `arr`.
     */
				remove: function remove(arr, fn) {
					for (var i = arr.length - 1; i >= 0; i--) {
						if (fn(arr[i]) === true) {
							arr.splice(i, 1);
						}
					}
				},

				/**
     * Performs the functionality of what modern browsers do when `String.prototype.split()` is called
     * with a regular expression that contains capturing parenthesis.
     *
     * For example:
     *
     *     // Modern browsers:
     *     "a,b,c".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]
     *
     *     // Old IE (including IE8):
     *     "a,b,c".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]
     *
     * This method emulates the functionality of modern browsers for the old IE case.
     *
     * @param {String} str The string to split.
     * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting
     *   character(s) will be spliced into the array, as in the "modern browsers" example in the
     *   description of this method.
     *   Note #1: the supplied regular expression **must** have the 'g' flag specified.
     *   Note #2: for simplicity's sake, the regular expression does not need
     *   to contain capturing parenthesis - it will be assumed that any match has them.
     * @return {String[]} The split array of strings, with the splitting character(s) included.
     */
				splitAndCapture: function splitAndCapture(str, splitRegex) {
					if (!splitRegex.global) throw new Error("`splitRegex` must have the 'g' flag set");

					var result = [],
					    lastIdx = 0,
					    match;

					while (match = splitRegex.exec(str)) {
						result.push(str.substring(lastIdx, match.index));
						result.push(match[0]); // push the splitting char(s)

						lastIdx = match.index + match[0].length;
					}
					result.push(str.substring(lastIdx));

					return result;
				},

				/**
     * Trims the leading and trailing whitespace from a string.
     *
     * @param {String} str The string to trim.
     * @return {String}
     */
				trim: function trim(str) {
					return str.replace(this.trimRegex, '');
				}

			};
			/*global Autolinker */
			/*jshint boss:true */
			/**
    * @class Autolinker.HtmlTag
    * @extends Object
    *
    * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.
    *
    * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use
    * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.
    *
    * ## Examples
    *
    * Example instantiation:
    *
    *     var tag = new Autolinker.HtmlTag( {
    *         tagName : 'a',
    *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },
    *         innerHtml : 'Google'
    *     } );
    *
    *     tag.toAnchorString();  // <a href="http://google.com" class="external-link">Google</a>
    *
    *     // Individual accessor methods
    *     tag.getTagName();                 // 'a'
    *     tag.getAttr( 'href' );            // 'http://google.com'
    *     tag.hasClass( 'external-link' );  // true
    *
    *
    * Using mutator methods (which may be used in combination with instantiation config properties):
    *
    *     var tag = new Autolinker.HtmlTag();
    *     tag.setTagName( 'a' );
    *     tag.setAttr( 'href', 'http://google.com' );
    *     tag.addClass( 'external-link' );
    *     tag.setInnerHtml( 'Google' );
    *
    *     tag.getTagName();                 // 'a'
    *     tag.getAttr( 'href' );            // 'http://google.com'
    *     tag.hasClass( 'external-link' );  // true
    *
    *     tag.toAnchorString();  // <a href="http://google.com" class="external-link">Google</a>
    *
    *
    * ## Example use within a {@link Autolinker#replaceFn replaceFn}
    *
    *     var html = Autolinker.link( "Test google.com", {
    *         replaceFn : function( match ) {
    *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text
    *             tag.setAttr( 'rel', 'nofollow' );
    *
    *             return tag;
    *         }
    *     } );
    *
    *     // generated html:
    *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
    *
    *
    * ## Example use with a new tag for the replacement
    *
    *     var html = Autolinker.link( "Test google.com", {
    *         replaceFn : function( match ) {
    *             var tag = new Autolinker.HtmlTag( {
    *                 tagName : 'button',
    *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },
    *                 innerHtml : 'Load URL: ' + match.getAnchorText()
    *             } );
    *
    *             return tag;
    *         }
    *     } );
    *
    *     // generated html:
    *     //   Test <button title="Load URL: http://google.com">Load URL: google.com</button>
    */
			Autolinker.HtmlTag = Autolinker.Util.extend(Object, {

				/**
     * @cfg {String} tagName
     *
     * The tag name. Ex: 'a', 'button', etc.
     *
     * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toAnchorString}
     * is executed.
     */

				/**
     * @cfg {Object.<String, String>} attrs
     *
     * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the
     * values are the attribute values.
     */

				/**
     * @cfg {String} innerHtml
     *
     * The inner HTML for the tag.
     *
     * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym
     * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}
     * if you prefer, but this one is recommended.
     */

				/**
     * @cfg {String} innerHTML
     *
     * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version
     * for acronym names.
     */

				/**
     * @protected
     * @property {RegExp} whitespaceRegex
     *
     * Regular expression used to match whitespace in a string of CSS classes.
     */
				whitespaceRegex: /\s+/,

				/**
     * @constructor
     * @param {Object} [cfg] The configuration properties for this class, in an Object (map)
     */
				constructor: function constructor(cfg) {
					Autolinker.Util.assign(this, cfg);

					this.innerHtml = this.innerHtml || this.innerHTML; // accept either the camelCased form or the fully capitalized acronym
				},

				/**
     * Sets the tag name that will be used to generate the tag with.
     *
     * @param {String} tagName
     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
     */
				setTagName: function setTagName(tagName) {
					this.tagName = tagName;
					return this;
				},

				/**
     * Retrieves the tag name.
     *
     * @return {String}
     */
				getTagName: function getTagName() {
					return this.tagName || "";
				},

				/**
     * Sets an attribute on the HtmlTag.
     *
     * @param {String} attrName The attribute name to set.
     * @param {String} attrValue The attribute value to set.
     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
     */
				setAttr: function setAttr(attrName, attrValue) {
					var tagAttrs = this.getAttrs();
					tagAttrs[attrName] = attrValue;

					return this;
				},

				/**
     * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.
     *
     * @param {String} attrName The attribute name to retrieve.
     * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.
     */
				getAttr: function getAttr(attrName) {
					return this.getAttrs()[attrName];
				},

				/**
     * Sets one or more attributes on the HtmlTag.
     *
     * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.
     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
     */
				setAttrs: function setAttrs(attrs) {
					var tagAttrs = this.getAttrs();
					Autolinker.Util.assign(tagAttrs, attrs);

					return this;
				},

				/**
     * Retrieves the attributes Object (map) for the HtmlTag.
     *
     * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.
     */
				getAttrs: function getAttrs() {
					return this.attrs || (this.attrs = {});
				},

				/**
     * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.
     *
     * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).
     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
     */
				setClass: function setClass(cssClass) {
					return this.setAttr('class', cssClass);
				},

				/**
     * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.
     *
     * @param {String} cssClass One or more space-separated CSS classes to add.
     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
     */
				addClass: function addClass(cssClass) {
					var classAttr = this.getClass(),
					    whitespaceRegex = this.whitespaceRegex,
					    indexOf = Autolinker.Util.indexOf,
					    // to support IE8 and below
					classes = !classAttr ? [] : classAttr.split(whitespaceRegex),
					    newClasses = cssClass.split(whitespaceRegex),
					    newClass;

					while (newClass = newClasses.shift()) {
						if (indexOf(classes, newClass) === -1) {
							classes.push(newClass);
						}
					}

					this.getAttrs()['class'] = classes.join(" ");
					return this;
				},

				/**
     * Convenience method to remove one or more CSS classes from the HtmlTag.
     *
     * @param {String} cssClass One or more space-separated CSS classes to remove.
     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
     */
				removeClass: function removeClass(cssClass) {
					var classAttr = this.getClass(),
					    whitespaceRegex = this.whitespaceRegex,
					    indexOf = Autolinker.Util.indexOf,
					    // to support IE8 and below
					classes = !classAttr ? [] : classAttr.split(whitespaceRegex),
					    removeClasses = cssClass.split(whitespaceRegex),
					    removeClass;

					while (classes.length && (removeClass = removeClasses.shift())) {
						var idx = indexOf(classes, removeClass);
						if (idx !== -1) {
							classes.splice(idx, 1);
						}
					}

					this.getAttrs()['class'] = classes.join(" ");
					return this;
				},

				/**
     * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when
     * there are multiple.
     *
     * @return {String}
     */
				getClass: function getClass() {
					return this.getAttrs()['class'] || "";
				},

				/**
     * Convenience method to check if the tag has a CSS class or not.
     *
     * @param {String} cssClass The CSS class to check for.
     * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.
     */
				hasClass: function hasClass(cssClass) {
					return (' ' + this.getClass() + ' ').indexOf(' ' + cssClass + ' ') !== -1;
				},

				/**
     * Sets the inner HTML for the tag.
     *
     * @param {String} html The inner HTML to set.
     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
     */
				setInnerHtml: function setInnerHtml(html) {
					this.innerHtml = html;

					return this;
				},

				/**
     * Retrieves the inner HTML for the tag.
     *
     * @return {String}
     */
				getInnerHtml: function getInnerHtml() {
					return this.innerHtml || "";
				},

				/**
     * Override of superclass method used to generate the HTML string for the tag.
     *
     * @return {String}
     */
				toAnchorString: function toAnchorString() {
					var tagName = this.getTagName(),
					    attrsStr = this.buildAttrsStr();

					attrsStr = attrsStr ? ' ' + attrsStr : ''; // prepend a space if there are actually attributes

					return ['<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>'].join("");
				},

				/**
     * Support method for {@link #toAnchorString}, returns the string space-separated key="value" pairs, used to populate
     * the stringified HtmlTag.
     *
     * @protected
     * @return {String} Example return: `attr1="value1" attr2="value2"`
     */
				buildAttrsStr: function buildAttrsStr() {
					if (!this.attrs) return ""; // no `attrs` Object (map) has been set, return empty string

					var attrs = this.getAttrs(),
					    attrsArr = [];

					for (var prop in attrs) {
						if (attrs.hasOwnProperty(prop)) {
							attrsArr.push(prop + '="' + attrs[prop] + '"');
						}
					}
					return attrsArr.join(" ");
				}

			});

			/*global Autolinker */
			/**
    * @class Autolinker.RegexLib
    * @singleton
    *
    * Builds and stores a library of the common regular expressions used by the
    * Autolinker utility.
    *
    * Other regular expressions may exist ad-hoc, but these are generally the
    * regular expressions that are shared between source files.
    */
			Autolinker.RegexLib = function () {

				/**
     * The string form of a regular expression that would match all of the
     * alphabetic ("letter") chars in the unicode character set when placed in a
     * RegExp character class (`[]`). This includes all international alphabetic
     * characters.
     *
     * These would be the characters matched by unicode regex engines `\p{L}`
     * escape ("all letters").
     *
     * Taken from the XRegExp library: http://xregexp.com/
     * Specifically: http://xregexp.com/v/3.0.0/unicode-categories.js
     *
     * @private
     * @type {String}
     */
				var alphaCharsStr = "A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";

				/**
     * The string form of a regular expression that would match all of the
     * decimal number chars in the unicode character set when placed in a RegExp
     * character class (`[]`).
     *
     * These would be the characters matched by unicode regex engines `\p{Nd}`
     * escape ("all decimal numbers")
     *
     * Taken from the XRegExp library: http://xregexp.com/
     * Specifically: http://xregexp.com/v/3.0.0/unicode-categories.js
     *
     * @private
     * @type {String}
     */
				var decimalNumbersStr = "0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19";

				// See documentation below
				var alphaNumericCharsStr = alphaCharsStr + decimalNumbersStr;

				// See documentation below
				var domainNameRegex = new RegExp('[' + alphaNumericCharsStr + '.\\-]*[' + alphaNumericCharsStr + '\\-]');

				// See documentation below
				var tldRegex = /(?:travelersinsurance|sandvikcoromant|kerryproperties|cancerresearch|weatherchannel|kerrylogistics|spreadbetting|international|wolterskluwer|lifeinsurance|construction|pamperedchef|scholarships|versicherung|bridgestone|creditunion|kerryhotels|investments|productions|blackfriday|enterprises|lamborghini|photography|motorcycles|williamhill|playstation|contractors|barclaycard|accountants|redumbrella|engineering|management|telefonica|protection|consulting|tatamotors|creditcard|vlaanderen|schaeffler|associates|properties|foundation|republican|bnpparibas|boehringer|eurovision|extraspace|industries|immobilien|university|technology|volkswagen|healthcare|restaurant|cuisinella|vistaprint|apartments|accountant|travelers|homedepot|institute|vacations|furniture|fresenius|insurance|christmas|bloomberg|solutions|barcelona|firestone|financial|kuokgroup|fairwinds|community|passagens|goldpoint|equipment|lifestyle|yodobashi|aquarelle|marketing|analytics|education|amsterdam|statefarm|melbourne|allfinanz|directory|microsoft|stockholm|montblanc|accenture|lancaster|landrover|everbank|istanbul|graphics|grainger|ipiranga|softbank|attorney|pharmacy|saarland|catering|airforce|yokohama|mortgage|frontier|mutuelle|stcgroup|memorial|pictures|football|symantec|cipriani|ventures|telecity|cityeats|verisign|flsmidth|boutique|cleaning|firmdale|clinique|clothing|redstone|infiniti|deloitte|feedback|services|broadway|plumbing|commbank|training|barclays|exchange|computer|brussels|software|delivery|barefoot|builders|business|bargains|engineer|holdings|download|security|helsinki|lighting|movistar|discount|hdfcbank|supplies|marriott|property|diamonds|capetown|partners|democrat|jpmorgan|bradesco|budapest|rexroth|zuerich|shriram|academy|science|support|youtube|singles|surgery|alibaba|statoil|dentist|schwarz|android|cruises|cricket|digital|markets|starhub|systems|courses|coupons|netbank|country|domains|corsica|network|neustar|realtor|lincoln|limited|schmidt|yamaxun|cooking|contact|auction|spiegel|liaison|leclerc|latrobe|lasalle|abogado|compare|lanxess|exposed|express|company|cologne|college|avianca|lacaixa|fashion|recipes|ferrero|komatsu|storage|wanggou|clubmed|sandvik|fishing|fitness|bauhaus|kitchen|flights|florist|flowers|watches|weather|temasek|samsung|bentley|forsale|channel|theater|frogans|theatre|okinawa|website|tickets|jewelry|gallery|tiffany|iselect|shiksha|brother|organic|wedding|genting|toshiba|origins|philips|hyundai|hotmail|hoteles|hosting|rentals|windows|cartier|bugatti|holiday|careers|whoswho|hitachi|panerai|caravan|reviews|guitars|capital|trading|hamburg|hangout|finance|stream|family|abbott|health|review|travel|report|hermes|hiphop|gratis|career|toyota|hockey|dating|repair|google|social|soccer|reisen|global|otsuka|giving|unicom|casino|photos|center|broker|rocher|orange|bostik|garden|insure|ryukyu|bharti|safety|physio|sakura|oracle|online|jaguar|gallup|piaget|tienda|futbol|pictet|joburg|webcam|berlin|office|juegos|kaufen|chanel|chrome|xihuan|church|tennis|circle|kinder|flickr|bayern|claims|clinic|viajes|nowruz|xperia|norton|yachts|studio|coffee|camera|sanofi|nissan|author|expert|events|comsec|lawyer|tattoo|viking|estate|villas|condos|realty|yandex|energy|emerck|virgin|vision|durban|living|school|coupon|london|taobao|natura|taipei|nagoya|luxury|walter|aramco|sydney|madrid|credit|maison|makeup|schule|market|anquan|direct|design|swatch|suzuki|alsace|vuelos|dental|alipay|voyage|shouji|voting|airtel|mutual|degree|supply|agency|museum|mobily|dealer|monash|select|mormon|active|moscow|racing|datsun|quebec|nissay|rodeo|email|gifts|works|photo|chloe|edeka|cheap|earth|vista|tushu|koeln|glass|shoes|globo|tunes|gmail|nokia|space|kyoto|black|ricoh|seven|lamer|sener|epson|cisco|praxi|trust|citic|crown|shell|lease|green|legal|lexus|ninja|tatar|gripe|nikon|group|video|wales|autos|gucci|party|nexus|guide|linde|adult|parts|amica|lixil|boats|azure|loans|locus|cymru|lotte|lotto|stada|click|poker|quest|dabur|lupin|nadex|paris|faith|dance|canon|place|gives|trade|skype|rocks|mango|cloud|boots|smile|final|swiss|homes|honda|media|horse|cards|deals|watch|bosch|house|pizza|miami|osaka|tours|total|xerox|coach|sucks|style|delta|toray|iinet|tools|money|codes|beats|tokyo|salon|archi|movie|baidu|study|actor|yahoo|store|apple|world|forex|today|bible|tmall|tirol|irish|tires|forum|reise|vegas|vodka|sharp|omega|weber|jetzt|audio|promo|build|bingo|chase|gallo|drive|dubai|rehab|press|solar|sale|beer|bbva|bank|band|auto|sapo|sarl|saxo|audi|asia|arte|arpa|army|yoga|ally|zara|scor|scot|sexy|seat|zero|seek|aero|adac|zone|aarp|maif|meet|meme|menu|surf|mini|mobi|mtpc|porn|desi|star|ltda|name|talk|navy|love|loan|live|link|news|limo|like|spot|life|nico|lidl|lgbt|land|taxi|team|tech|kred|kpmg|sony|song|kiwi|kddi|jprs|jobs|sohu|java|itau|tips|info|immo|icbc|hsbc|town|host|page|toys|here|help|pars|haus|guru|guge|tube|goog|golf|gold|sncf|gmbh|gift|ggee|gent|gbiz|game|vana|pics|fund|ford|ping|pink|fish|film|fast|farm|play|fans|fail|plus|skin|pohl|fage|moda|post|erni|dvag|prod|doha|prof|docs|viva|diet|luxe|site|dell|sina|dclk|show|qpon|date|vote|cyou|voto|read|coop|cool|wang|club|city|chat|cern|cash|reit|rent|casa|cars|care|camp|rest|call|cafe|weir|wien|rich|wiki|buzz|wine|book|bond|room|work|rsvp|shia|ruhr|blue|bing|shaw|bike|safe|xbox|best|pwc|mtn|lds|aig|boo|fyi|nra|nrw|ntt|car|gal|obi|zip|aeg|vin|how|one|ong|onl|dad|ooo|bet|esq|org|htc|bar|uol|ibm|ovh|gdn|ice|icu|uno|gea|ifm|bot|top|wtf|lol|day|pet|eus|wtc|ubs|tvs|aco|ing|ltd|ink|tab|abb|afl|cat|int|pid|pin|bid|cba|gle|com|cbn|ads|man|wed|ceb|gmo|sky|ist|gmx|tui|mba|fan|ski|iwc|app|pro|med|ceo|jcb|jcp|goo|dev|men|aaa|meo|pub|jlc|bom|jll|gop|jmp|mil|got|gov|win|jot|mma|joy|trv|red|cfa|cfd|bio|moe|moi|mom|ren|biz|aws|xin|bbc|dnp|buy|kfh|mov|thd|xyz|fit|kia|rio|rip|kim|dog|vet|nyc|bcg|mtr|bcn|bms|bmw|run|bzh|rwe|tel|stc|axa|kpn|fly|krd|cab|bnl|foo|crs|eat|tci|sap|srl|nec|sas|net|cal|sbs|sfr|sca|scb|csc|edu|new|xxx|hiv|fox|wme|ngo|nhk|vip|sex|frl|lat|yun|law|you|tax|soy|sew|om|ac|hu|se|sc|sg|sh|sb|sa|rw|ru|rs|ro|re|qa|py|si|pw|pt|ps|sj|sk|pr|pn|pm|pl|sl|sm|pk|sn|ph|so|pg|pf|pe|pa|zw|nz|nu|nr|np|no|nl|ni|ng|nf|sr|ne|st|nc|na|mz|my|mx|mw|mv|mu|mt|ms|mr|mq|mp|mo|su|mn|mm|ml|mk|mh|mg|me|sv|md|mc|sx|sy|ma|ly|lv|sz|lu|lt|ls|lr|lk|li|lc|lb|la|tc|kz|td|ky|kw|kr|kp|kn|km|ki|kh|tf|tg|th|kg|ke|jp|jo|jm|je|it|is|ir|tj|tk|tl|tm|iq|tn|to|io|in|im|il|ie|ad|sd|ht|hr|hn|hm|tr|hk|gy|gw|gu|gt|gs|gr|gq|tt|gp|gn|gm|gl|tv|gi|tw|tz|ua|gh|ug|uk|gg|gf|ge|gd|us|uy|uz|va|gb|ga|vc|ve|fr|fo|fm|fk|fj|vg|vi|fi|eu|et|es|er|eg|ee|ec|dz|do|dm|dk|vn|dj|de|cz|cy|cx|cw|vu|cv|cu|cr|co|cn|cm|cl|ck|ci|ch|cg|cf|cd|cc|ca|wf|bz|by|bw|bv|bt|bs|br|bo|bn|bm|bj|bi|ws|bh|bg|bf|be|bd|bb|ba|az|ax|aw|au|at|as|ye|ar|aq|ao|am|al|yt|ai|za|ag|af|ae|zm|id)\b/;

				return {

					/**
      * The string form of a regular expression that would match all of the
      * letters and decimal number chars in the unicode character set when placed
      * in a RegExp character class (`[]`).
      *
      * These would be the characters matched by unicode regex engines `[\p{L}\p{Nd}]`
      * escape ("all letters and decimal numbers")
      *
      * @property {String} alphaNumericCharsStr
      */
					alphaNumericCharsStr: alphaNumericCharsStr,

					/**
      * A regular expression to match domain names of a URL or email address.
      * Ex: 'google', 'yahoo', 'some-other-company', etc.
      *
      * @property {RegExp} domainNameRegex
      */
					domainNameRegex: domainNameRegex,

					/**
      * A regular expression to match top level domains (TLDs) for a URL or
      * email address. Ex: 'com', 'org', 'net', etc.
      *
      * @property {RegExp} tldRegex
      */
					tldRegex: tldRegex

				};
			}();
			/*global Autolinker */
			/*jshint sub:true */
			/**
    * @protected
    * @class Autolinker.AnchorTagBuilder
    * @extends Object
    *
    * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is
    * found.
    *
    * Normally this class is instantiated, configured, and used internally by an
    * {@link Autolinker} instance, but may actually be used indirectly in a
    * {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag}
    * instances which may be modified before returning from the
    * {@link Autolinker#replaceFn replaceFn}. For example:
    *
    *     var html = Autolinker.link( "Test google.com", {
    *         replaceFn : function( match ) {
    *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance
    *             tag.setAttr( 'rel', 'nofollow' );
    *
    *             return tag;
    *         }
    *     } );
    *
    *     // generated html:
    *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
    */
			Autolinker.AnchorTagBuilder = Autolinker.Util.extend(Object, {

				/**
     * @cfg {Boolean} newWindow
     * @inheritdoc Autolinker#newWindow
     */

				/**
     * @cfg {Object} truncate
     * @inheritdoc Autolinker#truncate
     */

				/**
     * @cfg {String} className
     * @inheritdoc Autolinker#className
     */

				/**
     * @constructor
     * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).
     */
				constructor: function constructor(cfg) {
					cfg = cfg || {};

					this.newWindow = cfg.newWindow;
					this.truncate = cfg.truncate;
					this.className = cfg.className;
				},

				/**
     * Generates the actual anchor (&lt;a&gt;) tag to use in place of the
     * matched text, via its `match` object.
     *
     * @param {Autolinker.match.Match} match The Match instance to generate an
     *   anchor tag from.
     * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.
     */
				build: function build(match) {
					return new Autolinker.HtmlTag({
						tagName: 'a',
						attrs: this.createAttrs(match),
						innerHtml: this.processAnchorText(match.getAnchorText())
					});
				},

				/**
     * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;)
     *   tag being generated.
     *
     * @protected
     * @param {Autolinker.match.Match} match The Match instance to generate an
     *   anchor tag from.
     * @return {Object} A key/value Object (map) of the anchor tag's attributes.
     */
				createAttrs: function createAttrs(match) {
					var attrs = {
						'href': match.getAnchorHref() // we'll always have the `href` attribute
					};

					var cssClass = this.createCssClass(match);
					if (cssClass) {
						attrs['class'] = cssClass;
					}
					if (this.newWindow) {
						attrs['target'] = "_blank";
						attrs['rel'] = "noopener noreferrer";
					}

					return attrs;
				},

				/**
     * Creates the CSS class that will be used for a given anchor tag, based on
     * the `matchType` and the {@link #className} config.
     *
     * Example returns:
     *
     * - ""                                      // no {@link #className}
     * - "myLink myLink-url"                     // url match
     * - "myLink myLink-email"                   // email match
     * - "myLink myLink-phone"                   // phone match
     * - "myLink myLink-hashtag"                 // hashtag match
     * - "myLink myLink-mention myLink-twitter"  // mention match with Twitter service
     *
     * @private
     * @param {Autolinker.match.Match} match The Match instance to generate an
     *   anchor tag from.
     * @return {String} The CSS class string for the link. Example return:
     *   "myLink myLink-url". If no {@link #className} was configured, returns
     *   an empty string.
     */
				createCssClass: function createCssClass(match) {
					var className = this.className;

					if (!className) {
						return "";
					} else {
						var returnClasses = [className],
						    cssClassSuffixes = match.getCssClassSuffixes();

						for (var i = 0, len = cssClassSuffixes.length; i < len; i++) {
							returnClasses.push(className + '-' + cssClassSuffixes[i]);
						}
						return returnClasses.join(' ');
					}
				},

				/**
     * Processes the `anchorText` by truncating the text according to the
     * {@link #truncate} config.
     *
     * @private
     * @param {String} anchorText The anchor tag's text (i.e. what will be
     *   displayed).
     * @return {String} The processed `anchorText`.
     */
				processAnchorText: function processAnchorText(anchorText) {
					anchorText = this.doTruncate(anchorText);

					return anchorText;
				},

				/**
     * Performs the truncation of the `anchorText` based on the {@link #truncate}
     * option. If the `anchorText` is longer than the length specified by the
     * {@link #truncate} option, the truncation is performed based on the
     * `location` property. See {@link #truncate} for details.
     *
     * @private
     * @param {String} anchorText The anchor tag's text (i.e. what will be
     *   displayed).
     * @return {String} The truncated anchor text.
     */
				doTruncate: function doTruncate(anchorText) {
					var truncate = this.truncate;
					if (!truncate || !truncate.length) return anchorText;

					var truncateLength = truncate.length,
					    truncateLocation = truncate.location;

					if (truncateLocation === 'smart') {
						return Autolinker.truncate.TruncateSmart(anchorText, truncateLength, '..');
					} else if (truncateLocation === 'middle') {
						return Autolinker.truncate.TruncateMiddle(anchorText, truncateLength, '..');
					} else {
						return Autolinker.truncate.TruncateEnd(anchorText, truncateLength, '..');
					}
				}

			});

			/*global Autolinker */
			/**
    * @class Autolinker.htmlParser.HtmlParser
    * @extends Object
    *
    * An HTML parser implementation which simply walks an HTML string and returns an array of
    * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.
    *
    * Autolinker uses this to only link URLs/emails/mentions within text nodes, effectively ignoring / "walking
    * around" HTML tags.
    */
			Autolinker.htmlParser.HtmlParser = Autolinker.Util.extend(Object, {

				/**
     * @private
     * @property {RegExp} htmlRegex
     *
     * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and
     * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.
     *
     * Capturing groups:
     *
     * 1. The "!DOCTYPE" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.
     * 2. If it is an end tag, this group will have the '/'.
     * 3. If it is a comment tag, this group will hold the comment text (i.e.
     *    the text inside the `&lt;!--` and `--&gt;`.
     * 4. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)
     */
				htmlRegex: function () {
					var commentTagRegex = /!--([\s\S]+?)--/,
					    tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,
					    attrNameRegex = /[^\s"'>\/=\x00-\x1F\x7F]+/,
					    // the unicode range accounts for excluding control chars, and the delete char
					attrValueRegex = /(?:"[^"]*?"|'[^']*?'|[^'"=<>`\s]+)/,
					    // double quoted, single quoted, or unquoted attribute values
					nameEqualsValueRegex = attrNameRegex.source + '(?:\\s*=\\s*' + attrValueRegex.source + ')?'; // optional '=[value]'

					return new RegExp([
					// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
					'(?:', '<(!DOCTYPE)', // *** Capturing Group 1 - If it's a doctype tag

					// Zero or more attributes following the tag name
					'(?:', '\\s+', // one or more whitespace chars before an attribute

					// Either:
					// A. attr="value", or
					// B. "value" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
					'(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')', ')*', '>', ')', '|',

					// All other HTML tags (i.e. tags that are not <!DOCTYPE>)
					'(?:', '<(/)?', // Beginning of a tag or comment. Either '<' for a start tag, or '</' for an end tag.
					// *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.

					'(?:', commentTagRegex.source, // *** Capturing Group 3 - A Comment Tag's Text

					'|', '(?:',

					// *** Capturing Group 4 - The tag name
					'(' + tagNameRegex.source + ')',

					// Zero or more attributes following the tag name
					'(?:', '(?:\\s+|\\b)', // any number of whitespace chars before an attribute. NOTE: Using \s* here throws Chrome into an infinite loop for some reason, so using \s+|\b instead
					nameEqualsValueRegex, // attr="value" (with optional ="value" part)
					')*', '\\s*/?', // any trailing spaces and optional '/' before the closing '>'

					')', ')', '>', ')'].join(""), 'gi');
				}(),

				/**
     * @private
     * @property {RegExp} htmlCharacterEntitiesRegex
     *
     * The regular expression that matches common HTML character entities.
     *
     * Ignoring &amp; as it could be part of a query string -- handling it separately.
     */
				htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,

				/**
     * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes}
     * to represent the HTML structure of the input string.
     *
     * @param {String} html The HTML to parse.
     * @return {Autolinker.htmlParser.HtmlNode[]}
     */
				parse: function parse(html) {
					var htmlRegex = this.htmlRegex,
					    currentResult,
					    lastIndex = 0,
					    textAndEntityNodes,
					    nodes = []; // will be the result of the method

					while ((currentResult = htmlRegex.exec(html)) !== null) {
						var tagText = currentResult[0],
						    commentText = currentResult[3],
						    // if we've matched a comment
						tagName = currentResult[1] || currentResult[4],
						    // The <!DOCTYPE> tag (ex: "!DOCTYPE"), or another tag (ex: "a" or "img")
						isClosingTag = !!currentResult[2],
						    offset = currentResult.index,
						    inBetweenTagsText = html.substring(lastIndex, offset);

						// Push TextNodes and EntityNodes for any text found between tags
						if (inBetweenTagsText) {
							textAndEntityNodes = this.parseTextAndEntityNodes(lastIndex, inBetweenTagsText);
							nodes.push.apply(nodes, textAndEntityNodes);
						}

						// Push the CommentNode or ElementNode
						if (commentText) {
							nodes.push(this.createCommentNode(offset, tagText, commentText));
						} else {
							nodes.push(this.createElementNode(offset, tagText, tagName, isClosingTag));
						}

						lastIndex = offset + tagText.length;
					}

					// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.
					if (lastIndex < html.length) {
						var text = html.substring(lastIndex);

						// Push TextNodes and EntityNodes for any text found between tags
						if (text) {
							textAndEntityNodes = this.parseTextAndEntityNodes(lastIndex, text);
							nodes.push.apply(nodes, textAndEntityNodes);
						}
					}

					return nodes;
				},

				/**
     * Parses text and HTML entity nodes from a given string. The input string
     * should not have any HTML tags (elements) within it.
     *
     * @private
     * @param {Number} offset The offset of the text node match within the
     *   original HTML string.
     * @param {String} text The string of text to parse. This is from an HTML
     *   text node.
     * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to
     *   represent the {@link Autolinker.htmlParser.TextNode TextNodes} and
     *   {@link Autolinker.htmlParser.EntityNode EntityNodes} found.
     */
				parseTextAndEntityNodes: function parseTextAndEntityNodes(offset, text) {
					var nodes = [],
					    textAndEntityTokens = Autolinker.Util.splitAndCapture(text, this.htmlCharacterEntitiesRegex); // split at HTML entities, but include the HTML entities in the results array

					// Every even numbered token is a TextNode, and every odd numbered token is an EntityNode
					// For example: an input `text` of "Test &quot;this&quot; today" would turn into the
					//   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]
					for (var i = 0, len = textAndEntityTokens.length; i < len; i += 2) {
						var textToken = textAndEntityTokens[i],
						    entityToken = textAndEntityTokens[i + 1];

						if (textToken) {
							nodes.push(this.createTextNode(offset, textToken));
							offset += textToken.length;
						}
						if (entityToken) {
							nodes.push(this.createEntityNode(offset, entityToken));
							offset += entityToken.length;
						}
					}
					return nodes;
				},

				/**
     * Factory method to create an {@link Autolinker.htmlParser.CommentNode CommentNode}.
     *
     * @private
     * @param {Number} offset The offset of the match within the original HTML
     *   string.
     * @param {String} tagText The full text of the tag (comment) that was
     *   matched, including its &lt;!-- and --&gt;.
     * @param {String} commentText The full text of the comment that was matched.
     */
				createCommentNode: function createCommentNode(offset, tagText, commentText) {
					return new Autolinker.htmlParser.CommentNode({
						offset: offset,
						text: tagText,
						comment: Autolinker.Util.trim(commentText)
					});
				},

				/**
     * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.
     *
     * @private
     * @param {Number} offset The offset of the match within the original HTML
     *   string.
     * @param {String} tagText The full text of the tag (element) that was
     *   matched, including its attributes.
     * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would
     *   be passed to this method as "img".
     * @param {Boolean} isClosingTag `true` if it's a closing tag, false
     *   otherwise.
     * @return {Autolinker.htmlParser.ElementNode}
     */
				createElementNode: function createElementNode(offset, tagText, tagName, isClosingTag) {
					return new Autolinker.htmlParser.ElementNode({
						offset: offset,
						text: tagText,
						tagName: tagName.toLowerCase(),
						closing: isClosingTag
					});
				},

				/**
     * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.
     *
     * @private
     * @param {Number} offset The offset of the match within the original HTML
     *   string.
     * @param {String} text The text that was matched for the HTML entity (such
     *   as '&amp;nbsp;').
     * @return {Autolinker.htmlParser.EntityNode}
     */
				createEntityNode: function createEntityNode(offset, text) {
					return new Autolinker.htmlParser.EntityNode({ offset: offset, text: text });
				},

				/**
     * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.
     *
     * @private
     * @param {Number} offset The offset of the match within the original HTML
     *   string.
     * @param {String} text The text that was matched.
     * @return {Autolinker.htmlParser.TextNode}
     */
				createTextNode: function createTextNode(offset, text) {
					return new Autolinker.htmlParser.TextNode({ offset: offset, text: text });
				}

			});

			/*global Autolinker */
			/**
    * @abstract
    * @class Autolinker.htmlParser.HtmlNode
    *
    * Represents an HTML node found in an input string. An HTML node is one of the
    * following:
    *
    * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents
    *    HTML tags.
    * 2. A {@link Autolinker.htmlParser.CommentNode CommentNode}, which represents
    *    HTML comments.
    * 3. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text
    *    outside or within HTML tags.
    * 4. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents
    *    one of the known HTML entities that Autolinker looks for. This includes
    *    common ones such as &amp;quot; and &amp;nbsp;
    */
			Autolinker.htmlParser.HtmlNode = Autolinker.Util.extend(Object, {

				/**
     * @cfg {Number} offset (required)
     *
     * The offset of the HTML node in the original text that was parsed.
     */
				offset: undefined,

				/**
     * @cfg {String} text (required)
     *
     * The text that was matched for the HtmlNode.
     *
     * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode},
     *   this will be the tag's text.
     * - In the case of an {@link Autolinker.htmlParser.CommentNode CommentNode},
     *   this will be the comment's text.
     * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this
     *   will be the text itself.
     * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode},
     *   this will be the text of the HTML entity.
     */
				text: undefined,

				/**
     * @constructor
     * @param {Object} cfg The configuration properties for the Match instance,
     * specified in an Object (map).
     */
				constructor: function constructor(cfg) {
					Autolinker.Util.assign(this, cfg);

					if (this.offset == null) throw new Error('`offset` cfg required');
					if (this.text == null) throw new Error('`text` cfg required');
				},

				/**
     * Returns a string name for the type of node that this class represents.
     *
     * @abstract
     * @return {String}
     */
				getType: Autolinker.Util.abstractMethod,

				/**
     * Retrieves the {@link #offset} of the HtmlNode. This is the offset of the
     * HTML node in the original string that was parsed.
     *
     * @return {Number}
     */
				getOffset: function getOffset() {
					return this.offset;
				},

				/**
     * Retrieves the {@link #text} for the HtmlNode.
     *
     * @return {String}
     */
				getText: function getText() {
					return this.text;
				}

			});
			/*global Autolinker */
			/**
    * @class Autolinker.htmlParser.CommentNode
    * @extends Autolinker.htmlParser.HtmlNode
    *
    * Represents an HTML comment node that has been parsed by the
    * {@link Autolinker.htmlParser.HtmlParser}.
    *
    * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
    * details.
    */
			Autolinker.htmlParser.CommentNode = Autolinker.Util.extend(Autolinker.htmlParser.HtmlNode, {

				/**
     * @cfg {String} comment (required)
     *
     * The text inside the comment tag. This text is stripped of any leading or
     * trailing whitespace.
     */
				comment: '',

				/**
     * Returns a string name for the type of node that this class represents.
     *
     * @return {String}
     */
				getType: function getType() {
					return 'comment';
				},

				/**
     * Returns the comment inside the comment tag.
     *
     * @return {String}
     */
				getComment: function getComment() {
					return this.comment;
				}

			});
			/*global Autolinker */
			/**
    * @class Autolinker.htmlParser.ElementNode
    * @extends Autolinker.htmlParser.HtmlNode
    *
    * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
    *
    * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
    * details.
    */
			Autolinker.htmlParser.ElementNode = Autolinker.Util.extend(Autolinker.htmlParser.HtmlNode, {

				/**
     * @cfg {String} tagName (required)
     *
     * The name of the tag that was matched.
     */
				tagName: '',

				/**
     * @cfg {Boolean} closing (required)
     *
     * `true` if the element (tag) is a closing tag, `false` if its an opening
     * tag.
     */
				closing: false,

				/**
     * Returns a string name for the type of node that this class represents.
     *
     * @return {String}
     */
				getType: function getType() {
					return 'element';
				},

				/**
     * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag,
     * returns "img".
     *
     * @return {String}
     */
				getTagName: function getTagName() {
					return this.tagName;
				},

				/**
     * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt;
     * returns `false`, while &lt;/div&gt; returns `true`.
     *
     * @return {Boolean}
     */
				isClosing: function isClosing() {
					return this.closing;
				}

			});
			/*global Autolinker */
			/**
    * @class Autolinker.htmlParser.EntityNode
    * @extends Autolinker.htmlParser.HtmlNode
    *
    * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
    * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText}
    * method.
    *
    * Note that this class will only be returned from the HtmlParser for the set of
    * checked HTML entity nodes  defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.
    *
    * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
    * details.
    */
			Autolinker.htmlParser.EntityNode = Autolinker.Util.extend(Autolinker.htmlParser.HtmlNode, {

				/**
     * Returns a string name for the type of node that this class represents.
     *
     * @return {String}
     */
				getType: function getType() {
					return 'entity';
				}

			});
			/*global Autolinker */
			/**
    * @class Autolinker.htmlParser.TextNode
    * @extends Autolinker.htmlParser.HtmlNode
    *
    * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
    *
    * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
    * details.
    */
			Autolinker.htmlParser.TextNode = Autolinker.Util.extend(Autolinker.htmlParser.HtmlNode, {

				/**
     * Returns a string name for the type of node that this class represents.
     *
     * @return {String}
     */
				getType: function getType() {
					return 'text';
				}

			});
			/*global Autolinker */
			/**
    * @abstract
    * @class Autolinker.match.Match
    *
    * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a
    * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.
    *
    * For example:
    *
    *     var input = "...";  // string with URLs, Email Addresses, and Mentions (Twitter, Instagram)
    *
    *     var linkedText = Autolinker.link( input, {
    *         replaceFn : function( match ) {
    *             console.log( "href = ", match.getAnchorHref() );
    *             console.log( "text = ", match.getAnchorText() );
    *
    *             switch( match.getType() ) {
    *                 case 'url' :
    *                     console.log( "url: ", match.getUrl() );
    *
    *                 case 'email' :
    *                     console.log( "email: ", match.getEmail() );
    *
    *                 case 'mention' :
    *                     console.log( "mention: ", match.getMention() );
    *             }
    *         }
    *     } );
    *
    * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.
    */
			Autolinker.match.Match = Autolinker.Util.extend(Object, {

				/**
     * @cfg {Autolinker.AnchorTagBuilder} tagBuilder (required)
     *
     * Reference to the AnchorTagBuilder instance to use to generate an anchor
     * tag for the Match.
     */

				/**
     * @cfg {String} matchedText (required)
     *
     * The original text that was matched by the {@link Autolinker.matcher.Matcher}.
     */

				/**
     * @cfg {Number} offset (required)
     *
     * The offset of where the match was made in the input string.
     */

				/**
     * @constructor
     * @param {Object} cfg The configuration properties for the Match
     *   instance, specified in an Object (map).
     */
				constructor: function constructor(cfg) {
					if (cfg.tagBuilder == null) throw new Error('`tagBuilder` cfg required');
					if (cfg.matchedText == null) throw new Error('`matchedText` cfg required');
					if (cfg.offset == null) throw new Error('`offset` cfg required');

					this.tagBuilder = cfg.tagBuilder;
					this.matchedText = cfg.matchedText;
					this.offset = cfg.offset;
				},

				/**
     * Returns a string name for the type of match that this class represents.
     *
     * @abstract
     * @return {String}
     */
				getType: Autolinker.Util.abstractMethod,

				/**
     * Returns the original text that was matched.
     *
     * @return {String}
     */
				getMatchedText: function getMatchedText() {
					return this.matchedText;
				},

				/**
     * Sets the {@link #offset} of where the match was made in the input string.
     *
     * A {@link Autolinker.matcher.Matcher} will be fed only HTML text nodes,
     * and will therefore set an original offset that is relative to the HTML
     * text node itself. However, we want this offset to be relative to the full
     * HTML input string, and thus if using {@link Autolinker#parse} (rather
     * than calling a {@link Autolinker.matcher.Matcher} directly), then this
     * offset is corrected after the Matcher itself has done its job.
     *
     * @param {Number} offset
     */
				setOffset: function setOffset(offset) {
					this.offset = offset;
				},

				/**
     * Returns the offset of where the match was made in the input string. This
     * is the 0-based index of the match.
     *
     * @return {Number}
     */
				getOffset: function getOffset() {
					return this.offset;
				},

				/**
     * Returns the anchor href that should be generated for the match.
     *
     * @abstract
     * @return {String}
     */
				getAnchorHref: Autolinker.Util.abstractMethod,

				/**
     * Returns the anchor text that should be generated for the match.
     *
     * @abstract
     * @return {String}
     */
				getAnchorText: Autolinker.Util.abstractMethod,

				/**
     * Returns the CSS class suffix(es) for this match.
     *
     * A CSS class suffix is appended to the {@link Autolinker#className} in
     * the {@link Autolinker.AnchorTagBuilder} when a match is translated into
     * an anchor tag.
     *
     * For example, if {@link Autolinker#className} was configured as 'myLink',
     * and this method returns `[ 'url' ]`, the final class name of the element
     * will become: 'myLink myLink-url'.
     *
     * The match may provide multiple CSS class suffixes to be appended to the
     * {@link Autolinker#className} in order to facilitate better styling
     * options for different match criteria. See {@link Autolinker.match.Mention}
     * for an example.
     *
     * By default, this method returns a single array with the match's
     * {@link #getType type} name, but may be overridden by subclasses.
     *
     * @return {String[]}
     */
				getCssClassSuffixes: function getCssClassSuffixes() {
					return [this.getType()];
				},

				/**
     * Builds and returns an {@link Autolinker.HtmlTag} instance based on the
     * Match.
     *
     * This can be used to easily generate anchor tags from matches, and either
     * return their HTML string, or modify them before doing so.
     *
     * Example Usage:
     *
     *     var tag = match.buildTag();
     *     tag.addClass( 'cordova-link' );
     *     tag.setAttr( 'target', '_system' );
     *
     *     tag.toAnchorString();  // <a href="http://google.com" class="cordova-link" target="_system">Google</a>
     */
				buildTag: function buildTag() {
					return this.tagBuilder.build(this);
				}

			});

			/*global Autolinker */
			/**
    * @class Autolinker.match.Email
    * @extends Autolinker.match.Match
    *
    * Represents a Email match found in an input string which should be Autolinked.
    *
    * See this class's superclass ({@link Autolinker.match.Match}) for more details.
    */
			Autolinker.match.Email = Autolinker.Util.extend(Autolinker.match.Match, {

				/**
     * @cfg {String} email (required)
     *
     * The email address that was matched.
     */

				/**
     * @constructor
     * @param {Object} cfg The configuration properties for the Match
     *   instance, specified in an Object (map).
     */
				constructor: function constructor(cfg) {
					Autolinker.match.Match.prototype.constructor.call(this, cfg);

					if (!cfg.email) throw new Error('`email` cfg required');

					this.email = cfg.email;
				},

				/**
     * Returns a string name for the type of match that this class represents.
     *
     * @return {String}
     */
				getType: function getType() {
					return 'email';
				},

				/**
     * Returns the email address that was matched.
     *
     * @return {String}
     */
				getEmail: function getEmail() {
					return this.email;
				},

				/**
     * Returns the anchor href that should be generated for the match.
     *
     * @return {String}
     */
				getAnchorHref: function getAnchorHref() {
					return 'mailto:' + this.email;
				},

				/**
     * Returns the anchor text that should be generated for the match.
     *
     * @return {String}
     */
				getAnchorText: function getAnchorText() {
					return this.email;
				}

			});
			/*global Autolinker */
			/**
    * @class Autolinker.match.Hashtag
    * @extends Autolinker.match.Match
    *
    * Represents a Hashtag match found in an input string which should be
    * Autolinked.
    *
    * See this class's superclass ({@link Autolinker.match.Match}) for more
    * details.
    */
			Autolinker.match.Hashtag = Autolinker.Util.extend(Autolinker.match.Match, {

				/**
     * @cfg {String} serviceName
     *
     * The service to point hashtag matches to. See {@link Autolinker#hashtag}
     * for available values.
     */

				/**
     * @cfg {String} hashtag (required)
     *
     * The Hashtag that was matched, without the '#'.
     */

				/**
     * @constructor
     * @param {Object} cfg The configuration properties for the Match
     *   instance, specified in an Object (map).
     */
				constructor: function constructor(cfg) {
					Autolinker.match.Match.prototype.constructor.call(this, cfg);

					// TODO: if( !serviceName ) throw new Error( '`serviceName` cfg required' );
					if (!cfg.hashtag) throw new Error('`hashtag` cfg required');

					this.serviceName = cfg.serviceName;
					this.hashtag = cfg.hashtag;
				},

				/**
     * Returns the type of match that this class represents.
     *
     * @return {String}
     */
				getType: function getType() {
					return 'hashtag';
				},

				/**
     * Returns the configured {@link #serviceName} to point the Hashtag to.
     * Ex: 'facebook', 'twitter'.
     *
     * @return {String}
     */
				getServiceName: function getServiceName() {
					return this.serviceName;
				},

				/**
     * Returns the matched hashtag, without the '#' character.
     *
     * @return {String}
     */
				getHashtag: function getHashtag() {
					return this.hashtag;
				},

				/**
     * Returns the anchor href that should be generated for the match.
     *
     * @return {String}
     */
				getAnchorHref: function getAnchorHref() {
					var serviceName = this.serviceName,
					    hashtag = this.hashtag;

					switch (serviceName) {
						case 'twitter':
							return 'https://twitter.com/hashtag/' + hashtag;
						case 'facebook':
							return 'https://www.facebook.com/hashtag/' + hashtag;
						case 'instagram':
							return 'https://instagram.com/explore/tags/' + hashtag;

						default:
							// Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.
							throw new Error('Unknown service name to point hashtag to: ', serviceName);
					}
				},

				/**
     * Returns the anchor text that should be generated for the match.
     *
     * @return {String}
     */
				getAnchorText: function getAnchorText() {
					return '#' + this.hashtag;
				}

			});

			/*global Autolinker */
			/**
    * @class Autolinker.match.Phone
    * @extends Autolinker.match.Match
    *
    * Represents a Phone number match found in an input string which should be
    * Autolinked.
    *
    * See this class's superclass ({@link Autolinker.match.Match}) for more
    * details.
    */
			Autolinker.match.Phone = Autolinker.Util.extend(Autolinker.match.Match, {

				/**
     * @protected
     * @property {String} number (required)
     *
     * The phone number that was matched, without any delimiter characters.
     *
     * Note: This is a string to allow for prefixed 0's.
     */

				/**
     * @protected
     * @property  {Boolean} plusSign (required)
     *
     * `true` if the matched phone number started with a '+' sign. We'll include
     * it in the `tel:` URL if so, as this is needed for international numbers.
     *
     * Ex: '+1 (123) 456 7879'
     */

				/**
     * @constructor
     * @param {Object} cfg The configuration properties for the Match
     *   instance, specified in an Object (map).
     */
				constructor: function constructor(cfg) {
					Autolinker.match.Match.prototype.constructor.call(this, cfg);

					if (!cfg.number) throw new Error('`number` cfg required');
					if (cfg.plusSign == null) throw new Error('`plusSign` cfg required');

					this.number = cfg.number;
					this.plusSign = cfg.plusSign;
				},

				/**
     * Returns a string name for the type of match that this class represents.
     *
     * @return {String}
     */
				getType: function getType() {
					return 'phone';
				},

				/**
     * Returns the phone number that was matched as a string, without any
     * delimiter characters.
     *
     * Note: This is a string to allow for prefixed 0's.
     *
     * @return {String}
     */
				getNumber: function getNumber() {
					return this.number;
				},

				/**
     * Returns the anchor href that should be generated for the match.
     *
     * @return {String}
     */
				getAnchorHref: function getAnchorHref() {
					return 'tel:' + (this.plusSign ? '+' : '') + this.number;
				},

				/**
     * Returns the anchor text that should be generated for the match.
     *
     * @return {String}
     */
				getAnchorText: function getAnchorText() {
					return this.matchedText;
				}

			});

			/*global Autolinker */
			/**
    * @class Autolinker.match.Mention
    * @extends Autolinker.match.Match
    *
    * Represents a Mention match found in an input string which should be Autolinked.
    *
    * See this class's superclass ({@link Autolinker.match.Match}) for more details.
    */
			Autolinker.match.Mention = Autolinker.Util.extend(Autolinker.match.Match, {

				/**
     * @cfg {String} serviceName
     *
     * The service to point mention matches to. See {@link Autolinker#mention}
     * for available values.
     */

				/**
     * @cfg {String} mention (required)
     *
     * The Mention that was matched, without the '@' character.
     */

				/**
     * @constructor
     * @param {Object} cfg The configuration properties for the Match
     *   instance, specified in an Object (map).
     */
				constructor: function constructor(cfg) {
					Autolinker.match.Match.prototype.constructor.call(this, cfg);

					if (!cfg.serviceName) throw new Error('`serviceName` cfg required');
					if (!cfg.mention) throw new Error('`mention` cfg required');

					this.mention = cfg.mention;
					this.serviceName = cfg.serviceName;
				},

				/**
     * Returns the type of match that this class represents.
     *
     * @return {String}
     */
				getType: function getType() {
					return 'mention';
				},

				/**
     * Returns the mention, without the '@' character.
     *
     * @return {String}
     */
				getMention: function getMention() {
					return this.mention;
				},

				/**
     * Returns the configured {@link #serviceName} to point the mention to.
     * Ex: 'instagram', 'twitter'.
     *
     * @return {String}
     */
				getServiceName: function getServiceName() {
					return this.serviceName;
				},

				/**
     * Returns the anchor href that should be generated for the match.
     *
     * @return {String}
     */
				getAnchorHref: function getAnchorHref() {
					switch (this.serviceName) {
						case 'twitter':
							return 'https://twitter.com/' + this.mention;
						case 'instagram':
							return 'https://instagram.com/' + this.mention;

						default:
							// Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.
							throw new Error('Unknown service name to point mention to: ', this.serviceName);
					}
				},

				/**
     * Returns the anchor text that should be generated for the match.
     *
     * @return {String}
     */
				getAnchorText: function getAnchorText() {
					return '@' + this.mention;
				},

				/**
     * Returns the CSS class suffixes that should be used on a tag built with
     * the match. See {@link Autolinker.match.Match#getCssClassSuffixes} for
     * details.
     *
     * @return {String[]}
     */
				getCssClassSuffixes: function getCssClassSuffixes() {
					var cssClassSuffixes = Autolinker.match.Match.prototype.getCssClassSuffixes.call(this),
					    serviceName = this.getServiceName();

					if (serviceName) {
						cssClassSuffixes.push(serviceName);
					}
					return cssClassSuffixes;
				}

			});

			/*global Autolinker */
			/**
    * @class Autolinker.match.Url
    * @extends Autolinker.match.Match
    *
    * Represents a Url match found in an input string which should be Autolinked.
    *
    * See this class's superclass ({@link Autolinker.match.Match}) for more details.
    */
			Autolinker.match.Url = Autolinker.Util.extend(Autolinker.match.Match, {

				/**
     * @cfg {String} url (required)
     *
     * The url that was matched.
     */

				/**
     * @cfg {"scheme"/"www"/"tld"} urlMatchType (required)
     *
     * The type of URL match that this class represents. This helps to determine
     * if the match was made in the original text with a prefixed scheme (ex:
     * 'http://www.google.com'), a prefixed 'www' (ex: 'www.google.com'), or
     * was matched by a known top-level domain (ex: 'google.com').
     */

				/**
     * @cfg {Boolean} protocolUrlMatch (required)
     *
     * `true` if the URL is a match which already has a protocol (i.e.
     * 'http://'), `false` if the match was from a 'www' or known TLD match.
     */

				/**
     * @cfg {Boolean} protocolRelativeMatch (required)
     *
     * `true` if the URL is a protocol-relative match. A protocol-relative match
     * is a URL that starts with '//', and will be either http:// or https://
     * based on the protocol that the site is loaded under.
     */

				/**
     * @cfg {Object} stripPrefix (required)
     *
     * The Object form of {@link Autolinker#cfg-stripPrefix}.
     */

				/**
     * @cfg {Boolean} stripTrailingSlash (required)
     * @inheritdoc Autolinker#cfg-stripTrailingSlash
     */

				/**
     * @constructor
     * @param {Object} cfg The configuration properties for the Match
     *   instance, specified in an Object (map).
     */
				constructor: function constructor(cfg) {
					Autolinker.match.Match.prototype.constructor.call(this, cfg);

					if (cfg.urlMatchType !== 'scheme' && cfg.urlMatchType !== 'www' && cfg.urlMatchType !== 'tld') throw new Error('`urlMatchType` cfg must be one of: "scheme", "www", or "tld"');
					if (!cfg.url) throw new Error('`url` cfg required');
					if (cfg.protocolUrlMatch == null) throw new Error('`protocolUrlMatch` cfg required');
					if (cfg.protocolRelativeMatch == null) throw new Error('`protocolRelativeMatch` cfg required');
					if (cfg.stripPrefix == null) throw new Error('`stripPrefix` cfg required');
					if (cfg.stripTrailingSlash == null) throw new Error('`stripTrailingSlash` cfg required');

					this.urlMatchType = cfg.urlMatchType;
					this.url = cfg.url;
					this.protocolUrlMatch = cfg.protocolUrlMatch;
					this.protocolRelativeMatch = cfg.protocolRelativeMatch;
					this.stripPrefix = cfg.stripPrefix;
					this.stripTrailingSlash = cfg.stripTrailingSlash;
				},

				/**
     * @private
     * @property {RegExp} schemePrefixRegex
     *
     * A regular expression used to remove the 'http://' or 'https://' from
     * URLs.
     */
				schemePrefixRegex: /^(https?:\/\/)?/i,

				/**
     * @private
     * @property {RegExp} wwwPrefixRegex
     *
     * A regular expression used to remove the 'www.' from URLs.
     */
				wwwPrefixRegex: /^(https?:\/\/)?(www\.)?/i,

				/**
     * @private
     * @property {RegExp} protocolRelativeRegex
     *
     * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes
     * of {@link #getAnchorText}. A protocol-relative URL is, for example, "//yahoo.com"
     */
				protocolRelativeRegex: /^\/\//,

				/**
     * @private
     * @property {Boolean} protocolPrepended
     *
     * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the
     * {@link #url} did not have a protocol)
     */
				protocolPrepended: false,

				/**
     * Returns a string name for the type of match that this class represents.
     *
     * @return {String}
     */
				getType: function getType() {
					return 'url';
				},

				/**
     * Returns a string name for the type of URL match that this class
     * represents.
     *
     * This helps to determine if the match was made in the original text with a
     * prefixed scheme (ex: 'http://www.google.com'), a prefixed 'www' (ex:
     * 'www.google.com'), or was matched by a known top-level domain (ex:
     * 'google.com').
     *
     * @return {"scheme"/"www"/"tld"}
     */
				getUrlMatchType: function getUrlMatchType() {
					return this.urlMatchType;
				},

				/**
     * Returns the url that was matched, assuming the protocol to be 'http://' if the original
     * match was missing a protocol.
     *
     * @return {String}
     */
				getUrl: function getUrl() {
					var url = this.url;

					// if the url string doesn't begin with a protocol, assume 'http://'
					if (!this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended) {
						url = this.url = 'http://' + url;

						this.protocolPrepended = true;
					}

					return url;
				},

				/**
     * Returns the anchor href that should be generated for the match.
     *
     * @return {String}
     */
				getAnchorHref: function getAnchorHref() {
					var url = this.getUrl();

					return url.replace(/&amp;/g, '&'); // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html
				},

				/**
     * Returns the anchor text that should be generated for the match.
     *
     * @return {String}
     */
				getAnchorText: function getAnchorText() {
					var anchorText = this.getMatchedText();

					if (this.protocolRelativeMatch) {
						// Strip off any protocol-relative '//' from the anchor text
						anchorText = this.stripProtocolRelativePrefix(anchorText);
					}
					if (this.stripPrefix.scheme) {
						anchorText = this.stripSchemePrefix(anchorText);
					}
					if (this.stripPrefix.www) {
						anchorText = this.stripWwwPrefix(anchorText);
					}
					if (this.stripTrailingSlash) {
						anchorText = this.removeTrailingSlash(anchorText); // remove trailing slash, if there is one
					}

					return anchorText;
				},

				// ---------------------------------------

				// Utility Functionality

				/**
     * Strips the scheme prefix (such as "http://" or "https://") from the given
     * `url`.
     *
     * @private
     * @param {String} url The text of the anchor that is being generated, for
     *   which to strip off the url scheme.
     * @return {String} The `url`, with the scheme stripped.
     */
				stripSchemePrefix: function stripSchemePrefix(url) {
					return url.replace(this.schemePrefixRegex, '');
				},

				/**
     * Strips the 'www' prefix from the given `url`.
     *
     * @private
     * @param {String} url The text of the anchor that is being generated, for
     *   which to strip off the 'www' if it exists.
     * @return {String} The `url`, with the 'www' stripped.
     */
				stripWwwPrefix: function stripWwwPrefix(url) {
					return url.replace(this.wwwPrefixRegex, '$1'); // leave any scheme ($1), it one exists
				},

				/**
     * Strips any protocol-relative '//' from the anchor text.
     *
     * @private
     * @param {String} text The text of the anchor that is being generated, for which to strip off the
     *   protocol-relative prefix (such as stripping off "//")
     * @return {String} The `anchorText`, with the protocol-relative prefix stripped.
     */
				stripProtocolRelativePrefix: function stripProtocolRelativePrefix(text) {
					return text.replace(this.protocolRelativeRegex, '');
				},

				/**
     * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.
     *
     * @private
     * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing
     *   slash ('/') that may exist.
     * @return {String} The `anchorText`, with the trailing slash removed.
     */
				removeTrailingSlash: function removeTrailingSlash(anchorText) {
					if (anchorText.charAt(anchorText.length - 1) === '/') {
						anchorText = anchorText.slice(0, -1);
					}
					return anchorText;
				}

			});
			/*global Autolinker */
			/**
    * @abstract
    * @class Autolinker.matcher.Matcher
    *
    * An abstract class and interface for individual matchers to find matches in
    * an input string with linkified versions of them.
    *
    * Note that Matchers do not take HTML into account - they must be fed the text
    * nodes of any HTML string, which is handled by {@link Autolinker#parse}.
    */
			Autolinker.matcher.Matcher = Autolinker.Util.extend(Object, {

				/**
     * @cfg {Autolinker.AnchorTagBuilder} tagBuilder (required)
     *
     * Reference to the AnchorTagBuilder instance to use to generate HTML tags
     * for {@link Autolinker.match.Match Matches}.
     */

				/**
     * @constructor
     * @param {Object} cfg The configuration properties for the Matcher
     *   instance, specified in an Object (map).
     */
				constructor: function constructor(cfg) {
					if (!cfg.tagBuilder) throw new Error('`tagBuilder` cfg required');

					this.tagBuilder = cfg.tagBuilder;
				},

				/**
     * Parses the input `text` and returns the array of {@link Autolinker.match.Match Matches}
     * for the matcher.
     *
     * @abstract
     * @param {String} text The text to scan and replace matches in.
     * @return {Autolinker.match.Match[]}
     */
				parseMatches: Autolinker.Util.abstractMethod

			});
			/*global Autolinker */
			/**
    * @class Autolinker.matcher.Email
    * @extends Autolinker.matcher.Matcher
    *
    * Matcher to find email matches in an input string.
    *
    * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.
    */
			Autolinker.matcher.Email = Autolinker.Util.extend(Autolinker.matcher.Matcher, {

				/**
     * The regular expression to match email addresses. Example match:
     *
     *     person@place.com
     *
     * @private
     * @property {RegExp} matcherRegex
     */
				matcherRegex: function () {
					var alphaNumericChars = Autolinker.RegexLib.alphaNumericCharsStr,
					    emailRegex = new RegExp('[' + alphaNumericChars + '\\-_\';:&=+$.,]+@'),
					    // something@ for email addresses (a.k.a. local-part)
					domainNameRegex = Autolinker.RegexLib.domainNameRegex,
					    tldRegex = Autolinker.RegexLib.tldRegex; // match our known top level domains (TLDs)

					return new RegExp([emailRegex.source, domainNameRegex.source, '\\.', tldRegex.source // '.com', '.net', etc
					].join(""), 'gi');
				}(),

				/**
     * @inheritdoc
     */
				parseMatches: function parseMatches(text) {
					var matcherRegex = this.matcherRegex,
					    tagBuilder = this.tagBuilder,
					    matches = [],
					    match;

					while ((match = matcherRegex.exec(text)) !== null) {
						var matchedText = match[0];

						matches.push(new Autolinker.match.Email({
							tagBuilder: tagBuilder,
							matchedText: matchedText,
							offset: match.index,
							email: matchedText
						}));
					}

					return matches;
				}

			});
			/*global Autolinker */
			/**
    * @class Autolinker.matcher.Hashtag
    * @extends Autolinker.matcher.Matcher
    *
    * Matcher to find Hashtag matches in an input string.
    */
			Autolinker.matcher.Hashtag = Autolinker.Util.extend(Autolinker.matcher.Matcher, {

				/**
     * @cfg {String} serviceName
     *
     * The service to point hashtag matches to. See {@link Autolinker#hashtag}
     * for available values.
     */

				/**
     * The regular expression to match Hashtags. Example match:
     *
     *     #asdf
     *
     * @private
     * @property {RegExp} matcherRegex
     */
				matcherRegex: new RegExp('#[_' + Autolinker.RegexLib.alphaNumericCharsStr + ']{1,139}', 'g'),

				/**
     * The regular expression to use to check the character before a username match to
     * make sure we didn't accidentally match an email address.
     *
     * For example, the string "asdf@asdf.com" should not match "@asdf" as a username.
     *
     * @private
     * @property {RegExp} nonWordCharRegex
     */
				nonWordCharRegex: new RegExp('[^' + Autolinker.RegexLib.alphaNumericCharsStr + ']'),

				/**
     * @constructor
     * @param {Object} cfg The configuration properties for the Match instance,
     *   specified in an Object (map).
     */
				constructor: function constructor(cfg) {
					Autolinker.matcher.Matcher.prototype.constructor.call(this, cfg);

					this.serviceName = cfg.serviceName;
				},

				/**
     * @inheritdoc
     */
				parseMatches: function parseMatches(text) {
					var matcherRegex = this.matcherRegex,
					    nonWordCharRegex = this.nonWordCharRegex,
					    serviceName = this.serviceName,
					    tagBuilder = this.tagBuilder,
					    matches = [],
					    match;

					while ((match = matcherRegex.exec(text)) !== null) {
						var offset = match.index,
						    prevChar = text.charAt(offset - 1);

						// If we found the match at the beginning of the string, or we found the match
						// and there is a whitespace char in front of it (meaning it is not a '#' char
						// in the middle of a word), then it is a hashtag match.
						if (offset === 0 || nonWordCharRegex.test(prevChar)) {
							var matchedText = match[0],
							    hashtag = match[0].slice(1); // strip off the '#' character at the beginning

							matches.push(new Autolinker.match.Hashtag({
								tagBuilder: tagBuilder,
								matchedText: matchedText,
								offset: offset,
								serviceName: serviceName,
								hashtag: hashtag
							}));
						}
					}

					return matches;
				}

			});
			/*global Autolinker */
			/**
    * @class Autolinker.matcher.Phone
    * @extends Autolinker.matcher.Matcher
    *
    * Matcher to find Phone number matches in an input string.
    *
    * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more
    * details.
    */
			Autolinker.matcher.Phone = Autolinker.Util.extend(Autolinker.matcher.Matcher, {

				/**
     * The regular expression to match Phone numbers. Example match:
     *
     *     (123) 456-7890
     *
     * This regular expression has the following capturing groups:
     *
     * 1. The prefixed '+' sign, if there is one.
     *
     * @private
     * @property {RegExp} matcherRegex
     */
				matcherRegex: /(?:(\+)?\d{1,3}[-\040.])?\(?\d{3}\)?[-\040.]?\d{3}[-\040.]\d{4}/g, // ex: (123) 456-7890, 123 456 7890, 123-456-7890, etc.

				/**
     * @inheritdoc
     */
				parseMatches: function parseMatches(text) {
					var matcherRegex = this.matcherRegex,
					    tagBuilder = this.tagBuilder,
					    matches = [],
					    match;

					while ((match = matcherRegex.exec(text)) !== null) {
						// Remove non-numeric values from phone number string
						var matchedText = match[0],
						    cleanNumber = matchedText.replace(/\D/g, ''),
						    // strip out non-digit characters
						plusSign = !!match[1]; // match[ 1 ] is the prefixed plus sign, if there is one

						matches.push(new Autolinker.match.Phone({
							tagBuilder: tagBuilder,
							matchedText: matchedText,
							offset: match.index,
							number: cleanNumber,
							plusSign: plusSign
						}));
					}

					return matches;
				}

			});
			/*global Autolinker */
			/**
    * @class Autolinker.matcher.Mention
    * @extends Autolinker.matcher.Matcher
    *
    * Matcher to find/replace username matches in an input string.
    */
			Autolinker.matcher.Mention = Autolinker.Util.extend(Autolinker.matcher.Matcher, {

				/**
     * Hash of regular expression to match username handles. Example match:
     *
     *     @asdf
     *
     * @private
     * @property {Object} matcherRegexes
     */
				matcherRegexes: {
					"twitter": new RegExp('@[_' + Autolinker.RegexLib.alphaNumericCharsStr + ']{1,20}', 'g'),
					"instagram": new RegExp('@[_.' + Autolinker.RegexLib.alphaNumericCharsStr + ']{1,50}', 'g')
				},

				/**
     * The regular expression to use to check the character before a username match to
     * make sure we didn't accidentally match an email address.
     *
     * For example, the string "asdf@asdf.com" should not match "@asdf" as a username.
     *
     * @private
     * @property {RegExp} nonWordCharRegex
     */
				nonWordCharRegex: new RegExp('[^' + Autolinker.RegexLib.alphaNumericCharsStr + ']'),

				/**
     * @constructor
     * @param {Object} cfg The configuration properties for the Match instance,
     *   specified in an Object (map).
     */
				constructor: function constructor(cfg) {
					Autolinker.matcher.Matcher.prototype.constructor.call(this, cfg);

					this.serviceName = cfg.serviceName;
				},

				/**
     * @inheritdoc
     */
				parseMatches: function parseMatches(text) {
					var matcherRegex = this.matcherRegexes[this.serviceName],
					    nonWordCharRegex = this.nonWordCharRegex,
					    serviceName = this.serviceName,
					    tagBuilder = this.tagBuilder,
					    matches = [],
					    match;

					if (!matcherRegex) {
						return matches;
					}

					while ((match = matcherRegex.exec(text)) !== null) {
						var offset = match.index,
						    prevChar = text.charAt(offset - 1);

						// If we found the match at the beginning of the string, or we found the match
						// and there is a whitespace char in front of it (meaning it is not an email
						// address), then it is a username match.
						if (offset === 0 || nonWordCharRegex.test(prevChar)) {
							var matchedText = match[0].replace(/\.+$/g, ''),
							    // strip off trailing .
							mention = matchedText.slice(1); // strip off the '@' character at the beginning

							matches.push(new Autolinker.match.Mention({
								tagBuilder: tagBuilder,
								matchedText: matchedText,
								offset: offset,
								serviceName: serviceName,
								mention: mention
							}));
						}
					}

					return matches;
				}

			});

			/*global Autolinker */
			/**
    * @class Autolinker.matcher.Url
    * @extends Autolinker.matcher.Matcher
    *
    * Matcher to find URL matches in an input string.
    *
    * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.
    */
			Autolinker.matcher.Url = Autolinker.Util.extend(Autolinker.matcher.Matcher, {

				/**
     * @cfg {Object} stripPrefix (required)
     *
     * The Object form of {@link Autolinker#cfg-stripPrefix}.
     */

				/**
     * @cfg {Boolean} stripTrailingSlash (required)
     * @inheritdoc Autolinker#stripTrailingSlash
     */

				/**
     * @private
     * @property {RegExp} matcherRegex
     *
     * The regular expression to match URLs with an optional scheme, port
     * number, path, query string, and hash anchor.
     *
     * Example matches:
     *
     *     http://google.com
     *     www.google.com
     *     google.com/path/to/file?q1=1&q2=2#myAnchor
     *
     *
     * This regular expression will have the following capturing groups:
     *
     * 1.  Group that matches a scheme-prefixed URL (i.e. 'http://google.com').
     *     This is used to match scheme URLs with just a single word, such as
     *     'http://localhost', where we won't double check that the domain name
     *     has at least one dot ('.') in it.
     * 2.  Group that matches a 'www.' prefixed URL. This is only matched if the
     *     'www.' text was not prefixed by a scheme (i.e.: not prefixed by
     *     'http://', 'ftp:', etc.)
     * 3.  A protocol-relative ('//') match for the case of a 'www.' prefixed
     *     URL. Will be an empty string if it is not a protocol-relative match.
     *     We need to know the character before the '//' in order to determine
     *     if it is a valid match or the // was in a string we don't want to
     *     auto-link.
     * 4.  Group that matches a known TLD (top level domain), when a scheme
     *     or 'www.'-prefixed domain is not matched.
     * 5.  A protocol-relative ('//') match for the case of a known TLD prefixed
     *     URL. Will be an empty string if it is not a protocol-relative match.
     *     See #3 for more info.
     */
				matcherRegex: function () {
					var schemeRegex = /(?:[A-Za-z][-.+A-Za-z0-9]*:(?![A-Za-z][-.+A-Za-z0-9]*:\/\/)(?!\d+\/?)(?:\/\/)?)/,
					    // match protocol, allow in format "http://" or "mailto:". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match "link:"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)
					wwwRegex = /(?:www\.)/,
					    // starting with 'www.'
					domainNameRegex = Autolinker.RegexLib.domainNameRegex,
					    tldRegex = Autolinker.RegexLib.tldRegex,
					    // match our known top level domains (TLDs)
					alphaNumericCharsStr = Autolinker.RegexLib.alphaNumericCharsStr,


					// Allow optional path, query string, and hash anchor, not ending in the following characters: "?!:,.;"
					// http://blog.codinghorror.com/the-problem-with-urls/
					urlSuffixRegex = new RegExp('[' + alphaNumericCharsStr + "\\-+&@#/%=~_()|'$*\\[\\]?!:,.;\u2713]*[" + alphaNumericCharsStr + "\\-+&@#/%=~_()|'$*\\[\\]\u2713]");

					return new RegExp(['(?:', // parens to cover match for scheme (optional), and domain
					'(', // *** Capturing group $1, for a scheme-prefixed url (ex: http://google.com)
					schemeRegex.source, domainNameRegex.source, ')', '|', '(', // *** Capturing group $2, for a 'www.' prefixed url (ex: www.google.com)
					'(//)?', // *** Capturing group $3 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character (handled later)
					wwwRegex.source, domainNameRegex.source, ')', '|', '(', // *** Capturing group $4, for known a TLD url (ex: google.com)
					'(//)?', // *** Capturing group $5 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character (handled later)
					domainNameRegex.source + '\\.', tldRegex.source, ')', ')', '(?:' + urlSuffixRegex.source + ')?' // match for path, query string, and/or hash anchor - optional
					].join(""), 'gi');
				}(),

				/**
     * A regular expression to use to check the character before a protocol-relative
     * URL match. We don't want to match a protocol-relative URL if it is part
     * of another word.
     *
     * For example, we want to match something like "Go to: //google.com",
     * but we don't want to match something like "abc//google.com"
     *
     * This regular expression is used to test the character before the '//'.
     *
     * @private
     * @type {RegExp} wordCharRegExp
     */
				wordCharRegExp: /\w/,

				/**
     * The regular expression to match opening parenthesis in a URL match.
     *
     * This is to determine if we have unbalanced parenthesis in the URL, and to
     * drop the final parenthesis that was matched if so.
     *
     * Ex: The text "(check out: wikipedia.com/something_(disambiguation))"
     * should only autolink the inner "wikipedia.com/something_(disambiguation)"
     * part, so if we find that we have unbalanced parenthesis, we will drop the
     * last one for the match.
     *
     * @private
     * @property {RegExp}
     */
				openParensRe: /\(/g,

				/**
     * The regular expression to match closing parenthesis in a URL match. See
     * {@link #openParensRe} for more information.
     *
     * @private
     * @property {RegExp}
     */
				closeParensRe: /\)/g,

				/**
     * @constructor
     * @param {Object} cfg The configuration properties for the Match instance,
     *   specified in an Object (map).
     */
				constructor: function constructor(cfg) {
					Autolinker.matcher.Matcher.prototype.constructor.call(this, cfg);

					if (cfg.stripPrefix == null) throw new Error('`stripPrefix` cfg required');
					if (cfg.stripTrailingSlash == null) throw new Error('`stripTrailingSlash` cfg required');

					this.stripPrefix = cfg.stripPrefix;
					this.stripTrailingSlash = cfg.stripTrailingSlash;
				},

				/**
     * @inheritdoc
     */
				parseMatches: function parseMatches(text) {
					var matcherRegex = this.matcherRegex,
					    stripPrefix = this.stripPrefix,
					    stripTrailingSlash = this.stripTrailingSlash,
					    tagBuilder = this.tagBuilder,
					    matches = [],
					    match;

					while ((match = matcherRegex.exec(text)) !== null) {
						var matchStr = match[0],
						    schemeUrlMatch = match[1],
						    wwwUrlMatch = match[2],
						    wwwProtocolRelativeMatch = match[3],

						//tldUrlMatch = match[ 4 ],  -- not needed at the moment
						tldProtocolRelativeMatch = match[5],
						    offset = match.index,
						    protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,
						    prevChar = text.charAt(offset - 1);

						if (!Autolinker.matcher.UrlMatchValidator.isValid(matchStr, schemeUrlMatch)) {
							continue;
						}

						// If the match is preceded by an '@' character, then it is either
						// an email address or a username. Skip these types of matches.
						if (offset > 0 && prevChar === '@') {
							continue;
						}

						// If it's a protocol-relative '//' match, but the character before the '//'
						// was a word character (i.e. a letter/number), then we found the '//' in the
						// middle of another word (such as "asdf//asdf.com"). In this case, skip the
						// match.
						if (offset > 0 && protocolRelativeMatch && this.wordCharRegExp.test(prevChar)) {
							continue;
						}

						// Handle a closing parenthesis at the end of the match, and exclude
						// it if there is not a matching open parenthesis in the match
						// itself.
						if (this.matchHasUnbalancedClosingParen(matchStr)) {
							matchStr = matchStr.substr(0, matchStr.length - 1); // remove the trailing ")"
						} else {
							// Handle an invalid character after the TLD
							var pos = this.matchHasInvalidCharAfterTld(matchStr, schemeUrlMatch);
							if (pos > -1) {
								matchStr = matchStr.substr(0, pos); // remove the trailing invalid chars
							}
						}

						var urlMatchType = schemeUrlMatch ? 'scheme' : wwwUrlMatch ? 'www' : 'tld',
						    protocolUrlMatch = !!schemeUrlMatch;

						matches.push(new Autolinker.match.Url({
							tagBuilder: tagBuilder,
							matchedText: matchStr,
							offset: offset,
							urlMatchType: urlMatchType,
							url: matchStr,
							protocolUrlMatch: protocolUrlMatch,
							protocolRelativeMatch: !!protocolRelativeMatch,
							stripPrefix: stripPrefix,
							stripTrailingSlash: stripTrailingSlash
						}));
					}

					return matches;
				},

				/**
     * Determines if a match found has an unmatched closing parenthesis. If so,
     * this parenthesis will be removed from the match itself, and appended
     * after the generated anchor tag.
     *
     * A match may have an extra closing parenthesis at the end of the match
     * because the regular expression must include parenthesis for URLs such as
     * "wikipedia.com/something_(disambiguation)", which should be auto-linked.
     *
     * However, an extra parenthesis *will* be included when the URL itself is
     * wrapped in parenthesis, such as in the case of "(wikipedia.com/something_(disambiguation))".
     * In this case, the last closing parenthesis should *not* be part of the
     * URL itself, and this method will return `true`.
     *
     * @private
     * @param {String} matchStr The full match string from the {@link #matcherRegex}.
     * @return {Boolean} `true` if there is an unbalanced closing parenthesis at
     *   the end of the `matchStr`, `false` otherwise.
     */
				matchHasUnbalancedClosingParen: function matchHasUnbalancedClosingParen(matchStr) {
					var lastChar = matchStr.charAt(matchStr.length - 1);

					if (lastChar === ')') {
						var openParensMatch = matchStr.match(this.openParensRe),
						    closeParensMatch = matchStr.match(this.closeParensRe),
						    numOpenParens = openParensMatch && openParensMatch.length || 0,
						    numCloseParens = closeParensMatch && closeParensMatch.length || 0;

						if (numOpenParens < numCloseParens) {
							return true;
						}
					}

					return false;
				},

				/**
     * Determine if there's an invalid character after the TLD in a URL. Valid
     * characters after TLD are ':/?#'. Exclude scheme matched URLs from this
     * check.
     *
     * @private
     * @param {String} urlMatch The matched URL, if there was one. Will be an
     *   empty string if the match is not a URL match.
     * @param {String} schemeUrlMatch The match URL string for a scheme
     *   match. Ex: 'http://yahoo.com'. This is used to match something like
     *   'http://localhost', where we won't double check that the domain name
     *   has at least one '.' in it.
     * @return {Number} the position where the invalid character was found. If
     *   no such character was found, returns -1
     */
				matchHasInvalidCharAfterTld: function matchHasInvalidCharAfterTld(urlMatch, schemeUrlMatch) {
					if (!urlMatch) {
						return -1;
					}

					var offset = 0;
					if (schemeUrlMatch) {
						offset = urlMatch.indexOf(':');
						urlMatch = urlMatch.slice(offset);
					}

					var re = /^((.?\/\/)?[A-Za-z0-9\u00C0-\u017F\.\-]*[A-Za-z0-9\u00C0-\u017F\-]\.[A-Za-z]+)/;
					var res = re.exec(urlMatch);
					if (res === null) {
						return -1;
					}

					offset += res[1].length;
					urlMatch = urlMatch.slice(res[1].length);
					if (/^[^.A-Za-z:\/?#]/.test(urlMatch)) {
						return offset;
					}

					return -1;
				}

			});
			/*global Autolinker */
			/*jshint scripturl:true */
			/**
    * @private
    * @class Autolinker.matcher.UrlMatchValidator
    * @singleton
    *
    * Used by Autolinker to filter out false URL positives from the
    * {@link Autolinker.matcher.Url UrlMatcher}.
    *
    * Due to the limitations of regular expressions (including the missing feature
    * of look-behinds in JS regular expressions), we cannot always determine the
    * validity of a given match. This class applies a bit of additional logic to
    * filter out any false positives that have been matched by the
    * {@link Autolinker.matcher.Url UrlMatcher}.
    */
			Autolinker.matcher.UrlMatchValidator = {

				/**
     * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'
     *
     * @private
     * @property {RegExp} hasFullProtocolRegex
     */
				hasFullProtocolRegex: /^[A-Za-z][-.+A-Za-z0-9]*:\/\//,

				/**
     * Regex to find the URI scheme, such as 'mailto:'.
     *
     * This is used to filter out 'javascript:' and 'vbscript:' schemes.
     *
     * @private
     * @property {RegExp} uriSchemeRegex
     */
				uriSchemeRegex: /^[A-Za-z][-.+A-Za-z0-9]*:/,

				/**
     * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')
     *
     * @private
     * @property {RegExp} hasWordCharAfterProtocolRegex
     */
				hasWordCharAfterProtocolRegex: /:[^\s]*?[A-Za-z\u00C0-\u017F]/,

				/**
     * Regex to determine if the string is a valid IP address
     *
     * @private
     * @property {RegExp} ipRegex
     */
				ipRegex: /[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?(:[0-9]*)?\/?$/,

				/**
     * Determines if a given URL match found by the {@link Autolinker.matcher.Url UrlMatcher}
     * is valid. Will return `false` for:
     *
     * 1) URL matches which do not have at least have one period ('.') in the
     *    domain name (effectively skipping over matches like "abc:def").
     *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')
     * 2) URL matches which do not have at least one word character in the
     *    domain name (effectively skipping over matches like "git:1.0").
     * 3) A protocol-relative url match (a URL beginning with '//') whose
     *    previous character is a word character (effectively skipping over
     *    strings like "abc//google.com")
     *
     * Otherwise, returns `true`.
     *
     * @param {String} urlMatch The matched URL, if there was one. Will be an
     *   empty string if the match is not a URL match.
     * @param {String} protocolUrlMatch The match URL string for a protocol
     *   match. Ex: 'http://yahoo.com'. This is used to match something like
     *   'http://localhost', where we won't double check that the domain name
     *   has at least one '.' in it.
     * @return {Boolean} `true` if the match given is valid and should be
     *   processed, or `false` if the match is invalid and/or should just not be
     *   processed.
     */
				isValid: function isValid(urlMatch, protocolUrlMatch) {
					if (protocolUrlMatch && !this.isValidUriScheme(protocolUrlMatch) || this.urlMatchDoesNotHaveProtocolOrDot(urlMatch, protocolUrlMatch) || // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')
					this.urlMatchDoesNotHaveAtLeastOneWordChar(urlMatch, protocolUrlMatch) && // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like "git:1.0"
					!this.isValidIpAddress(urlMatch) // Except if it's an IP address
					) {
						return false;
					}

					return true;
				},

				isValidIpAddress: function isValidIpAddress(uriSchemeMatch) {
					var newRegex = new RegExp(this.hasFullProtocolRegex.source + this.ipRegex.source);
					var uriScheme = uriSchemeMatch.match(newRegex);

					return uriScheme !== null;
				},

				/**
     * Determines if the URI scheme is a valid scheme to be autolinked. Returns
     * `false` if the scheme is 'javascript:' or 'vbscript:'
     *
     * @private
     * @param {String} uriSchemeMatch The match URL string for a full URI scheme
     *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.
     * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.
     */
				isValidUriScheme: function isValidUriScheme(uriSchemeMatch) {
					var uriScheme = uriSchemeMatch.match(this.uriSchemeRegex)[0].toLowerCase();

					return uriScheme !== 'javascript:' && uriScheme !== 'vbscript:';
				},

				/**
     * Determines if a URL match does not have either:
     *
     * a) a full protocol (i.e. 'http://'), or
     * b) at least one dot ('.') in the domain name (for a non-full-protocol
     *    match).
     *
     * Either situation is considered an invalid URL (ex: 'git:d' does not have
     * either the '://' part, or at least one dot in the domain name. If the
     * match was 'git:abc.com', we would consider this valid.)
     *
     * @private
     * @param {String} urlMatch The matched URL, if there was one. Will be an
     *   empty string if the match is not a URL match.
     * @param {String} protocolUrlMatch The match URL string for a protocol
     *   match. Ex: 'http://yahoo.com'. This is used to match something like
     *   'http://localhost', where we won't double check that the domain name
     *   has at least one '.' in it.
     * @return {Boolean} `true` if the URL match does not have a full protocol,
     *   or at least one dot ('.') in a non-full-protocol match.
     */
				urlMatchDoesNotHaveProtocolOrDot: function urlMatchDoesNotHaveProtocolOrDot(urlMatch, protocolUrlMatch) {
					return !!urlMatch && (!protocolUrlMatch || !this.hasFullProtocolRegex.test(protocolUrlMatch)) && urlMatch.indexOf('.') === -1;
				},

				/**
     * Determines if a URL match does not have at least one word character after
     * the protocol (i.e. in the domain name).
     *
     * At least one letter character must exist in the domain name after a
     * protocol match. Ex: skip over something like "git:1.0"
     *
     * @private
     * @param {String} urlMatch The matched URL, if there was one. Will be an
     *   empty string if the match is not a URL match.
     * @param {String} protocolUrlMatch The match URL string for a protocol
     *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we
     *   have a protocol in the URL string, in order to check for a word
     *   character after the protocol separator (':').
     * @return {Boolean} `true` if the URL match does not have at least one word
     *   character in it after the protocol, `false` otherwise.
     */
				urlMatchDoesNotHaveAtLeastOneWordChar: function urlMatchDoesNotHaveAtLeastOneWordChar(urlMatch, protocolUrlMatch) {
					if (urlMatch && protocolUrlMatch) {
						return !this.hasWordCharAfterProtocolRegex.test(urlMatch);
					} else {
						return false;
					}
				}

			};
			/*global Autolinker */
			/**
    * A truncation feature where the ellipsis will be placed at the end of the URL.
    *
    * @param {String} anchorText
    * @param {Number} truncateLen The maximum length of the truncated output URL string.
    * @param {String} ellipsisChars The characters to place within the url, e.g. "..".
    * @return {String} The truncated URL.
    */
			Autolinker.truncate.TruncateEnd = function (anchorText, truncateLen, ellipsisChars) {
				return Autolinker.Util.ellipsis(anchorText, truncateLen, ellipsisChars);
			};

			/*global Autolinker */
			/**
    * Date: 2015-10-05
    * Author: Kasper Sfren <soefritz@gmail.com> (https://github.com/kafoso)
    *
    * A truncation feature, where the ellipsis will be placed in the dead-center of the URL.
    *
    * @param {String} url             A URL.
    * @param {Number} truncateLen     The maximum length of the truncated output URL string.
    * @param {String} ellipsisChars   The characters to place within the url, e.g. "..".
    * @return {String} The truncated URL.
    */
			Autolinker.truncate.TruncateMiddle = function (url, truncateLen, ellipsisChars) {
				if (url.length <= truncateLen) {
					return url;
				}
				var availableLength = truncateLen - ellipsisChars.length;
				var end = "";
				if (availableLength > 0) {
					end = url.substr(-1 * Math.floor(availableLength / 2));
				}
				return (url.substr(0, Math.ceil(availableLength / 2)) + ellipsisChars + end).substr(0, truncateLen);
			};

			/*global Autolinker */
			/**
    * Date: 2015-10-05
    * Author: Kasper Sfren <soefritz@gmail.com> (https://github.com/kafoso)
    *
    * A truncation feature, where the ellipsis will be placed at a section within
    * the URL making it still somewhat human readable.
    *
    * @param {String} url						 A URL.
    * @param {Number} truncateLen		 The maximum length of the truncated output URL string.
    * @param {String} ellipsisChars	 The characters to place within the url, e.g. "..".
    * @return {String} The truncated URL.
    */
			Autolinker.truncate.TruncateSmart = function (url, truncateLen, ellipsisChars) {
				var parse_url = function parse_url(url) {
					// Functionality inspired by PHP function of same name
					var urlObj = {};
					var urlSub = url;
					var match = urlSub.match(/^([a-z]+):\/\//i);
					if (match) {
						urlObj.scheme = match[1];
						urlSub = urlSub.substr(match[0].length);
					}
					match = urlSub.match(/^(.*?)(?=(\?|#|\/|$))/i);
					if (match) {
						urlObj.host = match[1];
						urlSub = urlSub.substr(match[0].length);
					}
					match = urlSub.match(/^\/(.*?)(?=(\?|#|$))/i);
					if (match) {
						urlObj.path = match[1];
						urlSub = urlSub.substr(match[0].length);
					}
					match = urlSub.match(/^\?(.*?)(?=(#|$))/i);
					if (match) {
						urlObj.query = match[1];
						urlSub = urlSub.substr(match[0].length);
					}
					match = urlSub.match(/^#(.*?)$/i);
					if (match) {
						urlObj.fragment = match[1];
						//urlSub = urlSub.substr(match[0].length);  -- not used. Uncomment if adding another block.
					}
					return urlObj;
				};

				var buildUrl = function buildUrl(urlObj) {
					var url = "";
					if (urlObj.scheme && urlObj.host) {
						url += urlObj.scheme + "://";
					}
					if (urlObj.host) {
						url += urlObj.host;
					}
					if (urlObj.path) {
						url += "/" + urlObj.path;
					}
					if (urlObj.query) {
						url += "?" + urlObj.query;
					}
					if (urlObj.fragment) {
						url += "#" + urlObj.fragment;
					}
					return url;
				};

				var buildSegment = function buildSegment(segment, remainingAvailableLength) {
					var remainingAvailableLengthHalf = remainingAvailableLength / 2,
					    startOffset = Math.ceil(remainingAvailableLengthHalf),
					    endOffset = -1 * Math.floor(remainingAvailableLengthHalf),
					    end = "";
					if (endOffset < 0) {
						end = segment.substr(endOffset);
					}
					return segment.substr(0, startOffset) + ellipsisChars + end;
				};
				if (url.length <= truncateLen) {
					return url;
				}
				var availableLength = truncateLen - ellipsisChars.length;
				var urlObj = parse_url(url);
				// Clean up the URL
				if (urlObj.query) {
					var matchQuery = urlObj.query.match(/^(.*?)(?=(\?|\#))(.*?)$/i);
					if (matchQuery) {
						// Malformed URL; two or more "?". Removed any content behind the 2nd.
						urlObj.query = urlObj.query.substr(0, matchQuery[1].length);
						url = buildUrl(urlObj);
					}
				}
				if (url.length <= truncateLen) {
					return url;
				}
				if (urlObj.host) {
					urlObj.host = urlObj.host.replace(/^www\./, "");
					url = buildUrl(urlObj);
				}
				if (url.length <= truncateLen) {
					return url;
				}
				// Process and build the URL
				var str = "";
				if (urlObj.host) {
					str += urlObj.host;
				}
				if (str.length >= availableLength) {
					if (urlObj.host.length == truncateLen) {
						return (urlObj.host.substr(0, truncateLen - ellipsisChars.length) + ellipsisChars).substr(0, truncateLen);
					}
					return buildSegment(str, availableLength).substr(0, truncateLen);
				}
				var pathAndQuery = "";
				if (urlObj.path) {
					pathAndQuery += "/" + urlObj.path;
				}
				if (urlObj.query) {
					pathAndQuery += "?" + urlObj.query;
				}
				if (pathAndQuery) {
					if ((str + pathAndQuery).length >= availableLength) {
						if ((str + pathAndQuery).length == truncateLen) {
							return (str + pathAndQuery).substr(0, truncateLen);
						}
						var remainingAvailableLength = availableLength - str.length;
						return (str + buildSegment(pathAndQuery, remainingAvailableLength)).substr(0, truncateLen);
					} else {
						str += pathAndQuery;
					}
				}
				if (urlObj.fragment) {
					var fragment = "#" + urlObj.fragment;
					if ((str + fragment).length >= availableLength) {
						if ((str + fragment).length == truncateLen) {
							return (str + fragment).substr(0, truncateLen);
						}
						var remainingAvailableLength2 = availableLength - str.length;
						return (str + buildSegment(fragment, remainingAvailableLength2)).substr(0, truncateLen);
					} else {
						str += fragment;
					}
				}
				if (urlObj.scheme && urlObj.host) {
					var scheme = urlObj.scheme + "://";
					if ((str + scheme).length < availableLength) {
						return (scheme + str).substr(0, truncateLen);
					}
				}
				if (str.length <= truncateLen) {
					return str;
				}
				var end = "";
				if (availableLength > 0) {
					end = str.substr(-1 * Math.floor(availableLength / 2));
				}
				return (str.substr(0, Math.ceil(availableLength / 2)) + ellipsisChars + end).substr(0, truncateLen);
			};

			return Autolinker;
		});
	}, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * primaryEmail takes the given email addresses and returns the email address
         * marked as 'Primary'.
         * If none exists it returns the first active email address.
         *
         * @param emailAddresses {Array}: Array containing the email addresses.
         *
         * @returns email_address {String}: The primary email address.
         */
        angular.module('app.filters').filter('primaryEmail', primaryEmail);

        primaryEmail.$inject = ['$filter'];
        function primaryEmail($filter) {
            return function (emailAddresses) {
                var primaryEmailAddress = '';
                var filteredEmailAddresses = $filter('filter')(emailAddresses, { status: '!' + 0 });

                if (filteredEmailAddresses && filteredEmailAddresses.length) {
                    primaryEmailAddress = $filter('filter')(filteredEmailAddresses, { status: 2 })[0];

                    if (!primaryEmailAddress) {
                        // No primary email set, so just get the first active email address.
                        primaryEmailAddress = filteredEmailAddresses[0];
                    }

                    primaryEmailAddress = primaryEmailAddress.email_address;
                }

                return primaryEmailAddress;
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * stripScheme strips the scheme of the given URL (e.g. http://).
         *
         * @param url {string}: String containing the URL
         *
         * @returns: string: The stripped URL
         */
        angular.module('app.filters').filter('stripScheme', stripScheme);

        stripScheme.$inject = [];
        function stripScheme() {
            return function (url) {
                return url.replace(/http(s)?:\/\//, '');
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.filters').filter('trustAsResourceUrl', trustAsResourceUrl);

        trustAsResourceUrl.$inject = ['$sce'];
        function trustAsResourceUrl($sce) {
            return function (val) {
                return $sce.trustAsResourceUrl(val);
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').factory('AppHash', AppHash);

        AppHash.$inject = ['$resource', 'HLCache', 'CacheFactory'];
        function AppHash($resource, HLCache, CacheFactory) {
            return $resource('/api/utils/apphash/', null, {
                get: {
                    cache: CacheFactory.get('dataCache')
                }
            });
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').factory('Country', Country);

        Country.$inject = ['$q', 'Account'];
        function Country($q, Account) {
            var list = [];
            var _country = {};

            _country.getList = getList;

            activate();

            ////

            function activate() {
                getList();
            }

            function getList() {
                var deferred = $q.defer();
                if (list.length) {
                    deferred.resolve(list);
                } else {
                    // Fetch the country choices from Address model
                    Account.addressOptions(function (data) {
                        list = data.actions.POST.country.choices;
                        deferred.resolve(list);
                    });
                }

                return deferred.promise;
            }

            return _country;
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * HLCache Service provides a way to re-use one cache for different APIs.
         */

        angular.module('app.services').service('HLCache', HLCache);

        HLCache.$inject = ['CacheFactory'];
        function HLCache(CacheFactory) {
            // Create the cache.
            new CacheFactory('dataCache', {
                // Items added to this cache expire after 5 minutes.
                maxAge: 5 * 60 * 1000,
                // Expired items will remain in the cache until requested, at which point they are removed.
                deleteOnExpire: 'passive'
            });

            new CacheFactory('userCache', {
                // Items added to this cache expire after 5 minutes.
                maxAge: 5 * 60 * 1000,
                // Expired items will remain in the cache until requested, at which point they are removed.
                deleteOnExpire: 'passive'
            });
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').service('HLFields', HLFields);

        function HLFields() {
            /**
             * cleanRelatedFields() cleans the related fields of the given objects.
             * For now it only removes fields that have the is_deleted flag set to true.
             *
             * @param object (object): the object to clean.
             *
             * @returns (object): returns the object with the related fields cleaned.
             */
            this.cleanRelatedFields = function (object) {
                var relatedFields = ['email_addresses', 'phone_numbers', 'websites', 'addresses'];

                angular.forEach(object, function (fieldValues, field) {
                    var cleanedValues = [];

                    // We only want to clean the related fields, so check if the field is a related field.
                    if (relatedFields.indexOf(field) > -1) {
                        // Loop through each array element.
                        angular.forEach(fieldValues, function (fieldValue) {
                            if (!fieldValue.hasOwnProperty('is_deleted')) {
                                if (fieldValue.email_address) {
                                    cleanedValues.push(fieldValue);
                                }

                                if (fieldValue.number) {
                                    cleanedValues.push(fieldValue);
                                }

                                if (fieldValue.address && (fieldValue.city || fieldValue.postal_code)) {
                                    cleanedValues.push(fieldValue);
                                }

                                if (fieldValue.website) {
                                    if (!fieldValue.is_primary || fieldValue.is_primary && object.primaryWebsite) {
                                        if (fieldValue.website !== object.primaryWebsite) {
                                            fieldValue.is_primary = false;
                                        }

                                        cleanedValues.push(fieldValue);
                                    }
                                }
                            }
                        });

                        object[field] = cleanedValues;
                    }
                });

                return object;
            };

            this.cleanInlineRelatedFields = function (items) {
                var cleanedValues = [];

                angular.forEach(items, function (item) {
                    if (item.email_address || item.number || item.address && (item.city || item.postal_code) || item.website) {
                        if (item.id || !item.hasOwnProperty('is_deleted')) {
                            cleanedValues.push(item);
                        }
                    }
                });

                return cleanedValues;
            };

            this.addRelatedField = function (object, field) {
                // Default status is 'Other'.
                var status = 1;
                var isPrimary = false;

                switch (field) {
                    case 'emailAddress':
                        if (object.email_addresses.length === 0) {
                            // No email addresses added yet, so first one is primary.
                            status = 2;
                            isPrimary = true;
                        }

                        object.email_addresses.push({ is_primary: isPrimary, status: status });
                        break;
                    case 'phoneNumber':
                        object.phone_numbers.push({ type: 'work' });
                        break;
                    case 'address':
                        object.addresses.push({ type: 'visiting' });
                        break;
                    case 'website':
                        object.websites.push({ website: '', is_primary: false });
                        break;
                    default:
                        break;
                }
            };

            this.removeRelatedField = function (object, field, index, remove) {
                switch (field) {
                    case 'emailAddress':
                        object.email_addresses[index].is_deleted = remove;
                        break;
                    case 'phoneNumber':
                        object.phone_numbers[index].is_deleted = remove;
                        break;
                    case 'address':
                        object.addresses[index].is_deleted = remove;
                        break;
                    case 'website':
                        object.websites[index].is_deleted = remove;
                        break;
                    default:
                        break;
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').service('HLFilters', HLFilters);

        function HLFilters() {
            this.updateFilterQuery = function (viewModel, hasClearButtons) {
                // Update the filter based on the separate filters.
                var filterStrings = [];
                var specialFilterStrings = [];
                var filterList = viewModel.filterList;

                viewModel.table.filterQuery = '';

                if (hasClearButtons) {
                    this._displayClearButtons(viewModel);
                }

                if (viewModel.filterSpecialList) {
                    filterList = filterList.concat(viewModel.filterSpecialList);
                }

                filterList.forEach(function (filter) {
                    if (filter.id && filter.id === 'is_archived') {
                        if (!filter.selected) {
                            filterStrings.push('is_archived:false');
                        }
                    } else {
                        if (filter.selected) {
                            if (filter.isSpecialFilter) {
                                specialFilterStrings.push(filter.value);
                            } else {
                                filterStrings.push(filter.value);
                            }
                        }
                    }
                });

                if (viewModel.table.dueDateFilter) {
                    filterStrings.push(viewModel.table.dueDateFilter);
                }

                // If we have type filter, we join them OR-wise.
                if (specialFilterStrings.length > 0) {
                    filterStrings.push('(' + specialFilterStrings.join(' OR ') + ')');
                }

                if (viewModel.table.usersFilter) {
                    filterStrings.push('(' + viewModel.table.usersFilter + ')');
                }

                // Finally join all filters AND-wise.
                viewModel.table.filterQuery = filterStrings.join(' AND ');
            };

            this._displayClearButtons = function (viewModel) {
                viewModel.displayFilterClear = false;
                viewModel.displaySpecialFilterClear = false;

                viewModel.filterList.forEach(function (filter) {
                    if (filter.selected) {
                        viewModel.displayFilterClear = true;
                    }
                });

                if (viewModel.filterSpecialList) {
                    viewModel.filterSpecialList.forEach(function (filter) {
                        if (filter.selected) {
                            viewModel.displaySpecialFilterClear = true;
                        }
                    });
                }
            };

            this.clearFilters = function (viewModel, clearSpecial) {
                if (clearSpecial) {
                    viewModel.filterSpecialList.forEach(function (filter) {
                        filter.selected = false;
                    });
                } else {
                    viewModel.filterList.forEach(function (filter) {
                        filter.selected = false;
                    });
                }

                viewModel.updateFilterQuery();
            };

            this.getStoredSelections = function (filterList, storedFilterList) {
                if (storedFilterList) {
                    // Stored filter list exists, merge the selections from with the stored values.
                    angular.forEach(storedFilterList, function (storedFilter) {
                        angular.forEach(filterList, function (filter) {
                            if (storedFilter.name === filter.name) {
                                filter.selected = storedFilter.selected;
                            }
                        });
                    });
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').service('HLForms', HLForms);

        HLForms.$inject = ['$timeout'];
        function HLForms($timeout) {
            /**
             * setErrors() sets the errors of the forms, making use of Angular's error handling.
             *
             * @param form (object): the form on which the errors are set
             * @param data (object): object containing all the errors
             *
             */
            this.setErrors = function (form, data) {
                var field;
                var i;
                var key;
                var formField;

                // Unblock the UI so user can retry filling in the form.
                Metronic.unblockUI();

                // We don't want to continue if the returned errors aren't properly formatted.
                if ((typeof data === "undefined" ? "undefined" : _typeof(data)) === 'object') {
                    for (field in data) {
                        // Errors are always in the <field>: Array format, so iterate over the array.
                        for (i = 0; i < data[field].length; i++) {
                            // Related fields are always an object, so check for that.
                            if (_typeof(data[field][i]) === 'object') {
                                for (key in data[field][i]) {
                                    formField = [field, key, i].join('-');

                                    // The error is always the first element, so get it and set as the error message.
                                    form[formField].$error = { message: data[field][i][key][0] };
                                    form[formField].$setValidity(formField, false);
                                }
                            } else {
                                // Not a related field, so get the error and set validity to false.
                                form[field].$error = { message: data[field][0] };
                                form[field].$setValidity(field, false);
                            }
                        }
                    }

                    $timeout(function () {
                        angular.element('.form-control.ng-invalid:first').focus();
                    });
                }
            };

            /**
             * Clear all errors of the form (in case of new errors).
             * @param form (object): The form from which the errors should be cleared.
             */
            this.clearErrors = function (form) {
                angular.forEach(form, function (value, key) {
                    if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' && value.hasOwnProperty('$modelValue')) {
                        form[key].$error = {};
                        form[key].$setValidity(key, true);
                    }
                });
            };

            /**
             * Clean the fields of the given view model.
             * @param viewModel (object): The view model that's being created/updated.
             */
            this.clean = function (viewModel) {
                // We don't want to clean certain fields.
                var ignoredFields = ['tags'];
                var ids = [];

                angular.forEach(viewModel, function (fieldValue, field) {
                    if (ignoredFields.indexOf(field) < 0 && fieldValue) {
                        // We don't want to send whole objects to the API, because they're not accepted.
                        // So loop through all fields and extract IDs.
                        if (fieldValue.constructor === Array) {
                            angular.forEach(fieldValue, function (item) {
                                if ((typeof item === "undefined" ? "undefined" : _typeof(item)) === 'object') {
                                    if (item.hasOwnProperty('id')) {
                                        ids.push(item.id);
                                    }
                                } else if (typeof item === 'number') {
                                    // Seems to be an ID, so just add it to the ID array.
                                    ids.push(item);
                                }
                            });

                            viewModel[field] = ids;
                        } else if ((typeof fieldValue === "undefined" ? "undefined" : _typeof(fieldValue)) === 'object') {
                            if (fieldValue.hasOwnProperty('id')) {
                                viewModel[field] = fieldValue.id;
                            } else if (fieldValue.hasOwnProperty('value')) {
                                viewModel[field] = fieldValue.value;
                            }
                        }
                    }
                });

                return viewModel;
            };

            /**
             * Block the UI, giving the user feedback about the form.
             */
            this.blockUI = function () {
                // animate shows a CSS animation instead of the standard 'Loading' text.
                Metronic.blockUI({ animate: true });
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').service('HLGravatar', HLGravatar);

        function HLGravatar() {
            this.getGravatar = function (email) {
                var trimmedEmail = email.trim();
                var lowerCasedEmail = trimmedEmail.toLowerCase();
                var gravatarHash = md5(lowerCasedEmail);

                return 'https://secure.gravatar.com/avatar/' + gravatarHash + '?s=200&d=mm';
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').factory('HLMessages', HLMessages);

        HLMessages.$inject = [];
        function HLMessages() {
            var mod = 'CTRL';
            if (navigator.userAgent.indexOf('Mac OS X') !== -1) {
                mod = '';
            }

            return {
                contact: {
                    accountInfoTooltip: 'I\'ve loaded the selected account\'s data for you. Now you don\'t have to enter duplicate data!',
                    accountListInfoTooltip: 'This is the data of the account(s) the contact works for',
                    contactInfoTooltip: 'This is the current contact\'s data'
                },
                alerts: {
                    accountForm: {
                        title: 'Website already exists',
                        body: 'This website has already been added to an existing account: <br />' + '<strong>%(account)s</strong><br />' + 'Are you sure you want to use:<br />' + '%(website)s',
                        cancelButtonText: 'No, clear the field'
                    },
                    delete: {
                        confirmTitle: 'Are you sure?',
                        confirmText: 'You are about to delete <strong>%(name)s</strong>.<br />You won\'t be able to revert this!',
                        confirmButtonText: 'Yes, delete it!',
                        successTitle: 'Deleted',
                        successText: 'The %(model)s <strong>%(name)s</strong> has been deleted.',
                        errorTitle: 'Error',
                        errorText: 'There was an error processing your request.<br />Please try again.'
                    },
                    assignTo: {
                        title: 'Assign this %(type)s',
                        questionText: 'Assign this %(type)s to yourself?'
                    },
                    deactivateUser: {
                        confirmText: 'Are you sure you want to deactivate <strong>%(name)s</strong>',
                        confirmButtonText: 'Yes, deactivate',
                        successTitle: 'Deactivated!',
                        successText: '<strong>%(name)s</strong> has been deactivated.'
                    },
                    postpone: {
                        dealTitle: 'Change next step date',
                        caseTitle: 'Change expiry date',
                        deal: 'Wrong day to solve it?<br />Set to today or postpone it.',
                        case: 'Not the right day to act upon it?<br />Set to today or postpone it.',
                        datepicker: 'Or manually select a date:'
                    },
                    dashboard: {
                        title: 'Widget settings'
                    },
                    deals: {
                        title: 'Why lost?'
                    },
                    email: {
                        sendCheckerTitle: 'No recipient',
                        sendCheckerText: 'I couldn\'t find a recipient, could you please fill in where I need to send this mail.',
                        overwriteTemplateConfirm: 'Selecting a different template will reload the template. This will put your typed text at the bottom of the email. Do you want to load the template anyway?',
                        reloadTemplateConfirm: 'Do you want to reload the template? This will load the template variables, but will put your text at the bottom of the email.'
                    },
                    preferences: {
                        userAssignTitle: 'Assign %(user)s to teams',
                        shareAccountTitle: 'Yes, let me share this email account'
                    }
                },
                tooltips: {
                    modEnter: {
                        title: mod + '+Enter'
                    },
                    newlyAssignedCase: 'Add it to \'My cases\'',
                    newlyAssignedDeal: 'Add it to \'My deals\''
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').service('HLNotifications', HLNotifications);

        HLNotifications.$inject = ['$state', 'LocalStorage', 'HLSockets'];
        function HLNotifications($state, LocalStorage, HLSockets) {
            var sendNotification = false;

            _notificationWindowCheck();

            HLSockets.bind('notification', function (data) {
                _notificationWindowCheck();
                if (sendNotification && 'Notification' in window) {
                    if (Notification.permission === 'granted') {
                        _makeNotification(data);
                    } else if (Notification.permission !== 'denied') {
                        // If the user has not already accepted or denied notifications
                        // permission will be asked to send the notification.
                        Notification.requestPermission(function (permission) {
                            if (permission === 'granted') {
                                _makeNotification(data);
                            } else if (permission === 'denied') {
                                // Close the WebSocket connection as it serves no purpose anymore.
                                HLSockets.close('Notification access denied');
                            }
                        });
                    }
                }
            });

            function _makeNotification(data) {
                var notification = void 0;
                // If there is no name available, use the phone number in the title of the notification
                if (data.params.name !== '') {
                    notification = new Notification(data.params.name + ' calling', { body: data.params.number, icon: data.icon });
                } else {
                    notification = new Notification(data.params.number + ' calling', { body: '', icon: data.icon });
                }
                setTimeout(function () {
                    notification.close();
                }, 5000);
                ga('send', 'event', 'Caller info', 'Answer', 'Incoming call');
                notification.onclick = function () {
                    switch (data.destination) {
                        case 'account':
                            window.open($state.href('base.accounts.detail', { id: data.params.id }), '_blank');
                            break;
                        case 'contact':
                            window.open($state.href('base.contacts.detail', { id: data.params.id }), '_blank');
                            break;
                        case 'create':
                            // There is no way to know if an account or contact needs to be created. As it's more
                            // likely an account needs to be created, this links to account.create.
                            window.open($state.href('base.accounts.create', {
                                name: data.params.name,
                                phone_number: data.params.number
                            }), '_blank');
                            break;
                        default:
                            break;
                    }
                    notification.close();
                    ga('send', 'event', 'Caller info', 'Open', 'Popup');
                };
            }

            function _notificationWindowCheck() {
                // This function makes sure notifications are only shown once if
                // Lily is open in multiple windows/tabs.
                var storage = new LocalStorage('notificationWindow');
                var dateNow = new Date();
                var timestamp = storage.getObjectValue('timestamp', false);
                if (!timestamp || timestamp < dateNow.getTime() - 4000) {
                    // The window sending the notifications will write a timestamp to localstorage
                    // every second. When a notification is received and the timestamp is
                    // older than 2 seconds, another window will take over.
                    storage.putObjectValue('timestamp', dateNow.getTime());
                    sendNotification = true;
                    setInterval(function () {
                        dateNow = new Date();
                        storage.putObjectValue('timestamp', dateNow.getTime());
                    }, 1000);
                }
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').service('HLResource', HLResource);

        HLResource.$inject = ['$injector'];
        function HLResource($injector) {
            this.patch = function (model, args) {
                return $injector.get(model).patch(args, function () {
                    toastr.success('I\'ve updated the ' + model.toLowerCase() + ' for you!', 'Done');
                }, function () {
                    toastr.error('Something went wrong while saving the field, please try again.', 'Oops!');
                    // For now return an empty string, we'll implement proper errors later.
                    return '';
                });
            };

            this.delete = function (model, object) {
                return $injector.get(model).delete({ id: object.id }).$promise.then(function () {
                    toastr.success('I\'ve deleted the ' + model.toLowerCase() + ' for you!', 'Done');
                });
            };

            /**
             * Gets the options for the given field which can be used for selects.
             * @param model {string}: The model that's loaded.
             * @param field {string}: The field for which the values will be retrieved.
             *
             * @returns: values {Array}: The retrieved values.
             */
            this.getChoicesForField = function (model, field) {
                // Dynamically get resource.
                var resource = $injector.get(model);
                var convertedField = _convertVariableName(field);
                var key;
                var choices;

                if (!resource.hasOwnProperty(convertedField)) {
                    // Resource doesn't contain the given field.
                    // So the field is probably a plural version of the given field or whatever.
                    for (key in resource) {
                        if (key.indexOf(convertedField) > -1) {
                            choices = resource[key]();
                        }
                    }
                } else {
                    // Call the proper endpoint/field.
                    choices = resource[convertedField]();
                }

                return choices;
            };

            /**
             * Creates an object with the data the object will be patched with.
             * @param data: The changed data. Can be an object or just a value.
             * @param [field] {string}: What field the data will be set to.
             * @param [model] {Object}: The model from which data can be retrieved.
             *
             * @returns args {Object}: The data the object will be patched with.
             */
            this.createArgs = function (data, field, model) {
                var args;

                if (data && !Array.isArray(data) && (typeof data === "undefined" ? "undefined" : _typeof(data)) === 'object') {
                    args = data;
                } else {
                    args = {
                        id: model.id
                    };

                    args[field] = data;
                }

                return args;
            };

            this.setSocialMediaFields = function (object) {
                if (object.social_media) {
                    object.social_media.forEach(function (profile) {
                        object[profile.name] = profile;
                    });
                }
            };

            /**
             * Converts the given variable name so it can be used to retrieve a field of the given resource.
             * @param name {string}: The string that will be converted to camelCase.
             *
             * @returns {string}: The converted variable name.
             */
            function _convertVariableName(name) {
                var splitName = name.split('_');
                var convertedName = 'get';
                var i;

                // Convert to title case.
                for (i = 0; i < splitName.length; i++) {
                    convertedName += splitName[i].charAt(0).toUpperCase() + splitName[i].slice(1);
                }

                return convertedName;
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').factory('HLSearch', HLSearch);

        HLSearch.$inject = ['$injector', 'Tag'];
        function HLSearch($injector, Tag) {
            HLSearch.refreshList = refreshList;
            HLSearch.refreshTags = refreshTags;
            HLSearch.getOpenCasesDeals = getOpenCasesDeals;

            function refreshList(query, modelName, extraFilterQuery) {
                var sortColumn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '-modified';
                var nameColumn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'name';

                var items;

                // Dynamically get the model.
                var model = $injector.get(modelName);

                var extraQuery = extraFilterQuery ? extraFilterQuery : '';

                if (query.length) {
                    // At least 2 characters need to be entered.
                    if (query.length >= 2) {
                        // Only exclude items if we have a multi-select field.
                        items = model.search({
                            filterquery: nameColumn + ':(' + query + ')' + extraQuery,
                            size: 60,
                            sort: sortColumn
                        });
                    }
                } else {
                    // No query yet, so just get the last 60 items of the given model.
                    items = model.search({ filterquery: extraQuery, size: 60, sort: sortColumn });
                }

                return items;
            }

            function refreshTags(searchQuery, object, type) {
                var tagsPromise;
                var i;

                var tags = object.tags;
                var contentTypeQuery = 'content_type.name:' + type;
                var query = searchQuery + ',' + contentTypeQuery;
                var filterquery = contentTypeQuery;

                // Exclude tags already selected.
                for (i = 0; i < tags.length; i++) {
                    filterquery += ' AND NOT name_flat:' + tags[i].name;
                }

                tagsPromise = Tag.search({ query: query, filterquery: filterquery });

                return tagsPromise;
            }

            /**
             * Search for open cases or deals belonging to the object's account and/or contact.
             *
             * @param closedStatusQuery {string}: Contains the filterquery string for the open status(es).
             * @param object {Object}: The case or deal that's used for the queries.
             * @param modelName {String}: Specifies if it's a case or deal.
             */
            function getOpenCasesDeals(closedStatusQuery, object, modelName) {
                var filterQuery = closedStatusQuery;

                if (object.id) {
                    // Filter out the current case.
                    filterQuery += ' AND NOT id: ' + object.id;
                }

                if (object.account && object.contact) {
                    filterQuery += ' AND (account.id:' + object.account.id + ' OR (account.id:' + object.account.id + ' AND contact.id:' + object.contact.id + '))';
                } else {
                    if (object.account) {
                        filterQuery += ' AND account.id:' + object.account.id;
                    }

                    if (object.contact) {
                        filterQuery += ' AND contact.id:' + object.contact.id;
                    }
                }

                // Inject the model's service and execute the search query.
                return $injector.get(modelName).search({ filterquery: filterQuery }).$promise;
            }

            return HLSearch;
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').service('HLShortcuts', HLShortcuts);

        HLShortcuts.$inject = ['$state', '$timeout', '$rootScope', 'Settings'];
        function HLShortcuts($state, $timeout, $rootScope, Settings) {
            // Use $rootScope because $root is unavailable in services.
            // This watches the change in states so we can execute certain Mousetrap
            // functions on specific pages.
            $rootScope.$on('$stateChangeSuccess', function () {
                var state = $state.current.name;
                if (state === 'base.email.list') {
                    Mousetrap.bind('c', function () {
                        $state.go('base.email.compose');
                        // Unbind after pressed so next bind can take place.
                        Mousetrap.unbind('c');
                    });
                }

                if (state === 'base.email.detail') {
                    Mousetrap.bind('c', function () {
                        _replyViaShortcode();
                        // Unbind after pressed so next bind can take place.
                        Mousetrap.unbind('c');
                    });

                    Mousetrap.bind('r', function () {
                        _replyViaShortcode();
                        // Unbind after pressed so next bind can take place.
                        Mousetrap.unbind('r');
                    });

                    Mousetrap.bind('d', function () {
                        // Broadcast event for email/controllers/detail.js to handle
                        // sending the particular email to trash.
                        $rootScope.$broadcast('deleteMessageByShortCode');
                        // Unbind after pressed so next bind can take place.
                        Mousetrap.unbind('d');
                    });

                    Mousetrap.bind('e', function () {
                        // Broadcast event for email/controllers/detail.js to handle
                        // sending the particular email to trash.
                        $rootScope.$broadcast('archiveMessageByShortCode');
                        // Unbind after pressed so next bind can take place.
                        Mousetrap.unbind('e');
                    });
                }

                if (state === 'base.email.compose') {
                    Mousetrap.bind('mod+enter', function () {
                        // Submit the email form.
                        document.getElementById('fileupload').submit();
                    });
                } else if (state === 'base.deals.detail.edit' || state === 'base.deals.create') {
                    Mousetrap.bindGlobal('mod+enter', function () {
                        // Broadcast event for deals/controllers/createupdate.js to save
                        // the deal.
                        $rootScope.$broadcast('saveDeal');
                    }, 'keyup');
                } else if (state === 'base.cases.detail.edit' || state === 'base.cases.create') {
                    Mousetrap.bindGlobal('mod+enter', function () {
                        // Broadcast event for cases/controllers/createupdate.js to save
                        // the case.
                        $rootScope.$broadcast('saveCase');
                    }, 'keyup');
                } else if (state === 'base.contacts.detail.edit' || state === 'base.contacts.create') {
                    Mousetrap.bindGlobal('mod+enter', function () {
                        // Broadcast event for contact/controllers/createupdate.js to save
                        // the contact.
                        $rootScope.$broadcast('saveContact');
                    });
                } else if (state === 'base.accounts.detail.edit' || state === 'base.accounts.create') {
                    Mousetrap.bindGlobal('mod+enter', function () {
                        // Broadcast event for account/controllers/createupdate.js to save
                        // the account.
                        $rootScope.$broadcast('saveAccount');
                    });
                } else if (state === 'base.email.detail') {
                    Mousetrap.bindGlobal('mod+enter', function () {
                        // Broadcast event for account/controllers/createupdate.js to save
                        // the account.
                        if (Settings.email.sidebar.form === 'account') {
                            $rootScope.$broadcast('saveAccount');
                        } else if (Settings.email.sidebar.form === 'contact') {
                            $rootScope.$broadcast('saveContact');
                        }
                    });
                } else {
                    // Unbind when not a form page.
                    Mousetrap.unbind('mod+enter');
                }

                // Function for both the c and r key when in Email Detail view.
                function _replyViaShortcode() {
                    var message = $state.params.id;
                    if (message) {
                        $state.go('base.email.reply', { id: message });
                    }
                }

                $timeout(function () {
                    var searchField = '.hl-search-field';

                    if (angular.element(searchField).length) {
                        Mousetrap.bind('s', function () {
                            var scope = angular.element($(searchField).get(0)).scope();
                            angular.element(searchField).focus();
                            // TODO: Remove if statement if Contacts get refactored
                            // To utilize vm.table. instead of table.
                            if (state === 'base.contacts') {
                                scope.table.filter = '';

                                // TODO: Remove else if statement if we refactor code to
                                // make the filter/search model consistent.
                            } else if (state === 'base.deals' || state === 'base.cases') {
                                scope.vm.table.searchQuery = '';
                            } else {
                                scope.vm.table.filter = '';
                            }
                            scope.$apply();
                        }, 'keyup');
                    }
                });
            });
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').service('HLSockets', HLSockets);

        HLSockets.$inject = ['$state', '$timeout', '$rootScope', 'Settings'];
        function HLSockets($state, $timeout, $rootScope, Settings) {
            var _this = this;

            var wsEnabled = 'WebSocket' in window && 'Notification' in window && Notification.permission !== 'denied' && currentUser.internalNumber;

            var listeners = {};
            var ws = null;

            if (wsEnabled) {
                var wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
                ws = new ReconnectingWebSocket(wsScheme + '://' + window.location.host + '/');

                // Dispatch open and close events so these can be bound to.
                ws.onopen = function () {
                    return _this.dispatch('open');
                };
                ws.onclose = function () {
                    return _this.dispatch('close');
                };
                ws.onmessage = function (message) {
                    var data = JSON.parse(message.data);
                    _this.dispatch(data.event, data.data);
                };
            }

            // Allow functions to bind to specific WebSocket events.
            this.bind = function (type, callback) {
                listeners[type] = listeners[type] || [];
                listeners[type].push(callback);
                return _this;
            };

            this.close = function () {
                var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

                if (wsEnabled) ws.close(1000, reason);
            };

            this.dispatch = function (type) {
                var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

                // Dispatches the event and its data to all functions bound to the event.
                if (!(type in listeners)) return;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = listeners[type][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var callback = _step.value;

                        callback(data);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').service('HLUtils', HLUtils);

        function HLUtils() {
            this.formatPhoneNumber = function (phoneNumber) {
                var newNumber;

                if (!phoneNumber.number || phoneNumber.number.match(/[a-z]/i)) {
                    // If letters are found, skip formatting: it may not be a phone field after all.
                    return false;
                }

                // Format phone number
                newNumber = phoneNumber.number.replace('(0)', '').replace(/\s|\(|\-|\)|\.|\\|\/|\|x|:|\*/g, '').replace(/^00/, '+');

                if (newNumber.length === 0) {
                    return false;
                }

                // Check if it's a mobile phone number.
                if (newNumber.match(/^\+31([\(0\)]+)?6|^06/)) {
                    // Set phone number type to mobile.
                    phoneNumber.type = 'mobile';
                }

                if (!newNumber.startsWith('+')) {
                    if (newNumber.startsWith('0')) {
                        newNumber = newNumber.substring(1);
                    }

                    newNumber = '+31' + newNumber;
                }

                if (newNumber.startsWith('+310')) {
                    newNumber = '+31' + newNumber.substring(4);
                }

                phoneNumber.number = newNumber;

                return phoneNumber;
            };

            this.setPrimaryEmailAddress = function (emailAddress, emailAddresses) {
                // Check if the status of an email address is 'Primary'.
                if (emailAddress.status === 2) {
                    angular.forEach(emailAddresses, function (email) {
                        // Set the status of the other (active) email addresses to 'Other'.
                        if (emailAddress !== email && email.status !== 0) {
                            email.status = 1;
                        }
                    });
                }
            };

            this.getFullName = function (user) {
                // Join strings in array while ignoring empty values.
                return [user.first_name, user.last_name].filter(function (val) {
                    return val;
                }).join(' ');
            };

            this.getSorting = function (field, descending) {
                var sort = '';
                sort += descending ? '-' : '';
                sort += field;

                return sort;
            };

            this.timeCategorizeObjects = function (data, field) {
                var now = moment();
                var tomorrow = moment().add('1', 'day');
                var day;

                var items = {
                    newlyAssigned: [],
                    expired: [],
                    today: [],
                    tomorrow: [],
                    later: []
                };

                angular.forEach(data, function (item) {
                    if (item[field]) {
                        day = moment(item[field]);

                        if (item.newly_assigned && item.assigned_to.id === currentUser.id) {
                            items.newlyAssigned.push(item);
                        } else if (day.isBefore(now, 'day')) {
                            items.expired.push(item);
                        } else if (day.isSame(now, 'day')) {
                            items.today.push(item);
                        } else if (day.isSame(tomorrow, 'day')) {
                            items.tomorrow.push(item);
                        } else {
                            items.later.push(item);
                        }
                    } else {
                        items.later.push(item);
                    }
                });

                return items;
            };

            this.addBusinessDays = function (daysToAdd, date) {
                var i = 0;
                var newDate;

                if (date) {
                    // Given date might not be a moment object, so just convert it.
                    newDate = moment(date);
                } else {
                    newDate = moment();
                }

                // Add days based on what the priority is. Skip weekends.
                while (i < daysToAdd) {
                    newDate = newDate.add(1, 'day');

                    if (newDate.day() !== 0 && newDate.day() !== 6) {
                        i++;
                    }
                }

                return newDate.toDate();
            };

            /**
             * The will block the interface for a specific element.
             *
             * @param target {string} the element to be blocked.
             * @param animate {boolean} if there needs to be an animation on the element.
             */
            this.blockUI = function (target, animate) {
                Metronic.blockUI({
                    css: { backgroundColor: '#ff0000' },
                    target: target,
                    animate: animate
                });
            };

            /**
             * Unblock the interface that was set with blockUI.
             *
             * @param target {string} the element that needs to be unblocked
             */
            this.unblockUI = function (target) {
                Metronic.unblockUI(target);
            };

            this.decodeHtmlEntities = function (str) {
                var chars = { quot: 34, amp: 38, lt: 60, gt: 62, nbsp: 160, copy: 169, reg: 174, deg: 176, frasl: 47, trade: 8482, euro: 8364, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, permil: 8240, lsaquo: 8249, rsaquo: 8250, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830, oline: 8254, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, hellip: 133, ndash: 150, mdash: 151, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, brkbar: 166, sect: 167, uml: 168, die: 168, ordf: 170, laquo: 171, not: 172, shy: 173, macr: 175, hibar: 175, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Alpha: 913, alpha: 945, Beta: 914, beta: 946, Gamma: 915, gamma: 947, Delta: 916, delta: 948, Epsilon: 917, epsilon: 949, Zeta: 918, zeta: 950, Eta: 919, eta: 951, Theta: 920, theta: 952, Iota: 921, iota: 953, Kappa: 922, kappa: 954, Lambda: 923, lambda: 955, Mu: 924, mu: 956, Nu: 925, nu: 957, Xi: 926, xi: 958, Omicron: 927, omicron: 959, Pi: 928, pi: 960, Rho: 929, rho: 961, Sigma: 931, sigma: 963, Tau: 932, tau: 964, Upsilon: 933, upsilon: 965, Phi: 934, phi: 966, Chi: 935, chi: 967, Psi: 936, psi: 968, Omega: 937, omega: 969 };
                return str.replace(/&#?(\w+);/g, function (match, char) {
                    var asciiChar = char;

                    // Look for html entities and replace with actual character (dec is the ascii character number).
                    if (isNaN(char)) {
                        if (chars[char] !== undefined) {
                            asciiChar = chars[char];
                        }
                    }
                    return String.fromCharCode(asciiChar);
                });
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        /**
         * LocalStorage Service provides a simple interface to get and store local storage values
         *
         * Set `prefix` to give local storage keys a prefix
         */
        angular.module('app.services').service('LocalStorage', LocalStorageService);

        LocalStorageService.$inject = [];
        function LocalStorageService() {
            function LocalStorageFactory(prefix) {
                return new LocalStorage(prefix);
            }

            function LocalStorage(prefix) {
                this.prefix = prefix;
            }

            /**
             * Try to retrieve and return a value from the local storage or
             * returns a default value if local storage doesn't exist.
             *
             * @param field {string}: Name of the field to retrieve info from
             * @param defaultValue {*} : Default value when locally stored doesn't exist
             * @returns {*}: Retrieved or default value
             */
            LocalStorage.prototype.get = function (field, defaultValue) {
                var value = localStorage.getItem(this.prefix + field);

                try {
                    value = JSON.parse(value);

                    return value !== null ? value : defaultValue;
                } catch (error) {
                    localStorage.removeItem(this.prefix + field);
                    return defaultValue;
                }
            };

            /**
             * Try to retrieve and return an object from the local storage or
             * returns a default value if local storage doesn't exist.
             *
             * @param field {string}: Name of the field to retrieve info from
             * @param defaultValue {*} : Default value when local storage doesn't exist
             * @returns {*}: Retrieved or default value
             */
            LocalStorage.prototype.getObjectValue = function (field, defaultValue) {
                var storage;
                var values;
                var value;

                try {
                    storage = this;
                    values = storage.get('', defaultValue);
                    value = values[field];

                    return value ? value : defaultValue;
                } catch (error) {
                    localStorage.removeItem(this.prefix[field]);
                    return defaultValue;
                }
            };

            /**
             * Creates/updates a local storage based on the given prefix + field name.
             *
             * @param field {string}: Name of the field to be created/updated
             * @param value {*} : The value to be stored
             */
            LocalStorage.prototype.put = function (field, value) {
                var convertedValue = JSON.stringify(value);

                localStorage.setItem(this.prefix + field, convertedValue);
            };

            /**
             * Stores an object as a local storage instead of creating a local storage for every option.
             * @param field {string}: Name of the field to be created/updated
             * @param value {*} : The value of the local storage
             */
            LocalStorage.prototype.putObjectValue = function (field, value) {
                var storage = this;
                var values = storage.get('', {});
                values[field] = value;

                localStorage.setItem(this.prefix, JSON.stringify(values));
            };

            return LocalStorageFactory;
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.services').factory('Settings', ['LocalStorage', function () {
            var page = new (Function.prototype.bind.apply(Page, [null].concat(Array.prototype.slice.call(arguments))))();
            return {
                page: page,
                email: page.email
            };
        }]);

        /**
         * Class representing the main settings object for the email sidebar layout.
         */

        var Sidebar = function Sidebar() {
            _classCallCheck(this, Sidebar);

            this.account = null;
            this.contact = null;
            this.cases = null;
            this.deals = null;
            this.form = null;
            this.isVisible = false;
        };

        /**
         * Class representing the main settings object for email layout.
         */


        var Email = function () {
            /**
             * Initialize email layout.
             * @param {LocalStorage} storage - LocalStorage instance.
             */
            function Email(storage) {
                _classCallCheck(this, Email);

                this.sidebar = new Sidebar();
                this.storage = storage;
                this.title = 'Welcome';
                this.previousInbox = this.storage.get('previousInbox', null);
                this.page = 0;
                this.toRemove = [];
            }

            /**
             * Set previous email state.
             * @param {Object} previousInbox - Email state object.
             */


            _createClass(Email, [{
                key: "setPreviousInbox",
                value: function setPreviousInbox(previousInbox) {
                    this.storage.put('previousInbox', previousInbox);
                    this.previousInbox = previousInbox;
                }

                /**
                 * Reset all the data properties that concern the email layout.
                 */

            }, {
                key: "resetEmailSettings",
                value: function resetEmailSettings() {
                    // email.sidebar stores the state of sidebar panels (so hidden/closed).
                    this.sidebar = {
                        account: null,
                        contact: null,
                        case: null,
                        deal: null,
                        form: null,
                        isVisible: false
                    };

                    // email.data stores the actual data which is used for the sidebars.
                    this.data = {
                        website: null,
                        account: null,
                        contact: null,
                        cases: null,
                        deals: null
                    };
                }
            }]);

            return Email;
        }();

        /**
         * Class representing the main settings object for page header layout.
         */


        var Header = function () {
            function Header() {
                _classCallCheck(this, Header);

                this.main = 'Lily';
            }

            /**
             * Sets the header's main title.
             * @param {String} pageType - The page category/type, e.g. `custom`/list`/`create`.
             * @param {String} newHeader - The new name to use in the title.
             * @return {String} The new title.
             */


            _createClass(Header, [{
                key: "setMain",
                value: function setMain(pageType, newHeader) {
                    var formats = {
                        create: 'New ',
                        edit: 'Edit ',
                        custom: ''
                    };

                    if (pageType && newHeader) {
                        if (formats[pageType]) {
                            this.main = formats[pageType] + newHeader;
                        } else {
                            this.main = newHeader.charAt(0).toUpperCase() + newHeader.slice(1);
                        }
                    }
                }
            }]);

            return Header;
        }();

        var Toolbar = function Toolbar() {
            _classCallCheck(this, Toolbar);

            this.data = null;
        };

        /**
         * Class representing the main settings object for page layout.
         */


        var Page = function () {
            function Page(localStorage) {
                _classCallCheck(this, Page);

                this.storage = localStorage('generalSettings');
                this.title = 'Welcome';

                this.email = new Email(this.storage);
                this.header = new Header();
                this.toolbar = new Toolbar();
                this.previousState = null;
            }

            /**
             * Sets tab/window border title, but also the header's title and (optional)
             * context of contact/account.
             * @param {String} pageType - The page category/type, e.g. `custom`/list`/`create`.
             * @param {String} objectInfo - The type of objects the page shows, e.g. `accounts`/`contacts`.
             * @param {Contact} contact - A contact object to set the page context to.
             * @param {Account} account - An account object to set the page context to.
             */


            _createClass(Page, [{
                key: "setAllTitles",
                value: function setAllTitles(pageType, objectInfo) {
                    var contact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                    var account = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

                    // Make sure sidebar forms don't set the titles/headers.
                    if (!this.email.sidebar.form) {
                        this.title = objectInfo.charAt(0).toUpperCase() + objectInfo.slice(1);
                        this.header.setMain(pageType, objectInfo);
                        this.contact = contact;
                        this.account = account;
                    }
                }
            }]);

            return Page;
        }();
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.users.filters').filter('fullName', fullName);

        function fullName() {
            return function (user) {
                return [user.first_name, user.last_name].join(' ');
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.users.services').factory('User', User);

        User.$inject = ['$resource', 'CacheFactory'];
        function User($resource, CacheFactory) {
            var cache = CacheFactory.get('userCache');
            var interceptor = {
                // Interceptor used to remove/update the cache on update/delete.
                response: function response(_response) {
                    var cacheKey = _response.config.url;

                    if (_response.config.params) {
                        cacheKey += '?' + _response.config.paramSerializer(_response.config.params);
                    }

                    if (_response.data) {
                        // New data was returned, so use that for the cache.
                        cache.put(cacheKey, _response.data);
                    } else {
                        // No new data was returned, so delete the cache.
                        cache.remove(cacheKey);
                    }

                    return _response;
                }
            };

            var _user = $resource('/api/users/:id/', null, {
                get: {
                    cache: cache,
                    transformResponse: function transformResponse(data) {
                        return angular.fromJson(data);
                    }
                },
                query: {
                    cache: cache,
                    isArray: false
                },
                search: {
                    url: '/search/search/?type=users_lilyuser&filterquery=:filterquery',
                    method: 'GET',
                    transformResponse: function transformResponse(data) {
                        var jsonData = angular.fromJson(data);
                        var objects = [];

                        if (jsonData && jsonData.hits && jsonData.hits.length > 0) {
                            jsonData.hits.forEach(function (obj) {
                                objects.push(obj);
                            });
                        }

                        return {
                            objects: objects,
                            total: jsonData.total
                        };
                    }
                },
                me: {
                    method: 'GET',
                    url: '/api/users/me/',
                    isArray: false
                },
                update: {
                    method: 'PUT',
                    url: '/api/users/:id/',
                    interceptor: interceptor
                },
                patch: {
                    method: 'PATCH',
                    params: {
                        id: '@id'
                    },
                    interceptor: interceptor
                },
                delete: {
                    method: 'DELETE',
                    url: '/api/users/:id/',
                    interceptor: interceptor
                },
                token: {
                    method: 'GET',
                    url: '/api/users/token/'
                },
                deleteToken: {
                    method: 'DELETE',
                    url: '/api/users/token/'
                },
                generateToken: {
                    method: 'POST',
                    url: '/api/users/token/'
                },
                getAssignOptions: {
                    url: '/api/users/'
                }
            });

            return _user;
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.users.services').factory('UserTeams', UserTeams);

        UserTeams.$inject = ['$resource'];
        function UserTeams($resource) {
            var _userTeam = $resource('/api/users/team/:id/', null, {
                query: {
                    isArray: false
                },
                search: {
                    url: '/search/search/?type=users_team&filterquery=:filterquery',
                    method: 'GET',
                    transformResponse: function transformResponse(data) {
                        var jsonData = angular.fromJson(data);
                        var objects = [];

                        if (jsonData && jsonData.hits && jsonData.hits.length > 0) {
                            jsonData.hits.forEach(function (obj) {
                                objects.push(obj);
                            });
                        }

                        return {
                            objects: objects,
                            total: jsonData.total
                        };
                    }
                },
                mine: {
                    method: 'GET',
                    url: '/api/users/team/mine/',
                    isArray: true
                }
            });

            return _userTeam;
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.utils.directives').directive('assignTo', assignToDirective);

        function assignToDirective() {
            return {
                restrict: 'E',
                scope: {
                    object: '<',
                    type: '@'
                },
                templateUrl: 'utils/directives/assignto.html',
                controller: AssignToController,
                controllerAs: 'vm',
                bindToController: true
            };
        }

        AssignToController.$inject = ['$compile', '$injector', '$scope', '$state', '$templateCache', '$timeout', 'HLResource', 'HLSearch', 'HLUtils'];
        function AssignToController($compile, $injector, $scope, $state, $templateCache, $timeout, HLResource, HLSearch, HLUtils) {
            var vm = this;

            vm.assignTo = assignTo;
            vm.assignToMe = assignToMe;
            vm.refreshUsers = refreshUsers;

            function assignTo(myCase) {
                swal({
                    title: sprintf(messages.alerts.assignTo.title, { type: vm.type.toLowerCase() }),
                    html: $compile($templateCache.get('utils/directives/assignto_modal.html'))($scope),
                    showCancelButton: true,
                    showCloseButton: true
                }).then(function (isConfirm) {
                    if (isConfirm) {
                        $injector.get(vm.type).patch({ id: vm.object.id, assigned_to: vm.assigned_to.id }).$promise.then(function () {
                            $state.go($state.current, {}, { reload: true });
                        });
                    }
                }).done();
            }

            function assignToMe() {
                vm.assigned_to = {
                    id: currentUser.id,
                    full_name: currentUser.fullName
                };
            }

            function refreshUsers(query) {
                var usersPromise;

                if (!vm.assigned_to || query.length) {
                    usersPromise = HLSearch.refreshList(query, 'User', 'is_active:true', 'full_name', 'full_name');

                    if (usersPromise) {
                        usersPromise.$promise.then(function (data) {
                            vm.users = data.objects;
                        });
                    }
                }
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.utils.directives').directive('collapsable', CollapsableDirective);

        CollapsableDirective.$inject = [];
        function CollapsableDirective() {
            return {
                restrict: 'E',
                transclude: true,
                templateUrl: 'utils/directives/collapsable.html',
                controller: CollapsableController,
                controllerAs: 'cl',
                bindToController: true,
                scope: {
                    name: '@'
                }
            };
        }

        CollapsableController.$inject = ['$scope', 'LocalStorage'];
        function CollapsableController($scope, LocalStorage) {
            var vm = this;

            var storage = new LocalStorage('collapseDirective-' + vm.name);
            vm.folded = storage.get('folded', false);

            vm.toggleFolded = toggleFolded;

            function toggleFolded() {
                vm.folded = !vm.folded;
                storage.put('folded', vm.folded);
                $scope.$broadcast('foldedToggle', vm.folded);
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.utils.directives').directive('collapsableButton', CollapsableButtonDirective);

        CollapsableButtonDirective.$inject = [];
        function CollapsableButtonDirective() {
            return {
                restrict: 'E',
                require: '^collapsable',
                templateUrl: 'utils/directives/collapsable_button.html',
                link: function link(scope, element, attrs, collapsableCtrl) {
                    element.on('click', function () {
                        collapsableCtrl.toggleFolded();
                    });
                },
                controller: CollapsableButtonController,
                controllerAs: 'cl'
            };
        }

        CollapsableButtonController.$inject = ['$scope'];
        function CollapsableButtonController($scope) {
            var vm = this;
            // Don't know why, but this controller is instantiated without the parent directive sometimes, somewhere...
            vm.folded = $scope.$parent.cl ? $scope.$parent.cl.folded : false;

            $scope.$on('foldedToggle', function (event, folded) {
                vm.folded = folded;
                $scope.$apply();
            });
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.utils.directives').directive('collapsableContent', CollapsableContentDirective);

        CollapsableContentDirective.$inject = [];
        function CollapsableContentDirective() {
            return {
                restrict: 'E',
                templateUrl: 'utils/directives/collapsable_content.html',
                transclude: true,
                require: '^collapsable',
                controller: CollapsableContentController,
                controllerAs: 'cl'
            };
        }

        CollapsableContentController.$inject = ['$scope'];
        function CollapsableContentController($scope) {
            var vm = this;
            // Don't know why, but this controller is instantiated without the parent directive sometimes, somewhere...
            vm.folded = $scope.$parent.cl ? $scope.$parent.cl.folded : false;

            $scope.$on('foldedToggle', function (event, folded) {
                vm.folded = folded;
                $scope.$apply();
            });
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.utils.directives').directive('date', dateDirective);

        function dateDirective() {
            return {
                restrict: 'E',
                scope: {
                    date: '=',
                    showTime: '=',
                    addTime: '=',
                    dateFormat: '@'
                },
                templateUrl: 'utils/directives/date.html',
                controller: DateController,
                controllerAs: 'vm',
                bindToController: true
            };
        }

        DateController.$inject = [];
        function DateController() {
            var vm = this;
            var date;

            if (vm.date) {
                // new Date() to prevent deprecation warning of MomentJS.
                date = moment(new Date(vm.date));

                if (!vm.dateFormat) {
                    if (date.isSame(moment(), 'day') && vm.showTime) {
                        // In certain cases we want to display the time if it's the same day.
                        vm.dateFormat = 'HH:mm';
                    } else {
                        if (vm.addTime) {
                            vm.dateFormat = 'dd MMM. yyyy - HH:mm'; // Renders as 29 Dec. - 2015 12:15
                        } else {
                            vm.dateFormat = 'dd MMM. yyyy'; // Renders as 29 Dec. 2015
                        }
                    }
                } else {
                    // Setting format to date to correctly use in the historylist.
                    vm.date = date.format();
                }
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.utils.directives').directive('dueDateFilter', dueDateFilter);

        function dueDateFilter() {
            return {
                restrict: 'E',
                scope: {
                    filterStore: '=',
                    filterField: '=',
                    type: '='
                },
                templateUrl: 'utils/directives/due_date_filter.html',
                controller: DueDateFilterWidgetController,
                controllerAs: 'vm',
                bindToController: true
            };
        }

        DueDateFilterWidgetController.$inject = ['LocalStorage', '$scope'];
        function DueDateFilterWidgetController(LocalStorage, $scope) {
            var vm = this;
            var storage = new LocalStorage(vm.type);

            // Get the stored value or set to 'All' if it doesn't exist
            vm.dueDateFilter = storage.get('dueDateFilter', 0);
            vm.openDueDateFilter = openDueDateFilter;

            activate();

            ////////////

            function activate() {
                _watchDueDateFilter();
            }

            // Open Due Date Filter for right element. This function gets used
            // when the breakpoints are > tablet.
            function openDueDateFilter($event) {
                angular.element($event.srcElement).next().toggleClass('is-open');
            }

            function _watchDueDateFilter() {
                $scope.$watch('vm.dueDateFilter', function () {
                    var today;
                    var tomorrow;
                    var week;

                    var filter = '';
                    var filterField = vm.filterField ? vm.filterField : 'expires';
                    filterField += ': ';

                    // Find element with .is-open class to close when clicking a filter.
                    angular.element('.due-date-filter-container.is-open').removeClass('is-open');

                    switch (vm.dueDateFilter) {
                        default:
                        case 0:
                            filter = '';
                            break;
                        case 1:
                            today = moment().format('YYYY-MM-DD');
                            filter = filterField + today;
                            break;
                        case 2:
                            tomorrow = moment().add(1, 'd').format('YYYY-MM-DD');
                            filter = filterField + tomorrow;
                            break;
                        case 3:
                            today = moment().format('YYYY-MM-DD');
                            week = moment().add(6, 'd').format('YYYY-MM-DD');
                            filter = filterField + '[' + today + ' TO ' + week + ']';
                            break;
                        case 4:
                            filter = filterField + '[* TO ' + moment().subtract(1, 'd').format('YYYY-MM-DD') + ']';
                            break;
                    }

                    storage.put('dueDateFilter', vm.dueDateFilter);
                    vm.filterStore = filter;
                });
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.utils.directives').directive('historyAddNote', historyAddNoteDirective);

        function historyAddNoteDirective() {
            return {
                restrict: 'E',
                scope: {
                    item: '='
                },
                templateUrl: 'utils/directives/history_add_note.html',
                controller: HistoryAddNoteController,
                controllerAs: 'vm',
                bindToController: true
            };
        }

        HistoryAddNoteController.$inject = ['$http', '$state', 'Note', 'User'];
        function HistoryAddNoteController($http, $state, Note, User) {
            var vm = this;
            vm.note = new Note({ content_type: vm.item.content_type, object_id: vm.item.id, type: 0 });

            vm.addNote = addNote;

            function addNote() {
                vm.note.$save(function (response) {
                    // Set user object to note to correctly show profile pic and name
                    // when adding a new note in the historylist.
                    User.get({ id: currentUser.id }, function (author) {
                        response.author = author;
                    });

                    vm.item.notes.unshift(response);
                    // 'Empty' the note object to be able to continue posting another
                    // note without having to refresh the page.
                    vm.note = new Note({ content_type: vm.item.content_type, object_id: vm.item.id, type: 0 });
                });
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.utils.directives').directive('historyList', HistoryListDirective);

        HistoryListDirective.$inject = ['$filter', '$q', '$state', 'Case', 'Deal', 'EmailAccount', 'EmailDetail', 'HLGravatar', 'HLResource', 'HLUtils', 'Note', 'NoteDetail', 'User'];
        function HistoryListDirective($filter, $q, $state, Case, Deal, EmailAccount, EmailDetail, HLGravatar, HLResource, HLUtils, Note, NoteDetail, User) {
            return {
                restrict: 'E',
                replace: true,
                scope: {
                    target: '=',
                    object: '=',
                    dateStart: '=?',
                    dateEnd: '=?',
                    extraObject: '=?',
                    parentObject: '=?'
                },
                templateUrl: 'utils/directives/historylist.html',
                link: function link(scope, element, attrs) {
                    var page = 0;
                    var pageSize = 50;

                    scope.history = {};
                    scope.history.list = [];
                    scope.history.types = {
                        '': { name: 'All', visible: true },
                        'note': { name: 'Notes', visible: false },
                        'case': { name: 'Cases', visible: false },
                        'deal': { name: 'Deals', visible: false },
                        'email': { name: 'Emails', visible: false }
                    };
                    scope.history.activeFilter = '';
                    scope.history.showMoreText = 'Show more';
                    scope.history.loadMore = loadMore;
                    scope.history.reloadHistory = reloadHistory;
                    scope.history.addNote = addNote;
                    scope.history.pinNote = pinNote;
                    scope.history.removeFromList = removeFromList;
                    scope.history.filterType = filterType;

                    scope.note = {};
                    scope.note.type = 0;

                    activate();

                    ////////

                    function activate() {
                        HLUtils.blockUI('#historyListBlockTarget', true);
                        // Somehow calling autosize on page content load does not work
                        // in the historylist.
                        autosize($('textarea'));
                        loadMore();
                    }

                    function filterType(value) {
                        var key;
                        var selectedCount;

                        scope.history.activeFilter = value;
                        // Loop through the months to hide the monthname when there
                        // aren't any items in that month that are shown due to
                        // the filter that is being selected.
                        for (key in scope.history.list.nonPinned) {
                            selectedCount = $filter('filter')(scope.history.list.nonPinned[key].items, { historyType: value }).length;
                            scope.history.list.nonPinned[key].isVisible = !!selectedCount;
                        }
                    }

                    function loadMore() {
                        if (!scope.object.$resolved) {
                            scope.object.$promise.then(function (obj) {
                                _fetchHistory(obj);
                            });
                        } else {
                            _fetchHistory(scope.object);
                        }
                    }

                    function reloadHistory() {
                        page -= 1;
                        loadMore();
                    }

                    function _fetchHistory(obj) {
                        var history = [];
                        var promises = [];
                        var neededLength = (page + 1) * pageSize;
                        var requestLength = neededLength + 1;
                        var notePromise;
                        var dateQuery = '';
                        var emailDateQuery = '';
                        var casePromise;
                        var dealPromise;
                        var tenantEmailAccountPromise;
                        var emailPromise;
                        var i;
                        var filterquery;
                        var currentObject = obj;
                        var contentType = scope.target;

                        if (scope.dateStart && scope.dateEnd) {
                            dateQuery = ' AND modified:[' + scope.dateStart + ' TO ' + scope.dateEnd + ']';
                            emailDateQuery = 'sent_date:[' + scope.dateStart + ' TO ' + scope.dateEnd + ']';
                        }

                        page += 1;

                        filterquery = '(content_type:' + contentType + ' AND object_id:' + currentObject.id + ')';

                        if (contentType === 'account' && currentObject.contact) {
                            // Show all notes of contacts linked to the account.
                            for (i = 0; i < currentObject.contact.length; i++) {
                                filterquery += ' OR (content_type:contact AND object_id:' + currentObject.contact[i] + ')';
                            }
                        }

                        if (scope.extraObject) {
                            filterquery += ' OR (content_type:' + scope.extraObject.target + ' AND object_id:' + scope.extraObject.object.id + ')';
                        }

                        filterquery = '(' + filterquery + ')';

                        notePromise = NoteDetail.query({ filterquery: filterquery + dateQuery, size: requestLength }).$promise;

                        promises.push(notePromise); // Add promise to list of all promises for later handling

                        notePromise.then(function (results) {
                            results.forEach(function (note) {
                                // Get user for notes to show profile picture correctly.
                                User.get({ id: note.author.id, is_active: 'All' }, function (userObject) {
                                    note.author = userObject;
                                });

                                // Set notes shown property to true to have toggled open as default.
                                if (note.is_pinned) {
                                    note.shown = true;
                                }

                                // If it's a contact's note, add extra attribute to the note
                                // so we can identify it in the template
                                if (scope.target === 'account' && note.content_type === 'contact') {
                                    note.showContact = true;
                                }

                                history.push(note);
                            });
                        });

                        if (scope.extraObject) {
                            currentObject = scope.extraObject.object;
                            contentType = scope.extraObject.target;
                        }

                        // We don't have to fetch extra objects for the case or deal
                        // history list. So continue if we have an extra object or if
                        // we're dealing with something else than a case or deal.
                        if (contentType !== 'case' && contentType !== 'deal') {
                            filterquery = contentType + '.id:' + currentObject.id;

                            casePromise = Case.search({ filterquery: filterquery + dateQuery, size: 100 }).$promise;

                            promises.push(casePromise); // Add promise to list of all promises for later handling

                            casePromise.then(function (response) {
                                response.objects.forEach(function (caseItem) {
                                    // Get user object for the assigned to user.
                                    if (caseItem.assigned_to) {
                                        User.get({ id: caseItem.assigned_to.id, is_active: 'All' }, function (userObject) {
                                            caseItem.assigned_to = userObject;
                                        });
                                    }

                                    if (caseItem.created_by) {
                                        // Get user object for the created by user.
                                        User.get({ id: caseItem.created_by.id, is_active: 'All' }, function (userObject) {
                                            caseItem.created_by = userObject;
                                        });
                                    }

                                    caseItem.historyType = 'case';

                                    history.push(caseItem);
                                    NoteDetail.query({ filterquery: 'content_type:case AND object_id:' + caseItem.id, size: 15 }).$promise.then(function (notes) {
                                        angular.forEach(notes, function (note) {
                                            // Get user for notes to show profile picture correctly.
                                            User.get({ id: note.author.id, is_active: 'All' }, function (author) {
                                                note.author = author;
                                            });
                                        });

                                        caseItem.notes = notes;
                                    });
                                });
                            });

                            dealPromise = Deal.search({ filterquery: filterquery + dateQuery, size: requestLength }).$promise;
                            promises.push(dealPromise); // Add promise to list of all promises for later handling

                            dealPromise.then(function (results) {
                                results.objects.forEach(function (deal) {
                                    if (deal.assigned_to) {
                                        // Get user object for the assigned to user.
                                        User.get({ id: deal.assigned_to.id, is_active: 'All' }, function (userObject) {
                                            deal.assigned_to = userObject;
                                        });
                                    }

                                    if (deal.created_by) {
                                        // Get user object to show profile picture correctly.
                                        User.get({ id: deal.created_by.id, is_active: 'All' }, function (userObject) {
                                            deal.created_by = userObject;
                                        });
                                    }

                                    NoteDetail.query({
                                        filterquery: 'content_type:deal AND object_id:' + deal.id,
                                        size: 5
                                    }).$promise.then(function (notes) {
                                        angular.forEach(notes, function (note) {
                                            // Get user for notes to show profile picture correctly.
                                            User.get({ id: note.author.id, is_active: 'All' }, function (author) {
                                                note.author = author;
                                            });
                                        });

                                        deal.notes = notes;
                                    });

                                    history.push(deal);
                                });
                            });

                            tenantEmailAccountPromise = EmailAccount.query().$promise;
                            promises.push(tenantEmailAccountPromise);

                            if (contentType === 'account') {
                                emailPromise = EmailDetail.query({ account_related: currentObject.id, filterquery: emailDateQuery, size: requestLength }).$promise;
                            } else {
                                emailPromise = EmailDetail.query({ contact_related: currentObject.id, filterquery: emailDateQuery, size: requestLength }).$promise;
                            }

                            promises.push(emailPromise);

                            $q.all([tenantEmailAccountPromise, emailPromise]).then(function (results) {
                                var tenantEmailAccountList = results[0].results;
                                var emailMessageList = results[1];

                                emailMessageList.forEach(function (email) {
                                    User.search({ filterquery: 'email:' + email.sender_email, is_active: 'All' }).$promise.then(function (userResults) {
                                        if (userResults.objects[0]) {
                                            email.profile_picture = userResults.objects[0].profile_picture;
                                        } else {
                                            email.profile_picture = HLGravatar.getGravatar(email.sender_email);
                                        }
                                    });

                                    tenantEmailAccountList.forEach(function (emailAddress) {
                                        if (emailAddress.email_address === email.sender_email) {
                                            email.right = true;
                                        }
                                    });

                                    history.push(email);
                                });
                            });
                        }

                        // Get all history types and add them to a common history.
                        $q.all(promises).then(function () {
                            var orderedHistoryList = { pinned: [], nonPinned: {}, totalItems: history.length };

                            // To properly sort the history list we need to compare dates
                            // because email doesn't have the modified key we decided
                            // to add an extra key called historySortDate which the list
                            // uses to sort properly. We add the sent_date of email to the
                            // object, and the modified date for the other types.
                            for (i = 0; i < history.length; i++) {
                                if (history[i].historyType === 'email') {
                                    history[i].historySortDate = history[i].sent_date;
                                } else if (history[i].historyType === 'note') {
                                    // We want to sort notes on created date.
                                    history[i].historySortDate = history[i].date;
                                } else {
                                    history[i].historySortDate = history[i].modified;
                                }
                            }

                            $filter('orderBy')(history, 'historySortDate', true).forEach(function (item) {
                                var date = '';
                                var key = '';
                                var parentObjectId = scope.parentObject ? scope.parentObject.id : null;

                                scope.history.types[item.historyType].visible = true;

                                if (item.is_pinned) {
                                    orderedHistoryList.pinned.push(item);
                                } else {
                                    // Exclude the current item from the history list.
                                    if (item.id !== scope.object.id && item.id !== parentObjectId) {
                                        if (item.hasOwnProperty('modified')) {
                                            date = item.modified;
                                        } else {
                                            date = item.sent_date;
                                        }

                                        key = moment(date).year() + '-' + (moment(date).month() + 1);

                                        if (!orderedHistoryList.nonPinned.hasOwnProperty(key)) {
                                            orderedHistoryList.nonPinned[key] = { isVisible: true, items: [] };
                                        }

                                        if (scope.target === 'case' && item.historyType === 'note' && item.content_type === 'case') {
                                            item.shown = true;
                                        }

                                        orderedHistoryList.nonPinned[key].items.push(item);
                                    } else {
                                        orderedHistoryList.totalItems -= 1;
                                    }
                                }
                            });

                            // Get first key in the nonPinned list to target the first
                            // item in the history items to set the property to shown.
                            if (scope.target !== 'case' && Object.keys(orderedHistoryList.nonPinned).length) {
                                orderedHistoryList.nonPinned[Object.keys(orderedHistoryList.nonPinned)[0]].items[0].shown = true;
                            }

                            scope.history.list = orderedHistoryList;

                            HLUtils.unblockUI('#historyListBlockTarget');
                        });
                    }

                    function addNote(note, form) {
                        note.content_type = scope.object.content_type.id;
                        note.object_id = scope.object.id;

                        Note.save(note, function () {
                            // Success.
                            scope.note.content = '';
                            toastr.success('I\'ve created the note for you!', 'Done');
                            reloadHistory();
                        }, function (response) {
                            // Error.
                            HLForms.setErrors(form, response.data);
                            toastr.error('Uh oh, there seems to be a problem', 'Oops!');
                        });
                    }

                    function pinNote(note, isPinned) {
                        Note.update({ id: note.id }, { is_pinned: isPinned }, function () {
                            $state.go($state.current, {}, { reload: true });
                        });
                    }

                    function removeFromList(item) {
                        var month = moment(item.modified).format('M');
                        var year = moment(item.modified).format('YYYY');
                        var index;

                        if (item.is_pinned) {
                            index = scope.history.list.pinned.indexOf(item);
                            scope.history.list.pinned.splice(index, 1);
                        } else {
                            index = scope.history.list.nonPinned[year + '-' + month].items.indexOf(item);
                            scope.history.list.nonPinned[year + '-' + month].items.splice(index, 1);
                        }

                        // We might be deleting the last object of a certain month.
                        // Check if there are still items and hide the block if needed.
                        if (!scope.history.list.nonPinned[year + '-' + month].items.length) {
                            scope.history.list.nonPinned[year + '-' + month].isVisible = false;
                        }

                        scope.$apply();
                    }
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.utils.directives').directive('historyListItem', HistoryListItemDirective);

        HistoryListItemDirective.$inject = ['$compile', '$http', '$templateCache'];
        function HistoryListItemDirective($compile, $http, $templateCache) {
            return {
                restrict: 'E',
                scope: {
                    item: '=',
                    history: '=',
                    object: '=',
                    deleteCallback: '&?',
                    updateCallback: '&?'
                },
                link: function link(scope, element, attrs) {
                    var getTemplate = function getTemplate(historyType) {
                        var templateLoader;
                        var baseUrl = 'utils/directives/history_list_';
                        var templateMap = {
                            case: 'case.html',
                            deal: 'deal.html',
                            email: 'email.html',
                            note: 'note.html'
                        };

                        var templateUrl = baseUrl + templateMap[historyType];
                        templateLoader = $http.get(templateUrl, { cache: $templateCache });

                        return templateLoader;
                    };
                    getTemplate(scope.vm.item.historyType).success(function (html) {
                        element.replaceWith($compile(html)(scope));
                    }).then(function () {
                        element.replaceWith($compile(element.html())(scope));
                    });
                },
                controller: HistoryListItemController,
                bindToController: true,
                controllerAs: 'vm'
            };
        }

        HistoryListItemController.$inject = ['$state'];
        function HistoryListItemController($state) {
            var vm = this;

            vm.replyOnEmail = replyOnEmail;

            /////

            function replyOnEmail() {
                // Check if the emailaccount belongs to the current contact or account.
                angular.forEach(vm.object.email_addresses, function (emailAddress) {
                    if (emailAddress.email_address === vm.item.sender_email && emailAddress.status === 0) {
                        // Is status is inactive, try to find other email address.
                        _replyToGoodEmailAddress();
                    }
                });

                function _replyToGoodEmailAddress() {
                    // Try to find primary.
                    angular.forEach(vm.object.email_addresses, function (emailAddress) {
                        if (emailAddress.status === 2) {
                            $state.go('base.email.replyOtherEmail', { id: vm.item.id, email: emailAddress.email_address });
                        }
                    });

                    // Other will do as alternative.
                    angular.forEach(vm.object.email_addresses, function (emailAddress) {
                        if (emailAddress.status === 1) {
                            $state.go('base.email.replyOtherEmail', { id: vm.item.id, email: emailAddress.email_address });
                        }
                    });
                }

                $state.go('base.email.reply', { id: vm.item.id });
            }
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.utils.directives').directive('passwordConfirmation', PasswordConfirmationDirective);

        PasswordConfirmationDirective.$inject = [];
        function PasswordConfirmationDirective() {
            return {
                restrict: 'E',
                templateUrl: 'utils/directives/password_confirmation.html',
                transclude: true,
                link: function link(scope, element, attrs, collapsableCtrl) {
                    djangoPasswordStrength.initListeners(element);
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.utils.directives').directive('passwordStrength', PasswordStrengthDirective);

        PasswordStrengthDirective.$inject = [];
        function PasswordStrengthDirective() {
            return {
                restrict: 'E',
                templateUrl: 'utils/directives/password_strength.html',
                transclude: true,
                link: function link(scope, element, attrs, collapsableCtrl) {
                    djangoPasswordStrength.initListeners(element);
                }
            };
        }
    }, {}] }, {}, [1]);})(angular);
(function(angular){'use strict';"use strict";

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        angular.module('app.utils.directives').directive('postpone', postponeDirective);

        function postponeDirective() {
            return {
                restrict: 'E',
                scope: {
                    object: '=',
                    type: '=',
                    dateField: '=',
                    callback: '&',
                    ttPlacement: '@' },
                templateUrl: 'utils/directives/postpone.html',
                controller: PostponeController,
                controllerAs: 'vm',
                bindToController: true
            };
        }

        PostponeController.$inject = ['$compile', '$injector', '$scope', '$state', '$templateCache', '$timeout', 'HLResource', 'HLUtils'];
        function PostponeController($compile, $injector, $scope, $state, $templateCache, $timeout, HLResource, HLUtils) {
            var vm = this;

            vm.datepickerOptions = {
                startingDay: 1 };

            vm.disabledDates = disabledDates;
            vm.postponeWithDays = postponeWithDays;
            vm.getFutureDate = getFutureDate;
            vm.openPostponeModal = openPostponeModal;

            activate();

            ////

            function activate() {
                if (vm.object[vm.dateField]) {
                    vm.date = moment(vm.object[vm.dateField]);
                } else {
                    vm.date = moment();
                }

                vm.date = vm.date.toDate();

                _watchCloseDatePicker();
            }

            /**
             * When the datepicker popup is closed, update model and close modal.
             *
             * @private
             */
            function _watchCloseDatePicker() {
                $scope.$watch('vm.pickerIsOpen', function (newValue, oldValue) {
                    // Don't close the whole modal if we didn't change anything.
                    if (!moment(vm.date).isSame(moment(vm.object[vm.dateField]))) {
                        if (!newValue && oldValue) {
                            _updateDayAndCloseModal();
                        }
                    }
                });
            }

            function _updateDayAndCloseModal() {
                var newDate;
                var args;

                if (!moment(vm.date).isSame(moment(vm.object[vm.dateField]))) {
                    // Update the due date for this case.
                    newDate = moment(vm.date).format('YYYY-MM-DD');

                    args = {
                        id: vm.object.id
                    };

                    args[vm.dateField] = newDate;
                    // Update the model so changes are reflected instantly.
                    vm.object[vm.dateField] = newDate;

                    // Dynamically get the model that should be updated.
                    HLResource.patch(vm.type, args).$promise.then(function () {
                        swal.close();
                        _processClose();
                    });
                } else {
                    swal.close();
                    _processClose();
                }
            }

            function _processClose() {
                if (vm.callback) {
                    vm.callback();
                } else {
                    $state.go($state.current, {}, { reload: true });
                }
            }

            function disabledDates(currentDate, mode) {
                var date = moment.isMoment(currentDate) ? currentDate : moment(currentDate);

                // Disable Saturday and Sunday.
                return mode === 'day' && (date.day() === 6 || date.day() === 0);
            }

            function postponeWithDays(days) {
                vm.date = getFutureDate(days);

                // Set timeout to wait for next digest cycle before being able to set
                // the date correctly.
                $timeout(function () {
                    _updateDayAndCloseModal();
                });
            }

            function getFutureDate(days) {
                var daysToAdd;

                var futureDate = moment();

                if (days) {
                    daysToAdd = days;

                    if (futureDate.isBefore(vm.date)) {
                        futureDate = moment(vm.date);
                    }
                } else {
                    // The date should be the current date.
                    daysToAdd = 0;
                }

                futureDate = HLUtils.addBusinessDays(daysToAdd, futureDate);

                return futureDate;
            }

            function openPostponeModal() {
                // Google Analytics events per page to track where users use the
                // postpone functionality.
                if ($state.current.name === 'base.dashboard') {
                    ga('send', 'event', vm.type, 'Open postpone modal', 'Dashboard');
                }

                if ($state.current.name === 'base.cases.detail') {
                    ga('send', 'event', 'Case', 'Open postpone modal', 'Case detail');
                }

                if ($state.current.name === 'base.cases') {
                    ga('send', 'event', 'Case', 'Open postpone modal', 'Cases list view');
                }

                if ($state.current.name === 'base.deals.detail') {
                    ga('send', 'event', 'Deal', 'Open postpone modal', 'Deal detail');
                }

                if ($state.current.name === 'base.deals') {
                    ga('send', 'event', 'Deal', 'Open postpone modal', 'Deal list view');
                }

                if ($state.current.name === 'base.accounts.detail') {
                    ga('send', 'event', vm.type, 'Open postpone modal', 'Account detail');
                }

                if ($state.current.name === 'base.contacts.detail') {
                    ga('send', 'event', vm.type, 'Open postpone modal', 'Contact detail');
                }

                vm.bodyText = messages.alerts.postpone[vm.type.toLowerCase()];

                swal({
                    title: messages.alerts.postpone[vm.type.toLowerCase() + 'Title'],
                    html: $compile($templateCache.get('utils/controllers/postpone.html'))($scope),
                    showCloseButton: true
                }).then(function (isConfirm) {
                    if (isConfirm) {
                        _updateDayAndCloseModal();
                    }
                }).done();
            }
        }
    }, {}] }, {}, [1]);})(angular);
//# sourceMappingURL=app.js.map